
user/sbin/init.exec:     file format elf32-i386


Disassembly of section .text:

08048094 <open_tty>:
const char      *ttystr = "tty";
const char      *home = "/";
const char      *alldone = "init: no remaining processes\n";

static int open_tty(char *tty)
{
 8048094:	55                   	push   %ebp
 8048095:	89 e5                	mov    %esp,%ebp
 8048097:	83 ec 18             	sub    $0x18,%esp
        if (-1 == open(tty, O_RDONLY, 0)) {
 804809a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 80480a1:	00 
 80480a2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 80480a9:	00 
 80480aa:	8b 45 08             	mov    0x8(%ebp),%eax
 80480ad:	89 04 24             	mov    %eax,(%esp)
 80480b0:	e8 18 16 00 00       	call   80496cd <open>
 80480b5:	83 f8 ff             	cmp    $0xffffffff,%eax
 80480b8:	75 07                	jne    80480c1 <open_tty+0x2d>
                return -1;
 80480ba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80480bf:	eb 44                	jmp    8048105 <open_tty+0x71>
        } else if (-1 == open(tty, O_WRONLY, 0)) {
 80480c1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 80480c8:	00 
 80480c9:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 80480d0:	00 
 80480d1:	8b 45 08             	mov    0x8(%ebp),%eax
 80480d4:	89 04 24             	mov    %eax,(%esp)
 80480d7:	e8 f1 15 00 00       	call   80496cd <open>
 80480dc:	83 f8 ff             	cmp    $0xffffffff,%eax
 80480df:	75 07                	jne    80480e8 <open_tty+0x54>
                return -1;
 80480e1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80480e6:	eb 1d                	jmp    8048105 <open_tty+0x71>
        } else if (2 != dup(1)) {
 80480e8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 80480ef:	e8 c6 17 00 00       	call   80498ba <dup>
 80480f4:	83 f8 02             	cmp    $0x2,%eax
 80480f7:	74 07                	je     8048100 <open_tty+0x6c>
                return -1;
 80480f9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80480fe:	eb 05                	jmp    8048105 <open_tty+0x71>
        } else {
                return 0;
 8048100:	b8 00 00 00 00       	mov    $0x0,%eax
        }
}
 8048105:	c9                   	leave  
 8048106:	c3                   	ret    

08048107 <spawn_shell_on>:

static void spawn_shell_on(char *tty)
{
 8048107:	55                   	push   %ebp
 8048108:	89 e5                	mov    %esp,%ebp
 804810a:	83 ec 18             	sub    $0x18,%esp
        if (!fork()) {
 804810d:	e8 72 11 00 00       	call   8049284 <fork>
 8048112:	85 c0                	test   %eax,%eax
 8048114:	0f 85 b3 00 00 00    	jne    80481cd <spawn_shell_on+0xc6>
                close(0);
 804811a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8048121:	e8 43 17 00 00       	call   8049869 <close>
                close(1);
 8048126:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804812d:	e8 37 17 00 00       	call   8049869 <close>
                close(2);
 8048132:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8048139:	e8 2b 17 00 00       	call   8049869 <close>
                if (-1 == open_tty(tty)) {
 804813e:	8b 45 08             	mov    0x8(%ebp),%eax
 8048141:	89 04 24             	mov    %eax,(%esp)
 8048144:	e8 4b ff ff ff       	call   8048094 <open_tty>
 8048149:	83 f8 ff             	cmp    $0xffffffff,%eax
 804814c:	75 0c                	jne    804815a <spawn_shell_on+0x53>
                        exit(1);
 804814e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8048155:	e8 06 12 00 00       	call   8049360 <exit>
                }

                chdir(home);
 804815a:	a1 ac 01 05 08       	mov    0x80501ac,%eax
 804815f:	89 04 24             	mov    %eax,(%esp)
 8048162:	e8 32 1a 00 00       	call   8049b99 <chdir>

                printf(hi, NULL);
 8048167:	a1 a0 01 05 08       	mov    0x80501a0,%eax
 804816c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048173:	00 
 8048174:	89 04 24             	mov    %eax,(%esp)
 8048177:	e8 c4 01 00 00       	call   8048340 <printf>
                printf(tty, NULL);
 804817c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048183:	00 
 8048184:	8b 45 08             	mov    0x8(%ebp),%eax
 8048187:	89 04 24             	mov    %eax,(%esp)
 804818a:	e8 b1 01 00 00       	call   8048340 <printf>
                printf("\n");
 804818f:	c7 04 24 f1 d6 04 08 	movl   $0x804d6f1,(%esp)
 8048196:	e8 a5 01 00 00       	call   8048340 <printf>

                execve(sh, empty, empty);
 804819b:	a1 a4 01 05 08       	mov    0x80501a4,%eax
 80481a0:	c7 44 24 08 00 03 05 	movl   $0x8050300,0x8(%esp)
 80481a7:	08 
 80481a8:	c7 44 24 04 00 03 05 	movl   $0x8050300,0x4(%esp)
 80481af:	08 
 80481b0:	89 04 24             	mov    %eax,(%esp)
 80481b3:	e8 9a 1a 00 00       	call   8049c52 <execve>
                fprintf(stderr, "exec failed!\n");
 80481b8:	a1 c8 01 05 08       	mov    0x80501c8,%eax
 80481bd:	c7 44 24 04 f3 d6 04 	movl   $0x804d6f3,0x4(%esp)
 80481c4:	08 
 80481c5:	89 04 24             	mov    %eax,(%esp)
 80481c8:	e8 ab 01 00 00       	call   8048378 <fprintf>
        }
}
 80481cd:	c9                   	leave  
 80481ce:	c3                   	ret    

080481cf <main>:

int main(int argc, char **argv, char **envp)
{
 80481cf:	55                   	push   %ebp
 80481d0:	89 e5                	mov    %esp,%ebp
 80481d2:	83 e4 f0             	and    $0xfffffff0,%esp
 80481d5:	83 ec 50             	sub    $0x50,%esp
        int      devdir, ii;
        dirent_t d;
        int      status;

        for (ii = 0; ii < NFILES; ii++)
 80481d8:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%esp)
 80481df:	00 
 80481e0:	eb 11                	jmp    80481f3 <main+0x24>
                close(ii);
 80481e2:	8b 44 24 4c          	mov    0x4c(%esp),%eax
 80481e6:	89 04 24             	mov    %eax,(%esp)
 80481e9:	e8 7b 16 00 00       	call   8049869 <close>
{
        int      devdir, ii;
        dirent_t d;
        int      status;

        for (ii = 0; ii < NFILES; ii++)
 80481ee:	83 44 24 4c 01       	addl   $0x1,0x4c(%esp)
 80481f3:	83 7c 24 4c 1f       	cmpl   $0x1f,0x4c(%esp)
 80481f8:	7e e8                	jle    80481e2 <main+0x13>
                close(ii);
        ii  = ii;

        if (-1 == open_tty("/dev/tty0")) {
 80481fa:	c7 04 24 01 d7 04 08 	movl   $0x804d701,(%esp)
 8048201:	e8 8e fe ff ff       	call   8048094 <open_tty>
 8048206:	83 f8 ff             	cmp    $0xffffffff,%eax
 8048209:	75 0c                	jne    8048217 <main+0x48>
                exit(1);
 804820b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8048212:	e8 49 11 00 00       	call   8049360 <exit>
        }

        chdir("/dev");
 8048217:	c7 04 24 0b d7 04 08 	movl   $0x804d70b,(%esp)
 804821e:	e8 76 19 00 00       	call   8049b99 <chdir>

        devdir = open("/dev", O_RDONLY, 0);
 8048223:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804822a:	00 
 804822b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048232:	00 
 8048233:	c7 04 24 0b d7 04 08 	movl   $0x804d70b,(%esp)
 804823a:	e8 8e 14 00 00       	call   80496cd <open>
 804823f:	89 44 24 48          	mov    %eax,0x48(%esp)
        while (getdents(devdir, &d, sizeof(d)) > 0) {
 8048243:	eb 3d                	jmp    8048282 <main+0xb3>
                if (0 == strncmp(d.d_name, ttystr, strlen(ttystr))) {
 8048245:	a1 a8 01 05 08       	mov    0x80501a8,%eax
 804824a:	89 04 24             	mov    %eax,(%esp)
 804824d:	e8 1f 05 00 00       	call   8048771 <strlen>
 8048252:	8b 15 a8 01 05 08    	mov    0x80501a8,%edx
 8048258:	89 44 24 08          	mov    %eax,0x8(%esp)
 804825c:	89 54 24 04          	mov    %edx,0x4(%esp)
 8048260:	8d 44 24 1c          	lea    0x1c(%esp),%eax
 8048264:	83 c0 08             	add    $0x8,%eax
 8048267:	89 04 24             	mov    %eax,(%esp)
 804826a:	e8 42 03 00 00       	call   80485b1 <strncmp>
 804826f:	85 c0                	test   %eax,%eax
 8048271:	75 0f                	jne    8048282 <main+0xb3>
                        spawn_shell_on(d.d_name);
 8048273:	8d 44 24 1c          	lea    0x1c(%esp),%eax
 8048277:	83 c0 08             	add    $0x8,%eax
 804827a:	89 04 24             	mov    %eax,(%esp)
 804827d:	e8 85 fe ff ff       	call   8048107 <spawn_shell_on>
        }

        chdir("/dev");

        devdir = open("/dev", O_RDONLY, 0);
        while (getdents(devdir, &d, sizeof(d)) > 0) {
 8048282:	c7 44 24 08 28 00 00 	movl   $0x28,0x8(%esp)
 8048289:	00 
 804828a:	8d 44 24 1c          	lea    0x1c(%esp),%eax
 804828e:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048292:	8b 44 24 48          	mov    0x48(%esp),%eax
 8048296:	89 04 24             	mov    %eax,(%esp)
 8048299:	e8 19 1c 00 00       	call   8049eb7 <getdents>
 804829e:	85 c0                	test   %eax,%eax
 80482a0:	7f a3                	jg     8048245 <main+0x76>
                if (0 == strncmp(d.d_name, ttystr, strlen(ttystr))) {
                        spawn_shell_on(d.d_name);
                }
        }
        close(devdir);
 80482a2:	8b 44 24 48          	mov    0x48(%esp),%eax
 80482a6:	89 04 24             	mov    %eax,(%esp)
 80482a9:	e8 bb 15 00 00       	call   8049869 <close>

        int pid;
        while (0 <= (pid = wait(&status))) {
 80482ae:	eb 1d                	jmp    80482cd <main+0xfe>
                if (EFAULT == status) {
 80482b0:	8b 44 24 18          	mov    0x18(%esp),%eax
 80482b4:	83 f8 0e             	cmp    $0xe,%eax
 80482b7:	75 14                	jne    80482cd <main+0xfe>
                        printf("process %i faulted\n", pid);
 80482b9:	8b 44 24 44          	mov    0x44(%esp),%eax
 80482bd:	89 44 24 04          	mov    %eax,0x4(%esp)
 80482c1:	c7 04 24 10 d7 04 08 	movl   $0x804d710,(%esp)
 80482c8:	e8 73 00 00 00       	call   8048340 <printf>
                }
        }
        close(devdir);

        int pid;
        while (0 <= (pid = wait(&status))) {
 80482cd:	8d 44 24 18          	lea    0x18(%esp),%eax
 80482d1:	89 04 24             	mov    %eax,(%esp)
 80482d4:	e8 19 11 00 00       	call   80493f2 <wait>
 80482d9:	89 44 24 44          	mov    %eax,0x44(%esp)
 80482dd:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
 80482e2:	79 cc                	jns    80482b0 <main+0xe1>
                if (EFAULT == status) {
                        printf("process %i faulted\n", pid);
                }
        }

        if (ECHILD != errno) {
 80482e4:	a1 20 04 05 08       	mov    0x8050420,%eax
 80482e9:	83 f8 0a             	cmp    $0xa,%eax
 80482ec:	74 24                	je     8048312 <main+0x143>
                printf("error: wait: %s\n", strerror(errno));
 80482ee:	a1 20 04 05 08       	mov    0x8050420,%eax
 80482f3:	89 04 24             	mov    %eax,(%esp)
 80482f6:	e8 d4 06 00 00       	call   80489cf <strerror>
 80482fb:	89 44 24 04          	mov    %eax,0x4(%esp)
 80482ff:	c7 04 24 24 d7 04 08 	movl   $0x804d724,(%esp)
 8048306:	e8 35 00 00 00       	call   8048340 <printf>
                return 1;
 804830b:	b8 01 00 00 00       	mov    $0x1,%eax
 8048310:	eb 1a                	jmp    804832c <main+0x15d>
        } else {
                printf(alldone, NULL);
 8048312:	a1 b0 01 05 08       	mov    0x80501b0,%eax
 8048317:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804831e:	00 
 804831f:	89 04 24             	mov    %eax,(%esp)
 8048322:	e8 19 00 00 00       	call   8048340 <printf>
                return 0;
 8048327:	b8 00 00 00 00       	mov    $0x0,%eax
        }
}
 804832c:	c9                   	leave  
 804832d:	c3                   	ret    
 804832e:	90                   	nop
 804832f:	90                   	nop

08048330 <__libc_static_entry>:
#ifndef __DYNAMIC__

.globl __libc_static_entry

__libc_static_entry:
	addl $4, %esp; /* Make sure when we overwrite dummy return address
 8048330:	83 c4 04             	add    $0x4,%esp
	                  with the correct one, so args will be in the right
	                  place when we call main */
	call main;
 8048333:	e8 97 fe ff ff       	call   80481cf <main>
	push %eax; /* Argument to exit is return value from main */
 8048338:	50                   	push   %eax
	call exit;
 8048339:	e8 22 10 00 00       	call   8049360 <exit>
 804833e:	90                   	nop
 804833f:	90                   	nop

08048340 <printf>:

#include "stdio.h"
#include "unistd.h"

int printf(const char *fmt, ...)
{
 8048340:	55                   	push   %ebp
 8048341:	89 e5                	mov    %esp,%ebp
 8048343:	53                   	push   %ebx
 8048344:	83 ec 24             	sub    $0x24,%esp
 8048347:	e8 d5 01 00 00       	call   8048521 <__i686.get_pc_thunk.bx>
 804834c:	81 c3 34 7e 00 00    	add    $0x7e34,%ebx
        va_list args;
        int i;

        va_start(args, fmt);
 8048352:	8d 55 0c             	lea    0xc(%ebp),%edx
 8048355:	8d 45 f0             	lea    -0x10(%ebp),%eax
 8048358:	89 10                	mov    %edx,(%eax)
        i = vprintf(fmt, args);
 804835a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804835d:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048361:	8b 45 08             	mov    0x8(%ebp),%eax
 8048364:	89 04 24             	mov    %eax,(%esp)
 8048367:	e8 d0 00 00 00       	call   804843c <vprintf>
 804836c:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 804836f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048372:	83 c4 24             	add    $0x24,%esp
 8048375:	5b                   	pop    %ebx
 8048376:	5d                   	pop    %ebp
 8048377:	c3                   	ret    

08048378 <fprintf>:

int fprintf(FILE *stream, const char *fmt, ...)
{
 8048378:	55                   	push   %ebp
 8048379:	89 e5                	mov    %esp,%ebp
 804837b:	53                   	push   %ebx
 804837c:	83 ec 24             	sub    $0x24,%esp
 804837f:	e8 9d 01 00 00       	call   8048521 <__i686.get_pc_thunk.bx>
 8048384:	81 c3 fc 7d 00 00    	add    $0x7dfc,%ebx
        va_list args;
        int i;

        va_start(args, fmt);
 804838a:	8d 55 10             	lea    0x10(%ebp),%edx
 804838d:	8d 45 f0             	lea    -0x10(%ebp),%eax
 8048390:	89 10                	mov    %edx,(%eax)
        i = vfprintf(stream, fmt, args);
 8048392:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048395:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048399:	8b 45 0c             	mov    0xc(%ebp),%eax
 804839c:	89 44 24 04          	mov    %eax,0x4(%esp)
 80483a0:	8b 45 08             	mov    0x8(%ebp),%eax
 80483a3:	89 04 24             	mov    %eax,(%esp)
 80483a6:	e8 c7 00 00 00       	call   8048472 <vfprintf>
 80483ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 80483ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 80483b1:	83 c4 24             	add    $0x24,%esp
 80483b4:	5b                   	pop    %ebx
 80483b5:	5d                   	pop    %ebp
 80483b6:	c3                   	ret    

080483b7 <sprintf>:

int sprintf(char *buf, const char *fmt, ...)
{
 80483b7:	55                   	push   %ebp
 80483b8:	89 e5                	mov    %esp,%ebp
 80483ba:	53                   	push   %ebx
 80483bb:	83 ec 24             	sub    $0x24,%esp
 80483be:	e8 5e 01 00 00       	call   8048521 <__i686.get_pc_thunk.bx>
 80483c3:	81 c3 bd 7d 00 00    	add    $0x7dbd,%ebx
        va_list args;
        int i;

        va_start(args, fmt);
 80483c9:	8d 55 10             	lea    0x10(%ebp),%edx
 80483cc:	8d 45 f0             	lea    -0x10(%ebp),%eax
 80483cf:	89 10                	mov    %edx,(%eax)
        i = vsprintf(buf, fmt, args);
 80483d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80483d4:	89 44 24 08          	mov    %eax,0x8(%esp)
 80483d8:	8b 45 0c             	mov    0xc(%ebp),%eax
 80483db:	89 44 24 04          	mov    %eax,0x4(%esp)
 80483df:	8b 45 08             	mov    0x8(%ebp),%eax
 80483e2:	89 04 24             	mov    %eax,(%esp)
 80483e5:	e8 f4 00 00 00       	call   80484de <vsprintf>
 80483ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 80483ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 80483f0:	83 c4 24             	add    $0x24,%esp
 80483f3:	5b                   	pop    %ebx
 80483f4:	5d                   	pop    %ebp
 80483f5:	c3                   	ret    

080483f6 <snprintf>:

int snprintf(char *buf, size_t size, const char *fmt, ...)
{
 80483f6:	55                   	push   %ebp
 80483f7:	89 e5                	mov    %esp,%ebp
 80483f9:	53                   	push   %ebx
 80483fa:	83 ec 24             	sub    $0x24,%esp
 80483fd:	e8 1f 01 00 00       	call   8048521 <__i686.get_pc_thunk.bx>
 8048402:	81 c3 7e 7d 00 00    	add    $0x7d7e,%ebx
        va_list args;
        int i;

        va_start(args, fmt);
 8048408:	8d 55 14             	lea    0x14(%ebp),%edx
 804840b:	8d 45 f0             	lea    -0x10(%ebp),%eax
 804840e:	89 10                	mov    %edx,(%eax)
        i = vsnprintf(buf, size, fmt, args);
 8048410:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048413:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8048417:	8b 45 10             	mov    0x10(%ebp),%eax
 804841a:	89 44 24 08          	mov    %eax,0x8(%esp)
 804841e:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048421:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048425:	8b 45 08             	mov    0x8(%ebp),%eax
 8048428:	89 04 24             	mov    %eax,(%esp)
 804842b:	e8 ab 20 00 00       	call   804a4db <vsnprintf>
 8048430:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 8048433:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048436:	83 c4 24             	add    $0x24,%esp
 8048439:	5b                   	pop    %ebx
 804843a:	5d                   	pop    %ebp
 804843b:	c3                   	ret    

0804843c <vprintf>:

int vprintf(const char *fmt, va_list args)
{
 804843c:	55                   	push   %ebp
 804843d:	89 e5                	mov    %esp,%ebp
 804843f:	53                   	push   %ebx
 8048440:	83 ec 14             	sub    $0x14,%esp
 8048443:	e8 d9 00 00 00       	call   8048521 <__i686.get_pc_thunk.bx>
 8048448:	81 c3 38 7d 00 00    	add    $0x7d38,%ebx
        return vfprintf(stdout, fmt, args);
 804844e:	8b 83 f4 ff ff ff    	mov    -0xc(%ebx),%eax
 8048454:	8b 00                	mov    (%eax),%eax
 8048456:	8b 55 0c             	mov    0xc(%ebp),%edx
 8048459:	89 54 24 08          	mov    %edx,0x8(%esp)
 804845d:	8b 55 08             	mov    0x8(%ebp),%edx
 8048460:	89 54 24 04          	mov    %edx,0x4(%esp)
 8048464:	89 04 24             	mov    %eax,(%esp)
 8048467:	e8 06 00 00 00       	call   8048472 <vfprintf>
}
 804846c:	83 c4 14             	add    $0x14,%esp
 804846f:	5b                   	pop    %ebx
 8048470:	5d                   	pop    %ebp
 8048471:	c3                   	ret    

08048472 <vfprintf>:

#define __LIBC_PRINTF_BUFSIZE 1024
int vfprintf(FILE *stream, const char *fmt, va_list args)
{
 8048472:	55                   	push   %ebp
 8048473:	89 e5                	mov    %esp,%ebp
 8048475:	53                   	push   %ebx
 8048476:	81 ec 24 04 00 00    	sub    $0x424,%esp
 804847c:	e8 a0 00 00 00       	call   8048521 <__i686.get_pc_thunk.bx>
 8048481:	81 c3 ff 7c 00 00    	add    $0x7cff,%ebx
        /* I'm really lazy */
        char buf[__LIBC_PRINTF_BUFSIZE];
        int ret = vsnprintf(buf, __LIBC_PRINTF_BUFSIZE, fmt, args);
 8048487:	8b 45 10             	mov    0x10(%ebp),%eax
 804848a:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804848e:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048491:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048495:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
 804849c:	00 
 804849d:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
 80484a3:	89 04 24             	mov    %eax,(%esp)
 80484a6:	e8 30 20 00 00       	call   804a4db <vsnprintf>
 80484ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (ret > 0) {
 80484ae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 80484b2:	7e 1e                	jle    80484d2 <vfprintf+0x60>
                write(*stream, buf, ret);
 80484b4:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80484b7:	8b 45 08             	mov    0x8(%ebp),%eax
 80484ba:	8b 00                	mov    (%eax),%eax
 80484bc:	89 54 24 08          	mov    %edx,0x8(%esp)
 80484c0:	8d 95 f4 fb ff ff    	lea    -0x40c(%ebp),%edx
 80484c6:	89 54 24 04          	mov    %edx,0x4(%esp)
 80484ca:	89 04 24             	mov    %eax,(%esp)
 80484cd:	e8 34 13 00 00       	call   8049806 <write>
        }
        return ret;
 80484d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 80484d5:	81 c4 24 04 00 00    	add    $0x424,%esp
 80484db:	5b                   	pop    %ebx
 80484dc:	5d                   	pop    %ebp
 80484dd:	c3                   	ret    

080484de <vsprintf>:

int vsprintf(char *buf, const char *fmt, va_list args)
{
 80484de:	55                   	push   %ebp
 80484df:	89 e5                	mov    %esp,%ebp
 80484e1:	53                   	push   %ebx
 80484e2:	83 ec 14             	sub    $0x14,%esp
 80484e5:	e8 37 00 00 00       	call   8048521 <__i686.get_pc_thunk.bx>
 80484ea:	81 c3 96 7c 00 00    	add    $0x7c96,%ebx
        return vsnprintf(buf, 0xffffffffUL, fmt, args);
 80484f0:	8b 45 10             	mov    0x10(%ebp),%eax
 80484f3:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80484f7:	8b 45 0c             	mov    0xc(%ebp),%eax
 80484fa:	89 44 24 08          	mov    %eax,0x8(%esp)
 80484fe:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
 8048505:	ff 
 8048506:	8b 45 08             	mov    0x8(%ebp),%eax
 8048509:	89 04 24             	mov    %eax,(%esp)
 804850c:	e8 ca 1f 00 00       	call   804a4db <vsnprintf>
}
 8048511:	83 c4 14             	add    $0x14,%esp
 8048514:	5b                   	pop    %ebx
 8048515:	5d                   	pop    %ebp
 8048516:	c3                   	ret    

08048517 <fflush>:

int fflush(FILE *stream)
{
 8048517:	55                   	push   %ebp
 8048518:	89 e5                	mov    %esp,%ebp
        /* no-op */
        return 0;
 804851a:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804851f:	5d                   	pop    %ebp
 8048520:	c3                   	ret    

08048521 <__i686.get_pc_thunk.bx>:
 8048521:	8b 1c 24             	mov    (%esp),%ebx
 8048524:	c3                   	ret    
 8048525:	90                   	nop
 8048526:	90                   	nop
 8048527:	90                   	nop

08048528 <memcmp>:
#include "stdlib.h"
#include "string.h"
#include "errno.h"

int memcmp(const void *cs, const void *ct, size_t count)
{
 8048528:	55                   	push   %ebp
 8048529:	89 e5                	mov    %esp,%ebp
 804852b:	83 ec 10             	sub    $0x10,%esp
        const unsigned char *su1, *su2;
        signed char res = 0;
 804852e:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

        for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
 8048532:	8b 45 08             	mov    0x8(%ebp),%eax
 8048535:	89 45 fc             	mov    %eax,-0x4(%ebp)
 8048538:	8b 45 0c             	mov    0xc(%ebp),%eax
 804853b:	89 45 f8             	mov    %eax,-0x8(%ebp)
 804853e:	eb 27                	jmp    8048567 <memcmp+0x3f>
                if ((res = *su1 - *su2) != 0)
 8048540:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048543:	0f b6 10             	movzbl (%eax),%edx
 8048546:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048549:	0f b6 00             	movzbl (%eax),%eax
 804854c:	89 d1                	mov    %edx,%ecx
 804854e:	28 c1                	sub    %al,%cl
 8048550:	89 c8                	mov    %ecx,%eax
 8048552:	88 45 f7             	mov    %al,-0x9(%ebp)
 8048555:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
 8048559:	75 14                	jne    804856f <memcmp+0x47>
int memcmp(const void *cs, const void *ct, size_t count)
{
        const unsigned char *su1, *su2;
        signed char res = 0;

        for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
 804855b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804855f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
 8048563:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
 8048567:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804856b:	75 d3                	jne    8048540 <memcmp+0x18>
 804856d:	eb 01                	jmp    8048570 <memcmp+0x48>
                if ((res = *su1 - *su2) != 0)
                        break;
 804856f:	90                   	nop
        return res;
 8048570:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
}
 8048574:	c9                   	leave  
 8048575:	c3                   	ret    

08048576 <memcpy>:

void *memcpy(void *dest, const void *src, size_t count)
{
 8048576:	55                   	push   %ebp
 8048577:	89 e5                	mov    %esp,%ebp
 8048579:	83 ec 10             	sub    $0x10,%esp
        char *tmp = (char *) dest;
 804857c:	8b 45 08             	mov    0x8(%ebp),%eax
 804857f:	89 45 fc             	mov    %eax,-0x4(%ebp)
        const char *s = src;
 8048582:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048585:	89 45 f8             	mov    %eax,-0x8(%ebp)

        while (count--)
 8048588:	eb 13                	jmp    804859d <memcpy+0x27>
                *tmp++ = *s++;
 804858a:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804858d:	0f b6 10             	movzbl (%eax),%edx
 8048590:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048593:	88 10                	mov    %dl,(%eax)
 8048595:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 8048599:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
void *memcpy(void *dest, const void *src, size_t count)
{
        char *tmp = (char *) dest;
        const char *s = src;

        while (count--)
 804859d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 80485a1:	0f 95 c0             	setne  %al
 80485a4:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
 80485a8:	84 c0                	test   %al,%al
 80485aa:	75 de                	jne    804858a <memcpy+0x14>
                *tmp++ = *s++;

        return dest;
 80485ac:	8b 45 08             	mov    0x8(%ebp),%eax
}
 80485af:	c9                   	leave  
 80485b0:	c3                   	ret    

080485b1 <strncmp>:

int strncmp(const char *cs, const char *ct, size_t count)
{
 80485b1:	55                   	push   %ebp
 80485b2:	89 e5                	mov    %esp,%ebp
 80485b4:	56                   	push   %esi
        register signed char __res = 0;
 80485b5:	be 00 00 00 00       	mov    $0x0,%esi

        while (count) {
 80485ba:	eb 3c                	jmp    80485f8 <strncmp+0x47>
                if ((__res = *cs - *ct++) != 0 || !*cs++)
 80485bc:	8b 45 08             	mov    0x8(%ebp),%eax
 80485bf:	0f b6 00             	movzbl (%eax),%eax
 80485c2:	89 c2                	mov    %eax,%edx
 80485c4:	8b 45 0c             	mov    0xc(%ebp),%eax
 80485c7:	0f b6 00             	movzbl (%eax),%eax
 80485ca:	89 d1                	mov    %edx,%ecx
 80485cc:	28 c1                	sub    %al,%cl
 80485ce:	89 c8                	mov    %ecx,%eax
 80485d0:	89 c6                	mov    %eax,%esi
 80485d2:	89 f0                	mov    %esi,%eax
 80485d4:	84 c0                	test   %al,%al
 80485d6:	0f 95 c0             	setne  %al
 80485d9:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
 80485dd:	84 c0                	test   %al,%al
 80485df:	75 1d                	jne    80485fe <strncmp+0x4d>
 80485e1:	8b 45 08             	mov    0x8(%ebp),%eax
 80485e4:	0f b6 00             	movzbl (%eax),%eax
 80485e7:	84 c0                	test   %al,%al
 80485e9:	0f 94 c0             	sete   %al
 80485ec:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 80485f0:	84 c0                	test   %al,%al
 80485f2:	75 0a                	jne    80485fe <strncmp+0x4d>
                        break;
                count--;
 80485f4:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

int strncmp(const char *cs, const char *ct, size_t count)
{
        register signed char __res = 0;

        while (count) {
 80485f8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 80485fc:	75 be                	jne    80485bc <strncmp+0xb>
                if ((__res = *cs - *ct++) != 0 || !*cs++)
                        break;
                count--;
        }

        return __res;
 80485fe:	89 f2                	mov    %esi,%edx
 8048600:	0f be c2             	movsbl %dl,%eax
}
 8048603:	5e                   	pop    %esi
 8048604:	5d                   	pop    %ebp
 8048605:	c3                   	ret    

08048606 <strcmp>:

int strcmp(const char *cs, const char *ct)
{
 8048606:	55                   	push   %ebp
 8048607:	89 e5                	mov    %esp,%ebp
 8048609:	56                   	push   %esi
 804860a:	eb 01                	jmp    804860d <strcmp+0x7>
        register signed char __res;

        while (1) {
                if ((__res = *cs - *ct++) != 0 || !*cs++)
                        break;
        }
 804860c:	90                   	nop
int strcmp(const char *cs, const char *ct)
{
        register signed char __res;

        while (1) {
                if ((__res = *cs - *ct++) != 0 || !*cs++)
 804860d:	8b 45 08             	mov    0x8(%ebp),%eax
 8048610:	0f b6 00             	movzbl (%eax),%eax
 8048613:	89 c2                	mov    %eax,%edx
 8048615:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048618:	0f b6 00             	movzbl (%eax),%eax
 804861b:	89 d1                	mov    %edx,%ecx
 804861d:	28 c1                	sub    %al,%cl
 804861f:	89 c8                	mov    %ecx,%eax
 8048621:	89 c6                	mov    %eax,%esi
 8048623:	89 f0                	mov    %esi,%eax
 8048625:	84 c0                	test   %al,%al
 8048627:	0f 95 c0             	setne  %al
 804862a:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
 804862e:	84 c0                	test   %al,%al
 8048630:	75 13                	jne    8048645 <strcmp+0x3f>
 8048632:	8b 45 08             	mov    0x8(%ebp),%eax
 8048635:	0f b6 00             	movzbl (%eax),%eax
 8048638:	84 c0                	test   %al,%al
 804863a:	0f 94 c0             	sete   %al
 804863d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 8048641:	84 c0                	test   %al,%al
 8048643:	74 c7                	je     804860c <strcmp+0x6>
                        break;
        }

        return __res;
 8048645:	89 f2                	mov    %esi,%edx
 8048647:	0f be c2             	movsbl %dl,%eax
}
 804864a:	5e                   	pop    %esi
 804864b:	5d                   	pop    %ebp
 804864c:	c3                   	ret    

0804864d <strcpy>:

char *strcpy(char *dest, const char *src)
{
 804864d:	55                   	push   %ebp
 804864e:	89 e5                	mov    %esp,%ebp
 8048650:	83 ec 10             	sub    $0x10,%esp
        char *tmp = dest;
 8048653:	8b 45 08             	mov    0x8(%ebp),%eax
 8048656:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while ((*dest++ = *src++) != '\0')
 8048659:	90                   	nop
 804865a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804865d:	0f b6 10             	movzbl (%eax),%edx
 8048660:	8b 45 08             	mov    0x8(%ebp),%eax
 8048663:	88 10                	mov    %dl,(%eax)
 8048665:	8b 45 08             	mov    0x8(%ebp),%eax
 8048668:	0f b6 00             	movzbl (%eax),%eax
 804866b:	84 c0                	test   %al,%al
 804866d:	0f 95 c0             	setne  %al
 8048670:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 8048674:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
 8048678:	84 c0                	test   %al,%al
 804867a:	75 de                	jne    804865a <strcpy+0xd>
                /* nothing */;
        return tmp;
 804867c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804867f:	c9                   	leave  
 8048680:	c3                   	ret    

08048681 <strncpy>:

char *strncpy(char *dest, const char *src, size_t count)
{
 8048681:	55                   	push   %ebp
 8048682:	89 e5                	mov    %esp,%ebp
 8048684:	83 ec 10             	sub    $0x10,%esp
        char *tmp = dest;
 8048687:	8b 45 08             	mov    0x8(%ebp),%eax
 804868a:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (count-- && (*dest++ = *src++) != '\0')
 804868d:	90                   	nop
 804868e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 8048692:	0f 95 c0             	setne  %al
 8048695:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
 8048699:	84 c0                	test   %al,%al
 804869b:	74 22                	je     80486bf <strncpy+0x3e>
 804869d:	8b 45 0c             	mov    0xc(%ebp),%eax
 80486a0:	0f b6 10             	movzbl (%eax),%edx
 80486a3:	8b 45 08             	mov    0x8(%ebp),%eax
 80486a6:	88 10                	mov    %dl,(%eax)
 80486a8:	8b 45 08             	mov    0x8(%ebp),%eax
 80486ab:	0f b6 00             	movzbl (%eax),%eax
 80486ae:	84 c0                	test   %al,%al
 80486b0:	0f 95 c0             	setne  %al
 80486b3:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 80486b7:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
 80486bb:	84 c0                	test   %al,%al
 80486bd:	75 cf                	jne    804868e <strncpy+0xd>
                /* nothing */;

        return tmp;
 80486bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 80486c2:	c9                   	leave  
 80486c3:	c3                   	ret    

080486c4 <memset>:

void *memset(void *s, int c, size_t count)
{
 80486c4:	55                   	push   %ebp
 80486c5:	89 e5                	mov    %esp,%ebp
 80486c7:	83 ec 10             	sub    $0x10,%esp
        char *xs = (char *) s;
 80486ca:	8b 45 08             	mov    0x8(%ebp),%eax
 80486cd:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (count--)
 80486d0:	eb 0e                	jmp    80486e0 <memset+0x1c>
                *xs++ = c;
 80486d2:	8b 45 0c             	mov    0xc(%ebp),%eax
 80486d5:	89 c2                	mov    %eax,%edx
 80486d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80486da:	88 10                	mov    %dl,(%eax)
 80486dc:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)

void *memset(void *s, int c, size_t count)
{
        char *xs = (char *) s;

        while (count--)
 80486e0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 80486e4:	0f 95 c0             	setne  %al
 80486e7:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
 80486eb:	84 c0                	test   %al,%al
 80486ed:	75 e3                	jne    80486d2 <memset+0xe>
                *xs++ = c;

        return s;
 80486ef:	8b 45 08             	mov    0x8(%ebp),%eax
}
 80486f2:	c9                   	leave  
 80486f3:	c3                   	ret    

080486f4 <strnlen>:

size_t strnlen(const char *s, size_t count)
{
 80486f4:	55                   	push   %ebp
 80486f5:	89 e5                	mov    %esp,%ebp
 80486f7:	83 ec 10             	sub    $0x10,%esp
        const char *sc;

        for (sc = s; count-- && *sc != '\0'; ++sc)
 80486fa:	8b 45 08             	mov    0x8(%ebp),%eax
 80486fd:	89 45 fc             	mov    %eax,-0x4(%ebp)
 8048700:	eb 04                	jmp    8048706 <strnlen+0x12>
 8048702:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 8048706:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804870a:	0f 95 c0             	setne  %al
 804870d:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
 8048711:	84 c0                	test   %al,%al
 8048713:	74 0a                	je     804871f <strnlen+0x2b>
 8048715:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048718:	0f b6 00             	movzbl (%eax),%eax
 804871b:	84 c0                	test   %al,%al
 804871d:	75 e3                	jne    8048702 <strnlen+0xe>
                /* nothing */;
        return sc - s;
 804871f:	8b 55 fc             	mov    -0x4(%ebp),%edx
 8048722:	8b 45 08             	mov    0x8(%ebp),%eax
 8048725:	89 d1                	mov    %edx,%ecx
 8048727:	29 c1                	sub    %eax,%ecx
 8048729:	89 c8                	mov    %ecx,%eax
}
 804872b:	c9                   	leave  
 804872c:	c3                   	ret    

0804872d <strcat>:


char *strcat(char *dest, const char *src)
{
 804872d:	55                   	push   %ebp
 804872e:	89 e5                	mov    %esp,%ebp
 8048730:	83 ec 10             	sub    $0x10,%esp
        char *tmp = dest;
 8048733:	8b 45 08             	mov    0x8(%ebp),%eax
 8048736:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (*dest)
 8048739:	eb 04                	jmp    804873f <strcat+0x12>
                dest++;
 804873b:	83 45 08 01          	addl   $0x1,0x8(%ebp)

char *strcat(char *dest, const char *src)
{
        char *tmp = dest;

        while (*dest)
 804873f:	8b 45 08             	mov    0x8(%ebp),%eax
 8048742:	0f b6 00             	movzbl (%eax),%eax
 8048745:	84 c0                	test   %al,%al
 8048747:	75 f2                	jne    804873b <strcat+0xe>
                dest++;

        while ((*dest++ = *src++) != '\0');
 8048749:	90                   	nop
 804874a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804874d:	0f b6 10             	movzbl (%eax),%edx
 8048750:	8b 45 08             	mov    0x8(%ebp),%eax
 8048753:	88 10                	mov    %dl,(%eax)
 8048755:	8b 45 08             	mov    0x8(%ebp),%eax
 8048758:	0f b6 00             	movzbl (%eax),%eax
 804875b:	84 c0                	test   %al,%al
 804875d:	0f 95 c0             	setne  %al
 8048760:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 8048764:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
 8048768:	84 c0                	test   %al,%al
 804876a:	75 de                	jne    804874a <strcat+0x1d>

        return tmp;
 804876c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804876f:	c9                   	leave  
 8048770:	c3                   	ret    

08048771 <strlen>:

size_t strlen(const char *s)
{
 8048771:	55                   	push   %ebp
 8048772:	89 e5                	mov    %esp,%ebp
 8048774:	83 ec 10             	sub    $0x10,%esp
        const char *sc;

        for (sc = s; *sc != '\0'; ++sc)
 8048777:	8b 45 08             	mov    0x8(%ebp),%eax
 804877a:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804877d:	eb 04                	jmp    8048783 <strlen+0x12>
 804877f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 8048783:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048786:	0f b6 00             	movzbl (%eax),%eax
 8048789:	84 c0                	test   %al,%al
 804878b:	75 f2                	jne    804877f <strlen+0xe>
                /* nothing */;
        return sc - s;
 804878d:	8b 55 fc             	mov    -0x4(%ebp),%edx
 8048790:	8b 45 08             	mov    0x8(%ebp),%eax
 8048793:	89 d1                	mov    %edx,%ecx
 8048795:	29 c1                	sub    %eax,%ecx
 8048797:	89 c8                	mov    %ecx,%eax
}
 8048799:	c9                   	leave  
 804879a:	c3                   	ret    

0804879b <strchr>:

char *strchr(const char *s, int c)
{
 804879b:	55                   	push   %ebp
 804879c:	89 e5                	mov    %esp,%ebp
        for (; *s != (char) c; ++s)
 804879e:	eb 15                	jmp    80487b5 <strchr+0x1a>
                if (*s == '\0')
 80487a0:	8b 45 08             	mov    0x8(%ebp),%eax
 80487a3:	0f b6 00             	movzbl (%eax),%eax
 80487a6:	84 c0                	test   %al,%al
 80487a8:	75 07                	jne    80487b1 <strchr+0x16>
                        return NULL;
 80487aa:	b8 00 00 00 00       	mov    $0x0,%eax
 80487af:	eb 14                	jmp    80487c5 <strchr+0x2a>
        return sc - s;
}

char *strchr(const char *s, int c)
{
        for (; *s != (char) c; ++s)
 80487b1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 80487b5:	8b 45 08             	mov    0x8(%ebp),%eax
 80487b8:	0f b6 10             	movzbl (%eax),%edx
 80487bb:	8b 45 0c             	mov    0xc(%ebp),%eax
 80487be:	38 c2                	cmp    %al,%dl
 80487c0:	75 de                	jne    80487a0 <strchr+0x5>
                if (*s == '\0')
                        return NULL;
        return (char *)s;
 80487c2:	8b 45 08             	mov    0x8(%ebp),%eax
}
 80487c5:	5d                   	pop    %ebp
 80487c6:	c3                   	ret    

080487c7 <strrchr>:

char *strrchr(const char *s, int c)
{
 80487c7:	55                   	push   %ebp
 80487c8:	89 e5                	mov    %esp,%ebp
 80487ca:	83 ec 10             	sub    $0x10,%esp
        char *r = NULL;
 80487cd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
        for (; *s; ++s)
 80487d4:	eb 17                	jmp    80487ed <strrchr+0x26>
                if (*s == (char)c)
 80487d6:	8b 45 08             	mov    0x8(%ebp),%eax
 80487d9:	0f b6 10             	movzbl (%eax),%edx
 80487dc:	8b 45 0c             	mov    0xc(%ebp),%eax
 80487df:	38 c2                	cmp    %al,%dl
 80487e1:	75 06                	jne    80487e9 <strrchr+0x22>
                        r = (char *)s;
 80487e3:	8b 45 08             	mov    0x8(%ebp),%eax
 80487e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

char *strrchr(const char *s, int c)
{
        char *r = NULL;
        for (; *s; ++s)
 80487e9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 80487ed:	8b 45 08             	mov    0x8(%ebp),%eax
 80487f0:	0f b6 00             	movzbl (%eax),%eax
 80487f3:	84 c0                	test   %al,%al
 80487f5:	75 df                	jne    80487d6 <strrchr+0xf>
                if (*s == (char)c)
                        r = (char *)s;
        return r;
 80487f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 80487fa:	c9                   	leave  
 80487fb:	c3                   	ret    

080487fc <strstr>:

char *strstr(const char *s1, const char *s2)
{
 80487fc:	55                   	push   %ebp
 80487fd:	89 e5                	mov    %esp,%ebp
 80487ff:	53                   	push   %ebx
 8048800:	83 ec 24             	sub    $0x24,%esp
 8048803:	e8 19 fd ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 8048808:	81 c3 78 79 00 00    	add    $0x7978,%ebx
        int l1, l2;

        l2 = strlen(s2);
 804880e:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048811:	89 04 24             	mov    %eax,(%esp)
 8048814:	e8 58 ff ff ff       	call   8048771 <strlen>
 8048819:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (!l2)
 804881c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 8048820:	75 05                	jne    8048827 <strstr+0x2b>
                return (char *) s1;
 8048822:	8b 45 08             	mov    0x8(%ebp),%eax
 8048825:	eb 47                	jmp    804886e <strstr+0x72>
        l1 = strlen(s1);
 8048827:	8b 45 08             	mov    0x8(%ebp),%eax
 804882a:	89 04 24             	mov    %eax,(%esp)
 804882d:	e8 3f ff ff ff       	call   8048771 <strlen>
 8048832:	89 45 f4             	mov    %eax,-0xc(%ebp)
        while (l1 >= l2) {
 8048835:	eb 2a                	jmp    8048861 <strstr+0x65>
                l1--;
 8048837:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
                if (!memcmp(s1, s2, l2))
 804883b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804883e:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048842:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048845:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048849:	8b 45 08             	mov    0x8(%ebp),%eax
 804884c:	89 04 24             	mov    %eax,(%esp)
 804884f:	e8 d4 fc ff ff       	call   8048528 <memcmp>
 8048854:	85 c0                	test   %eax,%eax
 8048856:	75 05                	jne    804885d <strstr+0x61>
                        return (char *) s1;
 8048858:	8b 45 08             	mov    0x8(%ebp),%eax
 804885b:	eb 11                	jmp    804886e <strstr+0x72>
                s1++;
 804885d:	83 45 08 01          	addl   $0x1,0x8(%ebp)

        l2 = strlen(s2);
        if (!l2)
                return (char *) s1;
        l1 = strlen(s1);
        while (l1 >= l2) {
 8048861:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048864:	3b 45 f0             	cmp    -0x10(%ebp),%eax
 8048867:	7d ce                	jge    8048837 <strstr+0x3b>
                l1--;
                if (!memcmp(s1, s2, l2))
                        return (char *) s1;
                s1++;
        }
        return NULL;
 8048869:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804886e:	83 c4 24             	add    $0x24,%esp
 8048871:	5b                   	pop    %ebx
 8048872:	5d                   	pop    %ebp
 8048873:	c3                   	ret    

08048874 <strdup>:

char *strdup(const char *s)
{
 8048874:	55                   	push   %ebp
 8048875:	89 e5                	mov    %esp,%ebp
        /* TODO - alvin */
        return NULL;
 8048877:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804887c:	5d                   	pop    %ebp
 804887d:	c3                   	ret    

0804887e <strpbrk>:
 * Got this from /onnv-gate/usr/src/common/uti/string.c.
 */

char *
strpbrk(const char *string, const char *brkset)
{
 804887e:	55                   	push   %ebp
 804887f:	89 e5                	mov    %esp,%ebp
 8048881:	83 ec 10             	sub    $0x10,%esp
        const char *p;

        do {
                for (p = brkset; *p != '\0' && *p != *string; ++p)
 8048884:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048887:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804888a:	eb 04                	jmp    8048890 <strpbrk+0x12>
 804888c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 8048890:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048893:	0f b6 00             	movzbl (%eax),%eax
 8048896:	84 c0                	test   %al,%al
 8048898:	74 10                	je     80488aa <strpbrk+0x2c>
 804889a:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804889d:	0f b6 10             	movzbl (%eax),%edx
 80488a0:	8b 45 08             	mov    0x8(%ebp),%eax
 80488a3:	0f b6 00             	movzbl (%eax),%eax
 80488a6:	38 c2                	cmp    %al,%dl
 80488a8:	75 e2                	jne    804888c <strpbrk+0xe>
                        ;
                if (*p != '\0')
 80488aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80488ad:	0f b6 00             	movzbl (%eax),%eax
 80488b0:	84 c0                	test   %al,%al
 80488b2:	74 05                	je     80488b9 <strpbrk+0x3b>
                        return ((char *)string);
 80488b4:	8b 45 08             	mov    0x8(%ebp),%eax
 80488b7:	eb 18                	jmp    80488d1 <strpbrk+0x53>
        } while (*string++);
 80488b9:	8b 45 08             	mov    0x8(%ebp),%eax
 80488bc:	0f b6 00             	movzbl (%eax),%eax
 80488bf:	84 c0                	test   %al,%al
 80488c1:	0f 95 c0             	setne  %al
 80488c4:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 80488c8:	84 c0                	test   %al,%al
 80488ca:	75 b8                	jne    8048884 <strpbrk+0x6>

        return (NULL);
 80488cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
 80488d1:	c9                   	leave  
 80488d2:	c3                   	ret    

080488d3 <strspn>:

size_t
strspn(const char *string, const char *charset)
{
 80488d3:	55                   	push   %ebp
 80488d4:	89 e5                	mov    %esp,%ebp
 80488d6:	83 ec 10             	sub    $0x10,%esp
        const char *p, *q;

        for (q = string; *q != '\0'; ++q) {
 80488d9:	8b 45 08             	mov    0x8(%ebp),%eax
 80488dc:	89 45 f8             	mov    %eax,-0x8(%ebp)
 80488df:	eb 34                	jmp    8048915 <strspn+0x42>
                for (p = charset; *p != '\0' && *p != *q; ++p)
 80488e1:	8b 45 0c             	mov    0xc(%ebp),%eax
 80488e4:	89 45 fc             	mov    %eax,-0x4(%ebp)
 80488e7:	eb 04                	jmp    80488ed <strspn+0x1a>
 80488e9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 80488ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80488f0:	0f b6 00             	movzbl (%eax),%eax
 80488f3:	84 c0                	test   %al,%al
 80488f5:	74 10                	je     8048907 <strspn+0x34>
 80488f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80488fa:	0f b6 10             	movzbl (%eax),%edx
 80488fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048900:	0f b6 00             	movzbl (%eax),%eax
 8048903:	38 c2                	cmp    %al,%dl
 8048905:	75 e2                	jne    80488e9 <strspn+0x16>
                        ;
                if (*p == '\0')
 8048907:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804890a:	0f b6 00             	movzbl (%eax),%eax
 804890d:	84 c0                	test   %al,%al
 804890f:	74 10                	je     8048921 <strspn+0x4e>
size_t
strspn(const char *string, const char *charset)
{
        const char *p, *q;

        for (q = string; *q != '\0'; ++q) {
 8048911:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
 8048915:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048918:	0f b6 00             	movzbl (%eax),%eax
 804891b:	84 c0                	test   %al,%al
 804891d:	75 c2                	jne    80488e1 <strspn+0xe>
 804891f:	eb 01                	jmp    8048922 <strspn+0x4f>
                for (p = charset; *p != '\0' && *p != *q; ++p)
                        ;
                if (*p == '\0')
                        break;
 8048921:	90                   	nop
        }

        return (q - string);
 8048922:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048925:	8b 45 08             	mov    0x8(%ebp),%eax
 8048928:	89 d1                	mov    %edx,%ecx
 804892a:	29 c1                	sub    %eax,%ecx
 804892c:	89 c8                	mov    %ecx,%eax
}
 804892e:	c9                   	leave  
 804892f:	c3                   	ret    

08048930 <strtok>:

char *
strtok(char *string, const char *sepset)
{
 8048930:	55                   	push   %ebp
 8048931:	89 e5                	mov    %esp,%ebp
 8048933:	53                   	push   %ebx
 8048934:	83 ec 24             	sub    $0x24,%esp
 8048937:	e8 e5 fb ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804893c:	81 c3 44 78 00 00    	add    $0x7844,%ebx
        static char     *savept;

        /*
         * Set `p' to our current location in the string.
         */
        p = (string == NULL) ? savept : string;
 8048942:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8048946:	75 08                	jne    8048950 <strtok+0x20>
 8048948:	8b 83 84 01 00 00    	mov    0x184(%ebx),%eax
 804894e:	eb 03                	jmp    8048953 <strtok+0x23>
 8048950:	8b 45 08             	mov    0x8(%ebp),%eax
 8048953:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (p == NULL)
 8048956:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804895a:	75 07                	jne    8048963 <strtok+0x33>
                return (NULL);
 804895c:	b8 00 00 00 00       	mov    $0x0,%eax
 8048961:	eb 66                	jmp    80489c9 <strtok+0x99>

        /*
         * Skip leading separators; bail if no tokens remain.
         */
        q = p + strspn(p, sepset);
 8048963:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048966:	89 44 24 04          	mov    %eax,0x4(%esp)
 804896a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804896d:	89 04 24             	mov    %eax,(%esp)
 8048970:	e8 5e ff ff ff       	call   80488d3 <strspn>
 8048975:	03 45 f4             	add    -0xc(%ebp),%eax
 8048978:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (*q == '\0')
 804897b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804897e:	0f b6 00             	movzbl (%eax),%eax
 8048981:	84 c0                	test   %al,%al
 8048983:	75 07                	jne    804898c <strtok+0x5c>
                return (NULL);
 8048985:	b8 00 00 00 00       	mov    $0x0,%eax
 804898a:	eb 3d                	jmp    80489c9 <strtok+0x99>

        /*
         * Mark the end of the token and set `savept' for the next iteration.
         */
        if ((r = strpbrk(q, sepset)) == NULL)
 804898c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804898f:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048993:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048996:	89 04 24             	mov    %eax,(%esp)
 8048999:	e8 e0 fe ff ff       	call   804887e <strpbrk>
 804899e:	89 45 ec             	mov    %eax,-0x14(%ebp)
 80489a1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 80489a5:	75 0c                	jne    80489b3 <strtok+0x83>
                savept = NULL;
 80489a7:	c7 83 84 01 00 00 00 	movl   $0x0,0x184(%ebx)
 80489ae:	00 00 00 
 80489b1:	eb 13                	jmp    80489c6 <strtok+0x96>
        else {
                *r = '\0';
 80489b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80489b6:	c6 00 00             	movb   $0x0,(%eax)
                savept = ++r;
 80489b9:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
 80489bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80489c0:	89 83 84 01 00 00    	mov    %eax,0x184(%ebx)
        }

        return (q);
 80489c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 80489c9:	83 c4 24             	add    $0x24,%esp
 80489cc:	5b                   	pop    %ebx
 80489cd:	5d                   	pop    %ebp
 80489ce:	c3                   	ret    

080489cf <strerror>:

/* created with the help of:
 * perl -p -e 's/#define\s+(\w+)\s+\d+\s+\/\* ([^\t\*]+)\s*\*\/\s*$/case $1: return "$2";\n/' < /usr/include/sys/errno.h
 */
char *strerror(int errnum)
{
 80489cf:	55                   	push   %ebp
 80489d0:	89 e5                	mov    %esp,%ebp
 80489d2:	e8 17 07 00 00       	call   80490ee <__i686.get_pc_thunk.cx>
 80489d7:	81 c1 a9 77 00 00    	add    $0x77a9,%ecx
        switch (errnum) {
 80489dd:	81 7d 08 83 00 00 00 	cmpl   $0x83,0x8(%ebp)
 80489e4:	0f 87 fd 06 00 00    	ja     80490e7 <strerror+0x718>
 80489ea:	8b 45 08             	mov    0x8(%ebp),%eax
 80489ed:	c1 e0 02             	shl    $0x2,%eax
 80489f0:	8b 84 08 80 88 ff ff 	mov    -0x7780(%eax,%ecx,1),%eax
 80489f7:	89 ca                	mov    %ecx,%edx
 80489f9:	29 c2                	sub    %eax,%edx
 80489fb:	89 d0                	mov    %edx,%eax
 80489fd:	ff e0                	jmp    *%eax
 80489ff:	90                   	nop
 8048a00:	99                   	cltd   
 8048a01:	70 00                	jo     8048a03 <strerror+0x34>
 8048a03:	00 70 75             	add    %dh,0x75(%eax)
 8048a06:	00 00                	add    %al,(%eax)
 8048a08:	65                   	gs
 8048a09:	75 00                	jne    8048a0b <strerror+0x3c>
 8048a0b:	00 5a 75             	add    %bl,0x75(%edx)
 8048a0e:	00 00                	add    %al,(%eax)
 8048a10:	4f                   	dec    %edi
 8048a11:	75 00                	jne    8048a13 <strerror+0x44>
 8048a13:	00 44 75 00          	add    %al,0x0(%ebp,%esi,2)
 8048a17:	00 39                	add    %bh,(%ecx)
 8048a19:	75 00                	jne    8048a1b <strerror+0x4c>
 8048a1b:	00 2e                	add    %ch,(%esi)
 8048a1d:	75 00                	jne    8048a1f <strerror+0x50>
 8048a1f:	00 23                	add    %ah,(%ebx)
 8048a21:	75 00                	jne    8048a23 <strerror+0x54>
 8048a23:	00 18                	add    %bl,(%eax)
 8048a25:	75 00                	jne    8048a27 <strerror+0x58>
 8048a27:	00 0d 75 00 00 02    	add    %cl,0x2000075
 8048a2d:	75 00                	jne    8048a2f <strerror+0x60>
 8048a2f:	00 f7                	add    %dh,%bh
 8048a31:	74 00                	je     8048a33 <strerror+0x64>
 8048a33:	00 ec                	add    %ch,%ah
 8048a35:	74 00                	je     8048a37 <strerror+0x68>
 8048a37:	00 e1                	add    %ah,%cl
 8048a39:	74 00                	je     8048a3b <strerror+0x6c>
 8048a3b:	00 d6                	add    %dl,%dh
 8048a3d:	74 00                	je     8048a3f <strerror+0x70>
 8048a3f:	00 cb                	add    %cl,%bl
 8048a41:	74 00                	je     8048a43 <strerror+0x74>
 8048a43:	00 c0                	add    %al,%al
 8048a45:	74 00                	je     8048a47 <strerror+0x78>
 8048a47:	00 b5 74 00 00 aa    	add    %dh,-0x55ffff8c(%ebp)
 8048a4d:	74 00                	je     8048a4f <strerror+0x80>
 8048a4f:	00 9f 74 00 00 94    	add    %bl,-0x6bffff8c(%edi)
 8048a55:	74 00                	je     8048a57 <strerror+0x88>
 8048a57:	00 89 74 00 00 7e    	add    %cl,0x7e000074(%ecx)
 8048a5d:	74 00                	je     8048a5f <strerror+0x90>
 8048a5f:	00 73 74             	add    %dh,0x74(%ebx)
 8048a62:	00 00                	add    %al,(%eax)
 8048a64:	68 74 00 00 5d       	push   $0x5d000074
 8048a69:	74 00                	je     8048a6b <strerror+0x9c>
 8048a6b:	00 52 74             	add    %dl,0x74(%edx)
 8048a6e:	00 00                	add    %al,(%eax)
 8048a70:	47                   	inc    %edi
 8048a71:	74 00                	je     8048a73 <strerror+0xa4>
 8048a73:	00 3c 74             	add    %bh,(%esp,%esi,2)
 8048a76:	00 00                	add    %al,(%eax)
 8048a78:	31 74 00 00          	xor    %esi,0x0(%eax,%eax,1)
 8048a7c:	26                   	es
 8048a7d:	74 00                	je     8048a7f <strerror+0xb0>
 8048a7f:	00 1b                	add    %bl,(%ebx)
 8048a81:	74 00                	je     8048a83 <strerror+0xb4>
 8048a83:	00 10                	add    %dl,(%eax)
 8048a85:	74 00                	je     8048a87 <strerror+0xb8>
 8048a87:	00 05 74 00 00 8c    	add    %al,0x8c000074
 8048a8d:	73 00                	jae    8048a8f <strerror+0xc0>
 8048a8f:	00 58 72             	add    %bl,0x72(%eax)
 8048a92:	00 00                	add    %al,(%eax)
 8048a94:	81 73 00 00 df 71 00 	xorl   $0x71df00,0x0(%ebx)
 8048a9b:	00 b3 71 00 00 d4    	add    %dh,-0x2bffff8f(%ebx)
 8048aa1:	71 00                	jno    8048aa3 <strerror+0xd4>
 8048aa3:	00 99 70 00 00 fa    	add    %bl,-0x5ffff90(%ecx)
 8048aa9:	73 00                	jae    8048aab <strerror+0xdc>
 8048aab:	00 ef                	add    %ch,%bh
 8048aad:	73 00                	jae    8048aaf <strerror+0xe0>
 8048aaf:	00 e4                	add    %ah,%ah
 8048ab1:	73 00                	jae    8048ab3 <strerror+0xe4>
 8048ab3:	00 d9                	add    %bl,%cl
 8048ab5:	73 00                	jae    8048ab7 <strerror+0xe8>
 8048ab7:	00 ce                	add    %cl,%dh
 8048ab9:	73 00                	jae    8048abb <strerror+0xec>
 8048abb:	00 c3                	add    %al,%bl
 8048abd:	73 00                	jae    8048abf <strerror+0xf0>
 8048abf:	00 b8 73 00 00 ad    	add    %bh,-0x52ffff8d(%eax)
 8048ac5:	73 00                	jae    8048ac7 <strerror+0xf8>
 8048ac7:	00 a2 73 00 00 97    	add    %ah,-0x68ffff8d(%edx)
 8048acd:	73 00                	jae    8048acf <strerror+0x100>
 8048acf:	00 55 73             	add    %dl,0x73(%ebp)
 8048ad2:	00 00                	add    %al,(%eax)
 8048ad4:	4a                   	dec    %edx
 8048ad5:	73 00                	jae    8048ad7 <strerror+0x108>
 8048ad7:	00 3f                	add    %bh,(%edi)
 8048ad9:	73 00                	jae    8048adb <strerror+0x10c>
 8048adb:	00 34 73             	add    %dh,(%ebx,%esi,2)
 8048ade:	00 00                	add    %al,(%eax)
 8048ae0:	29 73 00             	sub    %esi,0x0(%ebx)
 8048ae3:	00 1e                	add    %bl,(%esi)
 8048ae5:	73 00                	jae    8048ae7 <strerror+0x118>
 8048ae7:	00 99 70 00 00 13    	add    %bl,0x13000070(%ecx)
 8048aed:	73 00                	jae    8048aef <strerror+0x120>
 8048aef:	00 f2                	add    %dh,%dl
 8048af1:	72 00                	jb     8048af3 <strerror+0x124>
 8048af3:	00 e7                	add    %ah,%bh
 8048af5:	72 00                	jb     8048af7 <strerror+0x128>
 8048af7:	00 dc                	add    %bl,%ah
 8048af9:	72 00                	jb     8048afb <strerror+0x12c>
 8048afb:	00 d1                	add    %dl,%cl
 8048afd:	72 00                	jb     8048aff <strerror+0x130>
 8048aff:	00 c6                	add    %al,%dh
 8048b01:	72 00                	jb     8048b03 <strerror+0x134>
 8048b03:	00 bb 72 00 00 b0    	add    %bh,-0x4fffff8e(%ebx)
 8048b09:	72 00                	jb     8048b0b <strerror+0x13c>
 8048b0b:	00 a5 72 00 00 9a    	add    %ah,-0x65ffff8e(%ebp)
 8048b11:	72 00                	jb     8048b13 <strerror+0x144>
 8048b13:	00 8f 72 00 00 84    	add    %cl,-0x7bffff8e(%edi)
 8048b19:	72 00                	jb     8048b1b <strerror+0x14c>
 8048b1b:	00 79 72             	add    %bh,0x72(%ecx)
 8048b1e:	00 00                	add    %al,(%eax)
 8048b20:	6e                   	outsb  %ds:(%esi),(%dx)
 8048b21:	72 00                	jb     8048b23 <strerror+0x154>
 8048b23:	00 99 70 00 00 63    	add    %bl,0x63000070(%ecx)
 8048b29:	72 00                	jb     8048b2b <strerror+0x15c>
 8048b2b:	00 4d 72             	add    %cl,0x72(%ebp)
 8048b2e:	00 00                	add    %al,(%eax)
 8048b30:	42                   	inc    %edx
 8048b31:	72 00                	jb     8048b33 <strerror+0x164>
 8048b33:	00 37                	add    %dh,(%edi)
 8048b35:	72 00                	jb     8048b37 <strerror+0x168>
 8048b37:	00 2c 72             	add    %ch,(%edx,%esi,2)
 8048b3a:	00 00                	add    %al,(%eax)
 8048b3c:	21 72 00             	and    %esi,0x0(%edx)
 8048b3f:	00 16                	add    %dl,(%esi)
 8048b41:	72 00                	jb     8048b43 <strerror+0x174>
 8048b43:	00 0b                	add    %cl,(%ebx)
 8048b45:	72 00                	jb     8048b47 <strerror+0x178>
 8048b47:	00 00                	add    %al,(%eax)
 8048b49:	72 00                	jb     8048b4b <strerror+0x17c>
 8048b4b:	00 f5                	add    %dh,%ch
 8048b4d:	71 00                	jno    8048b4f <strerror+0x180>
 8048b4f:	00 ea                	add    %ch,%dl
 8048b51:	71 00                	jno    8048b53 <strerror+0x184>
 8048b53:	00 c9                	add    %cl,%cl
 8048b55:	71 00                	jno    8048b57 <strerror+0x188>
 8048b57:	00 be 71 00 00 a8    	add    %bh,-0x57ffff8f(%esi)
 8048b5d:	71 00                	jno    8048b5f <strerror+0x190>
 8048b5f:	00 9d 71 00 00 92    	add    %bl,-0x6dffff8f(%ebp)
 8048b65:	71 00                	jno    8048b67 <strerror+0x198>
 8048b67:	00 87 71 00 00 7c    	add    %al,0x7c000071(%edi)
 8048b6d:	71 00                	jno    8048b6f <strerror+0x1a0>
 8048b6f:	00 71 71             	add    %dh,0x71(%ecx)
 8048b72:	00 00                	add    %al,(%eax)
 8048b74:	66                   	data16
 8048b75:	71 00                	jno    8048b77 <strerror+0x1a8>
 8048b77:	00 5b 71             	add    %bl,0x71(%ebx)
 8048b7a:	00 00                	add    %al,(%eax)
 8048b7c:	6b 73 00 00          	imul   $0x0,0x0(%ebx),%esi
 8048b80:	50                   	push   %eax
 8048b81:	71 00                	jno    8048b83 <strerror+0x1b4>
 8048b83:	00 45 71             	add    %al,0x71(%ebp)
 8048b86:	00 00                	add    %al,(%eax)
 8048b88:	3a 71 00             	cmp    0x0(%ecx),%dh
 8048b8b:	00 2f                	add    %ch,(%edi)
 8048b8d:	71 00                	jno    8048b8f <strerror+0x1c0>
 8048b8f:	00 24 71             	add    %ah,(%ecx,%esi,2)
 8048b92:	00 00                	add    %al,(%eax)
 8048b94:	19 71 00             	sbb    %esi,0x0(%ecx)
 8048b97:	00 11                	add    %dl,(%ecx)
 8048b99:	71 00                	jno    8048b9b <strerror+0x1cc>
 8048b9b:	00 09                	add    %cl,(%ecx)
 8048b9d:	71 00                	jno    8048b9f <strerror+0x1d0>
 8048b9f:	00 01                	add    %al,(%ecx)
 8048ba1:	71 00                	jno    8048ba3 <strerror+0x1d4>
 8048ba3:	00 f9                	add    %bh,%cl
 8048ba5:	70 00                	jo     8048ba7 <strerror+0x1d8>
 8048ba7:	00 f1                	add    %dh,%cl
 8048ba9:	70 00                	jo     8048bab <strerror+0x1dc>
 8048bab:	00 e9                	add    %ch,%cl
 8048bad:	70 00                	jo     8048baf <strerror+0x1e0>
 8048baf:	00 e1                	add    %ah,%cl
 8048bb1:	70 00                	jo     8048bb3 <strerror+0x1e4>
 8048bb3:	00 d9                	add    %bl,%cl
 8048bb5:	70 00                	jo     8048bb7 <strerror+0x1e8>
 8048bb7:	00 d1                	add    %dl,%cl
 8048bb9:	70 00                	jo     8048bbb <strerror+0x1ec>
 8048bbb:	00 c9                	add    %cl,%cl
 8048bbd:	70 00                	jo     8048bbf <strerror+0x1f0>
 8048bbf:	00 c1                	add    %al,%cl
 8048bc1:	70 00                	jo     8048bc3 <strerror+0x1f4>
 8048bc3:	00 b9 70 00 00 b1    	add    %bh,-0x4effff90(%ecx)
 8048bc9:	70 00                	jo     8048bcb <strerror+0x1fc>
 8048bcb:	00 a9 70 00 00 a1    	add    %ch,-0x5effff90(%ecx)
 8048bd1:	70 00                	jo     8048bd3 <strerror+0x204>
 8048bd3:	00 99 70 00 00 99    	add    %bl,-0x66ffff90(%ecx)
 8048bd9:	70 00                	jo     8048bdb <strerror+0x20c>
 8048bdb:	00 99 70 00 00 99    	add    %bl,-0x66ffff90(%ecx)
 8048be1:	70 00                	jo     8048be3 <strerror+0x214>
 8048be3:	00 99 70 00 00 60    	add    %bl,0x60000070(%ecx)
 8048be9:	73 00                	jae    8048beb <strerror+0x21c>
 8048beb:	00 99 70 00 00 99    	add    %bl,-0x66ffff90(%ecx)
 8048bf1:	70 00                	jo     8048bf3 <strerror+0x224>
 8048bf3:	00 76 73             	add    %dh,0x73(%esi)
 8048bf6:	00 00                	add    %al,(%eax)
 8048bf8:	99                   	cltd   
 8048bf9:	70 00                	jo     8048bfb <strerror+0x22c>
 8048bfb:	00 99 70 00 00 99    	add    %bl,-0x66ffff90(%ecx)
 8048c01:	70 00                	jo     8048c03 <strerror+0x234>
 8048c03:	00 99 70 00 00 08    	add    %bl,0x8000070(%ecx)
 8048c09:	73 00                	jae    8048c0b <strerror+0x23c>
 8048c0b:	00 fd                	add    %bh,%ch
 8048c0d:	72 00                	jb     8048c0f <strerror+0x240>
 8048c0f:	00 8d 81 b8 d5 ff    	add    %cl,-0x2a477f(%ebp)
                case EPERM: return "Not super-user";
 8048c15:	ff e9                	ljmp   *<internal disassembler error>
 8048c17:	d1 04 00             	roll   (%eax,%eax,1)
 8048c1a:	00 8d 81 c7 d5 ff    	add    %cl,-0x2a387f(%ebp)
                case ENOENT: return "No such file or directory";
 8048c20:	ff e9                	ljmp   *<internal disassembler error>
 8048c22:	c6 04 00 00          	movb   $0x0,(%eax,%eax,1)
                case ESRCH: return "No such process";
 8048c26:	8d 81 e1 d5 ff ff    	lea    -0x2a1f(%ecx),%eax
 8048c2c:	e9 bb 04 00 00       	jmp    80490ec <strerror+0x71d>
                case EINTR: return "interrupted system call";
 8048c31:	8d 81 f1 d5 ff ff    	lea    -0x2a0f(%ecx),%eax
 8048c37:	e9 b0 04 00 00       	jmp    80490ec <strerror+0x71d>
                case EIO: return "I/O error";
 8048c3c:	8d 81 09 d6 ff ff    	lea    -0x29f7(%ecx),%eax
 8048c42:	e9 a5 04 00 00       	jmp    80490ec <strerror+0x71d>
                case ENXIO: return "No such device or address";
 8048c47:	8d 81 13 d6 ff ff    	lea    -0x29ed(%ecx),%eax
 8048c4d:	e9 9a 04 00 00       	jmp    80490ec <strerror+0x71d>
                case E2BIG: return "Arg list too long";
 8048c52:	8d 81 2d d6 ff ff    	lea    -0x29d3(%ecx),%eax
 8048c58:	e9 8f 04 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOEXEC: return "Exec format error";
 8048c5d:	8d 81 3f d6 ff ff    	lea    -0x29c1(%ecx),%eax
 8048c63:	e9 84 04 00 00       	jmp    80490ec <strerror+0x71d>
                case EBADF: return "Bad file number";
 8048c68:	8d 81 51 d6 ff ff    	lea    -0x29af(%ecx),%eax
 8048c6e:	e9 79 04 00 00       	jmp    80490ec <strerror+0x71d>
                case ECHILD: return "No children";
 8048c73:	8d 81 61 d6 ff ff    	lea    -0x299f(%ecx),%eax
 8048c79:	e9 6e 04 00 00       	jmp    80490ec <strerror+0x71d>
                case EAGAIN: return "Resource temporarily unavailable";
 8048c7e:	8d 81 70 d6 ff ff    	lea    -0x2990(%ecx),%eax
 8048c84:	e9 63 04 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOMEM: return "Not enough core";
 8048c89:	8d 81 91 d6 ff ff    	lea    -0x296f(%ecx),%eax
 8048c8f:	e9 58 04 00 00       	jmp    80490ec <strerror+0x71d>
                case EACCES: return "Permission denied";
 8048c94:	8d 81 a1 d6 ff ff    	lea    -0x295f(%ecx),%eax
 8048c9a:	e9 4d 04 00 00       	jmp    80490ec <strerror+0x71d>
                case EFAULT: return "Bad address";
 8048c9f:	8d 81 b3 d6 ff ff    	lea    -0x294d(%ecx),%eax
 8048ca5:	e9 42 04 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOTBLK: return "Block device required";
 8048caa:	8d 81 bf d6 ff ff    	lea    -0x2941(%ecx),%eax
 8048cb0:	e9 37 04 00 00       	jmp    80490ec <strerror+0x71d>
                case EBUSY: return "Mount device busy";
 8048cb5:	8d 81 d5 d6 ff ff    	lea    -0x292b(%ecx),%eax
 8048cbb:	e9 2c 04 00 00       	jmp    80490ec <strerror+0x71d>
                case EEXIST: return "File exists";
 8048cc0:	8d 81 e7 d6 ff ff    	lea    -0x2919(%ecx),%eax
 8048cc6:	e9 21 04 00 00       	jmp    80490ec <strerror+0x71d>
                case EXDEV: return "Cross-device link";
 8048ccb:	8d 81 f3 d6 ff ff    	lea    -0x290d(%ecx),%eax
 8048cd1:	e9 16 04 00 00       	jmp    80490ec <strerror+0x71d>
                case ENODEV: return "No such device";
 8048cd6:	8d 81 05 d7 ff ff    	lea    -0x28fb(%ecx),%eax
 8048cdc:	e9 0b 04 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOTDIR: return "Not a directory";
 8048ce1:	8d 81 14 d7 ff ff    	lea    -0x28ec(%ecx),%eax
 8048ce7:	e9 00 04 00 00       	jmp    80490ec <strerror+0x71d>
                case EISDIR: return "Is a directory";
 8048cec:	8d 81 24 d7 ff ff    	lea    -0x28dc(%ecx),%eax
 8048cf2:	e9 f5 03 00 00       	jmp    80490ec <strerror+0x71d>
                case EINVAL: return "Invalid argument";
 8048cf7:	8d 81 33 d7 ff ff    	lea    -0x28cd(%ecx),%eax
 8048cfd:	e9 ea 03 00 00       	jmp    80490ec <strerror+0x71d>
                case ENFILE: return "File table overflow";
 8048d02:	8d 81 44 d7 ff ff    	lea    -0x28bc(%ecx),%eax
 8048d08:	e9 df 03 00 00       	jmp    80490ec <strerror+0x71d>
                case EMFILE: return "Too many open files";
 8048d0d:	8d 81 58 d7 ff ff    	lea    -0x28a8(%ecx),%eax
 8048d13:	e9 d4 03 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOTTY: return "Inappropriate ioctl for device";
 8048d18:	8d 81 6c d7 ff ff    	lea    -0x2894(%ecx),%eax
 8048d1e:	e9 c9 03 00 00       	jmp    80490ec <strerror+0x71d>
                case ETXTBSY: return "Text file busy";
 8048d23:	8d 81 8b d7 ff ff    	lea    -0x2875(%ecx),%eax
 8048d29:	e9 be 03 00 00       	jmp    80490ec <strerror+0x71d>
                case EFBIG: return "File too large";
 8048d2e:	8d 81 9a d7 ff ff    	lea    -0x2866(%ecx),%eax
 8048d34:	e9 b3 03 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOSPC: return "No space left on device";
 8048d39:	8d 81 a9 d7 ff ff    	lea    -0x2857(%ecx),%eax
 8048d3f:	e9 a8 03 00 00       	jmp    80490ec <strerror+0x71d>
                case ESPIPE: return "Illegal seek";
 8048d44:	8d 81 c1 d7 ff ff    	lea    -0x283f(%ecx),%eax
 8048d4a:	e9 9d 03 00 00       	jmp    80490ec <strerror+0x71d>
                case EROFS: return "Read only file system";
 8048d4f:	8d 81 ce d7 ff ff    	lea    -0x2832(%ecx),%eax
 8048d55:	e9 92 03 00 00       	jmp    80490ec <strerror+0x71d>
                case EMLINK: return "Too many links";
 8048d5a:	8d 81 e4 d7 ff ff    	lea    -0x281c(%ecx),%eax
 8048d60:	e9 87 03 00 00       	jmp    80490ec <strerror+0x71d>
                case EPIPE: return "Broken pipe";
 8048d65:	8d 81 f3 d7 ff ff    	lea    -0x280d(%ecx),%eax
 8048d6b:	e9 7c 03 00 00       	jmp    80490ec <strerror+0x71d>
                case EDOM: return "Math arg out of domain of func";
 8048d70:	8d 81 00 d8 ff ff    	lea    -0x2800(%ecx),%eax
 8048d76:	e9 71 03 00 00       	jmp    80490ec <strerror+0x71d>
                case ERANGE: return "Math result not representable";
 8048d7b:	8d 81 1f d8 ff ff    	lea    -0x27e1(%ecx),%eax
 8048d81:	e9 66 03 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOMSG: return "No message of desired type";
 8048d86:	8d 81 3d d8 ff ff    	lea    -0x27c3(%ecx),%eax
 8048d8c:	e9 5b 03 00 00       	jmp    80490ec <strerror+0x71d>
                case EIDRM: return "Identifier removed";
 8048d91:	8d 81 58 d8 ff ff    	lea    -0x27a8(%ecx),%eax
 8048d97:	e9 50 03 00 00       	jmp    80490ec <strerror+0x71d>
                case ECHRNG: return "Channel number out of range";
 8048d9c:	8d 81 6b d8 ff ff    	lea    -0x2795(%ecx),%eax
 8048da2:	e9 45 03 00 00       	jmp    80490ec <strerror+0x71d>
                case EL2NSYNC: return "Level 2 not synchronized";
 8048da7:	8d 81 87 d8 ff ff    	lea    -0x2779(%ecx),%eax
 8048dad:	e9 3a 03 00 00       	jmp    80490ec <strerror+0x71d>
                case EL3HLT: return "Level 3 halted";
 8048db2:	8d 81 a0 d8 ff ff    	lea    -0x2760(%ecx),%eax
 8048db8:	e9 2f 03 00 00       	jmp    80490ec <strerror+0x71d>
                case EL3RST: return "Level 3 reset";
 8048dbd:	8d 81 af d8 ff ff    	lea    -0x2751(%ecx),%eax
 8048dc3:	e9 24 03 00 00       	jmp    80490ec <strerror+0x71d>
                case ELNRNG: return "Link number out of range";
 8048dc8:	8d 81 bd d8 ff ff    	lea    -0x2743(%ecx),%eax
 8048dce:	e9 19 03 00 00       	jmp    80490ec <strerror+0x71d>
                case EUNATCH: return "Protocol driver not attached";
 8048dd3:	8d 81 d6 d8 ff ff    	lea    -0x272a(%ecx),%eax
 8048dd9:	e9 0e 03 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOCSI: return "No CSI structure available";
 8048dde:	8d 81 f3 d8 ff ff    	lea    -0x270d(%ecx),%eax
 8048de4:	e9 03 03 00 00       	jmp    80490ec <strerror+0x71d>
                case EL2HLT: return "Level 2 halted";
 8048de9:	8d 81 0e d9 ff ff    	lea    -0x26f2(%ecx),%eax
 8048def:	e9 f8 02 00 00       	jmp    80490ec <strerror+0x71d>
                case EDEADLK: return "Deadlock condition.";
 8048df4:	8d 81 1d d9 ff ff    	lea    -0x26e3(%ecx),%eax
 8048dfa:	e9 ed 02 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOLCK: return "No record locks available.";
 8048dff:	8d 81 31 d9 ff ff    	lea    -0x26cf(%ecx),%eax
 8048e05:	e9 e2 02 00 00       	jmp    80490ec <strerror+0x71d>
                case ECANCELED: return "Operation canceled";
 8048e0a:	8d 81 4c d9 ff ff    	lea    -0x26b4(%ecx),%eax
 8048e10:	e9 d7 02 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOTSUP: return "Operation not supported";
 8048e15:	8d 81 5f d9 ff ff    	lea    -0x26a1(%ecx),%eax
 8048e1b:	e9 cc 02 00 00       	jmp    80490ec <strerror+0x71d>
                case EDQUOT: return "Disc quota exceeded";
 8048e20:	8d 81 77 d9 ff ff    	lea    -0x2689(%ecx),%eax
 8048e26:	e9 c1 02 00 00       	jmp    80490ec <strerror+0x71d>
                case EBADE: return "invalid exchange";
 8048e2b:	8d 81 8b d9 ff ff    	lea    -0x2675(%ecx),%eax
 8048e31:	e9 b6 02 00 00       	jmp    80490ec <strerror+0x71d>
                case EBADR: return "invalid request descriptor";
 8048e36:	8d 81 9c d9 ff ff    	lea    -0x2664(%ecx),%eax
 8048e3c:	e9 ab 02 00 00       	jmp    80490ec <strerror+0x71d>
                case EXFULL: return "exchange full";
 8048e41:	8d 81 b7 d9 ff ff    	lea    -0x2649(%ecx),%eax
 8048e47:	e9 a0 02 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOANO: return "no anode";
 8048e4c:	8d 81 c5 d9 ff ff    	lea    -0x263b(%ecx),%eax
 8048e52:	e9 95 02 00 00       	jmp    80490ec <strerror+0x71d>
                case EBADRQC: return "invalid request code";
 8048e57:	8d 81 ce d9 ff ff    	lea    -0x2632(%ecx),%eax
 8048e5d:	e9 8a 02 00 00       	jmp    80490ec <strerror+0x71d>
                case EBADSLT: return "invalid slot";
 8048e62:	8d 81 e3 d9 ff ff    	lea    -0x261d(%ecx),%eax
 8048e68:	e9 7f 02 00 00       	jmp    80490ec <strerror+0x71d>
                case EBFONT: return "bad font file fmt";
 8048e6d:	8d 81 f0 d9 ff ff    	lea    -0x2610(%ecx),%eax
 8048e73:	e9 74 02 00 00       	jmp    80490ec <strerror+0x71d>
                case EOWNERDEAD: return "process died with the lock";
 8048e78:	8d 81 02 da ff ff    	lea    -0x25fe(%ecx),%eax
 8048e7e:	e9 69 02 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOTRECOVERABLE: return "lock is not recoverable";
 8048e83:	8d 81 1d da ff ff    	lea    -0x25e3(%ecx),%eax
 8048e89:	e9 5e 02 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOSTR: return "Device not a stream";
 8048e8e:	8d 81 35 da ff ff    	lea    -0x25cb(%ecx),%eax
 8048e94:	e9 53 02 00 00       	jmp    80490ec <strerror+0x71d>
                case ENODATA: return "no data (for no delay io)";
 8048e99:	8d 81 49 da ff ff    	lea    -0x25b7(%ecx),%eax
 8048e9f:	e9 48 02 00 00       	jmp    80490ec <strerror+0x71d>
                case ETIME: return "timer expired";
 8048ea4:	8d 81 63 da ff ff    	lea    -0x259d(%ecx),%eax
 8048eaa:	e9 3d 02 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOSR: return "out of streams resources";
 8048eaf:	8d 81 71 da ff ff    	lea    -0x258f(%ecx),%eax
 8048eb5:	e9 32 02 00 00       	jmp    80490ec <strerror+0x71d>
                case ENONET: return "Machine is not on the network";
 8048eba:	8d 81 8a da ff ff    	lea    -0x2576(%ecx),%eax
 8048ec0:	e9 27 02 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOPKG: return "Package not installed";
 8048ec5:	8d 81 a8 da ff ff    	lea    -0x2558(%ecx),%eax
 8048ecb:	e9 1c 02 00 00       	jmp    80490ec <strerror+0x71d>
                case EREMOTE: return "The object is remote";
 8048ed0:	8d 81 be da ff ff    	lea    -0x2542(%ecx),%eax
 8048ed6:	e9 11 02 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOLINK: return "the link has been severed";
 8048edb:	8d 81 d3 da ff ff    	lea    -0x252d(%ecx),%eax
 8048ee1:	e9 06 02 00 00       	jmp    80490ec <strerror+0x71d>
                case EADV: return "advertise error";
 8048ee6:	8d 81 ed da ff ff    	lea    -0x2513(%ecx),%eax
 8048eec:	e9 fb 01 00 00       	jmp    80490ec <strerror+0x71d>
                case ESRMNT: return "srmount error";
 8048ef1:	8d 81 fd da ff ff    	lea    -0x2503(%ecx),%eax
 8048ef7:	e9 f0 01 00 00       	jmp    80490ec <strerror+0x71d>
                case ECOMM: return "Communication error on send";
 8048efc:	8d 81 0b db ff ff    	lea    -0x24f5(%ecx),%eax
 8048f02:	e9 e5 01 00 00       	jmp    80490ec <strerror+0x71d>
                case EPROTO: return "Protocol error";
 8048f07:	8d 81 27 db ff ff    	lea    -0x24d9(%ecx),%eax
 8048f0d:	e9 da 01 00 00       	jmp    80490ec <strerror+0x71d>
                case EMULTIHOP: return "multihop attempted";
 8048f12:	8d 81 36 db ff ff    	lea    -0x24ca(%ecx),%eax
 8048f18:	e9 cf 01 00 00       	jmp    80490ec <strerror+0x71d>
                case EBADMSG: return "trying to read unreadable message";
 8048f1d:	8d 81 4c db ff ff    	lea    -0x24b4(%ecx),%eax
 8048f23:	e9 c4 01 00 00       	jmp    80490ec <strerror+0x71d>
                case ENAMETOOLONG: return "path name is too long";
 8048f28:	8d 81 6e db ff ff    	lea    -0x2492(%ecx),%eax
 8048f2e:	e9 b9 01 00 00       	jmp    80490ec <strerror+0x71d>
                case EOVERFLOW: return "value too large to be stored in data type";
 8048f33:	8d 81 84 db ff ff    	lea    -0x247c(%ecx),%eax
 8048f39:	e9 ae 01 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOTUNIQ: return "given log. name not unique";
 8048f3e:	8d 81 ae db ff ff    	lea    -0x2452(%ecx),%eax
 8048f44:	e9 a3 01 00 00       	jmp    80490ec <strerror+0x71d>
                case EBADFD: return "f.d. invalid for this operation";
 8048f49:	8d 81 cc db ff ff    	lea    -0x2434(%ecx),%eax
 8048f4f:	e9 98 01 00 00       	jmp    80490ec <strerror+0x71d>
                case EREMCHG: return "Remote address changed";
 8048f54:	8d 81 ec db ff ff    	lea    -0x2414(%ecx),%eax
 8048f5a:	e9 8d 01 00 00       	jmp    80490ec <strerror+0x71d>
                case ELIBACC: return "Can't access a needed shared lib.";
 8048f5f:	8d 81 04 dc ff ff    	lea    -0x23fc(%ecx),%eax
 8048f65:	e9 82 01 00 00       	jmp    80490ec <strerror+0x71d>
                case ELIBBAD: return "Accessing a corrupted shared lib.";
 8048f6a:	8d 81 28 dc ff ff    	lea    -0x23d8(%ecx),%eax
 8048f70:	e9 77 01 00 00       	jmp    80490ec <strerror+0x71d>
                case ELIBSCN: return ".lib section in a.out corrupted.";
 8048f75:	8d 81 4c dc ff ff    	lea    -0x23b4(%ecx),%eax
 8048f7b:	e9 6c 01 00 00       	jmp    80490ec <strerror+0x71d>
                case ELIBMAX: return "Attempting to link in too many libs.";
 8048f80:	8d 81 70 dc ff ff    	lea    -0x2390(%ecx),%eax
 8048f86:	e9 61 01 00 00       	jmp    80490ec <strerror+0x71d>
                case ELIBEXEC: return "Attempting to exec a shared library.";
 8048f8b:	8d 81 98 dc ff ff    	lea    -0x2368(%ecx),%eax
 8048f91:	e9 56 01 00 00       	jmp    80490ec <strerror+0x71d>
                case EILSEQ: return "Illegal byte sequence.";
 8048f96:	8d 81 bd dc ff ff    	lea    -0x2343(%ecx),%eax
 8048f9c:	e9 4b 01 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOSYS: return "Unsupported file system operation";
 8048fa1:	8d 81 d4 dc ff ff    	lea    -0x232c(%ecx),%eax
 8048fa7:	e9 40 01 00 00       	jmp    80490ec <strerror+0x71d>
                case ELOOP: return "Symbolic link loop";
 8048fac:	8d 81 f6 dc ff ff    	lea    -0x230a(%ecx),%eax
 8048fb2:	e9 35 01 00 00       	jmp    80490ec <strerror+0x71d>
                case ERESTART: return "Restartable system call";
 8048fb7:	8d 81 09 dd ff ff    	lea    -0x22f7(%ecx),%eax
 8048fbd:	e9 2a 01 00 00       	jmp    80490ec <strerror+0x71d>
                case ESTRPIPE: return "if pipe/FIFO, don't sleep in stream head";
 8048fc2:	8d 81 24 dd ff ff    	lea    -0x22dc(%ecx),%eax
 8048fc8:	e9 1f 01 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOTEMPTY: return "directory not empty";
 8048fcd:	8d 81 4d dd ff ff    	lea    -0x22b3(%ecx),%eax
 8048fd3:	e9 14 01 00 00       	jmp    80490ec <strerror+0x71d>
                case EUSERS: return "Too many users (for UFS)";
 8048fd8:	8d 81 61 dd ff ff    	lea    -0x229f(%ecx),%eax
 8048fde:	e9 09 01 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOTSOCK: return "Socket operation on non-socket";
 8048fe3:	8d 81 7c dd ff ff    	lea    -0x2284(%ecx),%eax
 8048fe9:	e9 fe 00 00 00       	jmp    80490ec <strerror+0x71d>
                case EDESTADDRREQ: return "Destination address required";
 8048fee:	8d 81 9b dd ff ff    	lea    -0x2265(%ecx),%eax
 8048ff4:	e9 f3 00 00 00       	jmp    80490ec <strerror+0x71d>
                case EMSGSIZE: return "Message too long";
 8048ff9:	8d 81 b8 dd ff ff    	lea    -0x2248(%ecx),%eax
 8048fff:	e9 e8 00 00 00       	jmp    80490ec <strerror+0x71d>
                case EPROTOTYPE: return "Protocol wrong type for socket";
 8049004:	8d 81 cc dd ff ff    	lea    -0x2234(%ecx),%eax
 804900a:	e9 dd 00 00 00       	jmp    80490ec <strerror+0x71d>
                case ENOPROTOOPT: return "Protocol not available";
 804900f:	8d 81 eb dd ff ff    	lea    -0x2215(%ecx),%eax
 8049015:	e9 d2 00 00 00       	jmp    80490ec <strerror+0x71d>
                case EPROTONOSUPPORT: return "Protocol not supported";
 804901a:	8d 81 02 de ff ff    	lea    -0x21fe(%ecx),%eax
 8049020:	e9 c7 00 00 00       	jmp    80490ec <strerror+0x71d>
                case ESOCKTNOSUPPORT: return "Socket type not supported";
 8049025:	8d 81 19 de ff ff    	lea    -0x21e7(%ecx),%eax
 804902b:	e9 bc 00 00 00       	jmp    80490ec <strerror+0x71d>
                case EPFNOSUPPORT: return "Protocol family not supported";
 8049030:	8d 81 33 de ff ff    	lea    -0x21cd(%ecx),%eax
 8049036:	e9 b1 00 00 00       	jmp    80490ec <strerror+0x71d>
                case EAFNOSUPPORT: return "Address family not supported by protocol family";
 804903b:	8d 81 54 de ff ff    	lea    -0x21ac(%ecx),%eax
 8049041:	e9 a6 00 00 00       	jmp    80490ec <strerror+0x71d>
                case EADDRINUSE: return "Address already in use";
 8049046:	8d 81 84 de ff ff    	lea    -0x217c(%ecx),%eax
 804904c:	e9 9b 00 00 00       	jmp    80490ec <strerror+0x71d>
                case EADDRNOTAVAIL: return "Can't assign requested address";
 8049051:	8d 81 9c de ff ff    	lea    -0x2164(%ecx),%eax
 8049057:	e9 90 00 00 00       	jmp    80490ec <strerror+0x71d>
                case ENETDOWN: return "Network is down";
 804905c:	8d 81 bb de ff ff    	lea    -0x2145(%ecx),%eax
 8049062:	e9 85 00 00 00       	jmp    80490ec <strerror+0x71d>
                case ENETUNREACH: return "Network is unreachable";
 8049067:	8d 81 cb de ff ff    	lea    -0x2135(%ecx),%eax
 804906d:	eb 7d                	jmp    80490ec <strerror+0x71d>
                case ENETRESET: return "Network dropped connection because of reset";
 804906f:	8d 81 e4 de ff ff    	lea    -0x211c(%ecx),%eax
 8049075:	eb 75                	jmp    80490ec <strerror+0x71d>
                case ECONNABORTED: return "Software caused connection abort";
 8049077:	8d 81 10 df ff ff    	lea    -0x20f0(%ecx),%eax
 804907d:	eb 6d                	jmp    80490ec <strerror+0x71d>
                case ECONNRESET: return "Connection reset by peer";
 804907f:	8d 81 31 df ff ff    	lea    -0x20cf(%ecx),%eax
 8049085:	eb 65                	jmp    80490ec <strerror+0x71d>
                case ENOBUFS: return "No buffer space available";
 8049087:	8d 81 4a df ff ff    	lea    -0x20b6(%ecx),%eax
 804908d:	eb 5d                	jmp    80490ec <strerror+0x71d>
                case EISCONN: return "Socket is already connected";
 804908f:	8d 81 64 df ff ff    	lea    -0x209c(%ecx),%eax
 8049095:	eb 55                	jmp    80490ec <strerror+0x71d>
                case ENOTCONN: return "Socket is not connected";
 8049097:	8d 81 80 df ff ff    	lea    -0x2080(%ecx),%eax
 804909d:	eb 4d                	jmp    80490ec <strerror+0x71d>
                case ESHUTDOWN: return "Can't send after socket shutdown";
 804909f:	8d 81 98 df ff ff    	lea    -0x2068(%ecx),%eax
 80490a5:	eb 45                	jmp    80490ec <strerror+0x71d>
                case ETOOMANYREFS: return "Too many references: can't splice";
 80490a7:	8d 81 bc df ff ff    	lea    -0x2044(%ecx),%eax
 80490ad:	eb 3d                	jmp    80490ec <strerror+0x71d>
                case ETIMEDOUT: return "Connection timed out";
 80490af:	8d 81 de df ff ff    	lea    -0x2022(%ecx),%eax
 80490b5:	eb 35                	jmp    80490ec <strerror+0x71d>
                case ECONNREFUSED: return "Connection refused";
 80490b7:	8d 81 f3 df ff ff    	lea    -0x200d(%ecx),%eax
 80490bd:	eb 2d                	jmp    80490ec <strerror+0x71d>
                case EHOSTDOWN: return "Host is down";
 80490bf:	8d 81 06 e0 ff ff    	lea    -0x1ffa(%ecx),%eax
 80490c5:	eb 25                	jmp    80490ec <strerror+0x71d>
                case EHOSTUNREACH: return "No route to host";
 80490c7:	8d 81 13 e0 ff ff    	lea    -0x1fed(%ecx),%eax
 80490cd:	eb 1d                	jmp    80490ec <strerror+0x71d>
                case EALREADY: return "operation already in progress";
 80490cf:	8d 81 24 e0 ff ff    	lea    -0x1fdc(%ecx),%eax
 80490d5:	eb 15                	jmp    80490ec <strerror+0x71d>
                case EINPROGRESS: return "operation now in progress";
 80490d7:	8d 81 42 e0 ff ff    	lea    -0x1fbe(%ecx),%eax
 80490dd:	eb 0d                	jmp    80490ec <strerror+0x71d>
                case ESTALE: return "Stale NFS file handle";
 80490df:	8d 81 5c e0 ff ff    	lea    -0x1fa4(%ecx),%eax
 80490e5:	eb 05                	jmp    80490ec <strerror+0x71d>
                default: return 0;
 80490e7:	b8 00 00 00 00       	mov    $0x0,%eax
        }
}
 80490ec:	5d                   	pop    %ebp
 80490ed:	c3                   	ret    

080490ee <__i686.get_pc_thunk.cx>:
 80490ee:	8b 0c 24             	mov    (%esp),%ecx
 80490f1:	c3                   	ret    
 80490f2:	90                   	nop
 80490f3:	90                   	nop

080490f4 <trap>:
#include "errno.h"

#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
 80490f4:	55                   	push   %ebp
 80490f5:	89 e5                	mov    %esp,%ebp
 80490f7:	56                   	push   %esi
 80490f8:	83 ec 14             	sub    $0x14,%esp
 80490fb:	e8 ee ff ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 8049100:	81 c1 80 70 00 00    	add    $0x7080,%ecx
        int ret;
        __asm__ volatile(
 8049106:	8b 45 08             	mov    0x8(%ebp),%eax
 8049109:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804910c:	8b 55 0c             	mov    0xc(%ebp),%edx
 804910f:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049112:	cd 2e                	int    $0x2e
 8049114:	89 c6                	mov    %eax,%esi
 8049116:	89 75 f8             	mov    %esi,-0x8(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049119:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8049120:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049123:	cd 2e                	int    $0x2e
 8049125:	89 c2                	mov    %eax,%edx
 8049127:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 804912d:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804912f:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
 8049132:	83 c4 14             	add    $0x14,%esp
 8049135:	5e                   	pop    %esi
 8049136:	5d                   	pop    %ebp
 8049137:	c3                   	ret    

08049138 <sbrk>:
static void     (*atexit_func[MAX_EXIT_HANDLERS])();
static int      atexit_handlers = 0;


void *sbrk(intptr_t incr)
{
 8049138:	55                   	push   %ebp
 8049139:	89 e5                	mov    %esp,%ebp
 804913b:	56                   	push   %esi
 804913c:	53                   	push   %ebx
 804913d:	83 ec 30             	sub    $0x30,%esp
 8049140:	e8 dc f3 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 8049145:	81 c3 3b 70 00 00    	add    $0x703b,%ebx
        uintptr_t oldbrk;

        /* If we don't have a saved break, find it from the kernel */
        if (!__curbrk) {
 804914b:	8b 83 a0 01 00 00    	mov    0x1a0(%ebx),%eax
 8049151:	85 c0                	test   %eax,%eax
 8049153:	75 51                	jne    80491a6 <sbrk+0x6e>
 8049155:	c7 45 f0 2c 00 00 00 	movl   $0x2c,-0x10(%ebp)
 804915c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049163:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049166:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8049169:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804916c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804916f:	cd 2e                	int    $0x2e
 8049171:	89 c6                	mov    %eax,%esi
 8049173:	89 75 e8             	mov    %esi,-0x18(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049176:	c7 45 e4 27 00 00 00 	movl   $0x27,-0x1c(%ebp)
 804917d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049180:	cd 2e                	int    $0x2e
 8049182:	89 c2                	mov    %eax,%edx
 8049184:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 804918a:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804918c:	8b 45 e8             	mov    -0x18(%ebp),%eax
                if (0 > (long)(__curbrk = (void *) trap(SYS_brk, (uint32_t) NULL))) {
 804918f:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
 8049195:	8b 83 a0 01 00 00    	mov    0x1a0(%ebx),%eax
 804919b:	85 c0                	test   %eax,%eax
 804919d:	79 07                	jns    80491a6 <sbrk+0x6e>
                        return (void *) -1;
 804919f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80491a4:	eb 5b                	jmp    8049201 <sbrk+0xc9>
                }
        }

        oldbrk = (uintptr_t) __curbrk;
 80491a6:	8b 83 a0 01 00 00    	mov    0x1a0(%ebx),%eax
 80491ac:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /* Increment or decrement the saved break */

        if (incr < 0) {
 80491af:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 80491b3:	79 2a                	jns    80491df <sbrk+0xa7>
                if ((uintptr_t) - incr > oldbrk) {
 80491b5:	8b 45 08             	mov    0x8(%ebp),%eax
 80491b8:	f7 d8                	neg    %eax
 80491ba:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 80491bd:	76 07                	jbe    80491c6 <sbrk+0x8e>
                        return (void *) -1;
 80491bf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80491c4:	eb 3b                	jmp    8049201 <sbrk+0xc9>
                } else if (brk((void *)(oldbrk - (uintptr_t) - incr)) < 0) {
 80491c6:	8b 45 08             	mov    0x8(%ebp),%eax
 80491c9:	03 45 f4             	add    -0xc(%ebp),%eax
 80491cc:	89 04 24             	mov    %eax,(%esp)
 80491cf:	e8 34 00 00 00       	call   8049208 <brk>
 80491d4:	85 c0                	test   %eax,%eax
 80491d6:	79 26                	jns    80491fe <sbrk+0xc6>
                        return (void *) -1;
 80491d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80491dd:	eb 22                	jmp    8049201 <sbrk+0xc9>
                }
        } else if (incr > 0) {
 80491df:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 80491e3:	7e 19                	jle    80491fe <sbrk+0xc6>
                if (brk((void *)(oldbrk + (uintptr_t) incr)) < 0) {
 80491e5:	8b 45 08             	mov    0x8(%ebp),%eax
 80491e8:	03 45 f4             	add    -0xc(%ebp),%eax
 80491eb:	89 04 24             	mov    %eax,(%esp)
 80491ee:	e8 15 00 00 00       	call   8049208 <brk>
 80491f3:	85 c0                	test   %eax,%eax
 80491f5:	79 07                	jns    80491fe <sbrk+0xc6>
                        return (void *) -1;
 80491f7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80491fc:	eb 03                	jmp    8049201 <sbrk+0xc9>
                }
        }
        return (void *) oldbrk;
 80491fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8049201:	83 c4 30             	add    $0x30,%esp
 8049204:	5b                   	pop    %ebx
 8049205:	5e                   	pop    %esi
 8049206:	5d                   	pop    %ebp
 8049207:	c3                   	ret    

08049208 <brk>:

int brk(void *addr)
{
 8049208:	55                   	push   %ebp
 8049209:	89 e5                	mov    %esp,%ebp
 804920b:	56                   	push   %esi
 804920c:	83 ec 14             	sub    $0x14,%esp
 804920f:	e8 da fe ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 8049214:	81 c1 6c 6f 00 00    	add    $0x6f6c,%ecx
        if (NULL == addr)
 804921a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804921e:	75 07                	jne    8049227 <brk+0x1f>
                return -1;
 8049220:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8049225:	eb 57                	jmp    804927e <brk+0x76>
        void *newbrk = (void *) trap(SYS_brk, (uint32_t) addr);
 8049227:	8b 45 08             	mov    0x8(%ebp),%eax
 804922a:	c7 45 f4 2c 00 00 00 	movl   $0x2c,-0xc(%ebp)
 8049231:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049234:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049237:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804923a:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804923d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049240:	cd 2e                	int    $0x2e
 8049242:	89 c6                	mov    %eax,%esi
 8049244:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049247:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 804924e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049251:	cd 2e                	int    $0x2e
 8049253:	89 c2                	mov    %eax,%edx
 8049255:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 804925b:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804925d:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049260:	89 45 f8             	mov    %eax,-0x8(%ebp)
        if (newbrk == (void *) -1)
 8049263:	83 7d f8 ff          	cmpl   $0xffffffff,-0x8(%ebp)
 8049267:	75 07                	jne    8049270 <brk+0x68>
                return -1;
 8049269:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804926e:	eb 0e                	jmp    804927e <brk+0x76>
        __curbrk = newbrk;
 8049270:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049273:	89 81 a0 01 00 00    	mov    %eax,0x1a0(%ecx)
        return 0;
 8049279:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804927e:	83 c4 14             	add    $0x14,%esp
 8049281:	5e                   	pop    %esi
 8049282:	5d                   	pop    %ebp
 8049283:	c3                   	ret    

08049284 <fork>:

int fork(void)
{
 8049284:	55                   	push   %ebp
 8049285:	89 e5                	mov    %esp,%ebp
 8049287:	56                   	push   %esi
 8049288:	83 ec 14             	sub    $0x14,%esp
 804928b:	e8 5e fe ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 8049290:	81 c1 f0 6e 00 00    	add    $0x6ef0,%ecx
 8049296:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
 804929d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80492a4:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80492a7:	89 45 e8             	mov    %eax,-0x18(%ebp)
 80492aa:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80492ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80492b0:	cd 2e                	int    $0x2e
 80492b2:	89 c6                	mov    %eax,%esi
 80492b4:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80492b7:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 80492be:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80492c1:	cd 2e                	int    $0x2e
 80492c3:	89 c2                	mov    %eax,%edx
 80492c5:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80492cb:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80492cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
        return trap(SYS_fork, 0);
}
 80492d0:	83 c4 14             	add    $0x14,%esp
 80492d3:	5e                   	pop    %esi
 80492d4:	5d                   	pop    %ebp
 80492d5:	c3                   	ret    

080492d6 <atexit>:

int atexit(void (*func)(void))
{
 80492d6:	55                   	push   %ebp
 80492d7:	89 e5                	mov    %esp,%ebp
 80492d9:	e8 10 fe ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 80492de:	81 c1 a2 6e 00 00    	add    $0x6ea2,%ecx
        if (atexit_handlers < MAX_EXIT_HANDLERS) {
 80492e4:	8b 81 40 02 00 00    	mov    0x240(%ecx),%eax
 80492ea:	83 f8 1f             	cmp    $0x1f,%eax
 80492ed:	7f 20                	jg     804930f <atexit+0x39>
                atexit_func[atexit_handlers++] = func;
 80492ef:	8b 81 40 02 00 00    	mov    0x240(%ecx),%eax
 80492f5:	8b 55 08             	mov    0x8(%ebp),%edx
 80492f8:	89 94 81 c0 01 00 00 	mov    %edx,0x1c0(%ecx,%eax,4)
 80492ff:	83 c0 01             	add    $0x1,%eax
 8049302:	89 81 40 02 00 00    	mov    %eax,0x240(%ecx)
                return 0;
 8049308:	b8 00 00 00 00       	mov    $0x0,%eax
 804930d:	eb 05                	jmp    8049314 <atexit+0x3e>
        }

        return 1;
 804930f:	b8 01 00 00 00       	mov    $0x1,%eax
}
 8049314:	5d                   	pop    %ebp
 8049315:	c3                   	ret    

08049316 <_exit>:

void _exit(int status)
{
 8049316:	55                   	push   %ebp
 8049317:	89 e5                	mov    %esp,%ebp
 8049319:	56                   	push   %esi
 804931a:	83 ec 14             	sub    $0x14,%esp
 804931d:	e8 cc fd ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 8049322:	81 c1 5e 6e 00 00    	add    $0x6e5e,%ecx
        trap(SYS_exit, (uint32_t) status);
 8049328:	8b 45 08             	mov    0x8(%ebp),%eax
 804932b:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
 8049332:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049335:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049338:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804933b:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804933e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049341:	cd 2e                	int    $0x2e
 8049343:	89 c6                	mov    %eax,%esi
 8049345:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049348:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 804934f:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049352:	cd 2e                	int    $0x2e
 8049354:	89 c2                	mov    %eax,%edx
 8049356:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 804935c:	89 10                	mov    %edx,(%eax)

        /* this keeps gcc from warning us about exit returning, because it
         * expects exit not to. We never actually get here. */
        for (;;);
 804935e:	eb fe                	jmp    804935e <_exit+0x48>

08049360 <exit>:
}

void exit(int status)
{
 8049360:	55                   	push   %ebp
 8049361:	89 e5                	mov    %esp,%ebp
 8049363:	53                   	push   %ebx
 8049364:	83 ec 14             	sub    $0x14,%esp
 8049367:	e8 b5 f1 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804936c:	81 c3 14 6e 00 00    	add    $0x6e14,%ebx
        while (atexit_handlers--) {
 8049372:	eb 0f                	jmp    8049383 <exit+0x23>
                atexit_func[atexit_handlers]();
 8049374:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
 804937a:	8b 84 83 c0 01 00 00 	mov    0x1c0(%ebx,%eax,4),%eax
 8049381:	ff d0                	call   *%eax
        for (;;);
}

void exit(int status)
{
        while (atexit_handlers--) {
 8049383:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
 8049389:	85 c0                	test   %eax,%eax
 804938b:	0f 95 c2             	setne  %dl
 804938e:	83 e8 01             	sub    $0x1,%eax
 8049391:	89 83 40 02 00 00    	mov    %eax,0x240(%ebx)
 8049397:	84 d2                	test   %dl,%dl
 8049399:	75 d9                	jne    8049374 <exit+0x14>
                atexit_func[atexit_handlers]();
        }

        _exit(status);
 804939b:	8b 45 08             	mov    0x8(%ebp),%eax
 804939e:	89 04 24             	mov    %eax,(%esp)
 80493a1:	e8 70 ff ff ff       	call   8049316 <_exit>
        exit(status); /* gcc doesn't realize that _exit() exits */
 80493a6:	8b 45 08             	mov    0x8(%ebp),%eax
 80493a9:	89 04 24             	mov    %eax,(%esp)
 80493ac:	e8 af ff ff ff       	call   8049360 <exit>
}
 80493b1:	83 c4 14             	add    $0x14,%esp
 80493b4:	5b                   	pop    %ebx
 80493b5:	5d                   	pop    %ebp
 80493b6:	c3                   	ret    

080493b7 <yield>:

void yield(void)
{
 80493b7:	55                   	push   %ebp
 80493b8:	89 e5                	mov    %esp,%ebp
 80493ba:	53                   	push   %ebx
 80493bb:	83 ec 14             	sub    $0x14,%esp
 80493be:	e8 5e f1 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 80493c3:	81 c3 bd 6d 00 00    	add    $0x6dbd,%ebx
        /* Due to a Bochs bug, the yield syscall itself is highly unyielding
         * (for instance, it's impossible to type while a process is in a yield
         * loop. This is good enough. */
        (fork() ? wait(NULL) : exit(0));
 80493c9:	e8 b6 fe ff ff       	call   8049284 <fork>
 80493ce:	85 c0                	test   %eax,%eax
 80493d0:	74 0e                	je     80493e0 <yield+0x29>
 80493d2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80493d9:	e8 14 00 00 00       	call   80493f2 <wait>
 80493de:	eb 0c                	jmp    80493ec <yield+0x35>
 80493e0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80493e7:	e8 74 ff ff ff       	call   8049360 <exit>
}
 80493ec:	83 c4 14             	add    $0x14,%esp
 80493ef:	5b                   	pop    %ebx
 80493f0:	5d                   	pop    %ebp
 80493f1:	c3                   	ret    

080493f2 <wait>:

pid_t wait(int *status)
{
 80493f2:	55                   	push   %ebp
 80493f3:	89 e5                	mov    %esp,%ebp
 80493f5:	56                   	push   %esi
 80493f6:	83 ec 24             	sub    $0x24,%esp
 80493f9:	e8 f0 fc ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 80493fe:	81 c1 82 6d 00 00    	add    $0x6d82,%ecx
        waitpid_args_t args;

        args.wpa_pid = -1;
 8049404:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
        args.wpa_options = 0;
 804940b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
        args.wpa_status = status;
 8049412:	8b 45 08             	mov    0x8(%ebp),%eax
 8049415:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_waitpid, (uint32_t) &args);
 8049418:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804941b:	c7 45 f8 07 00 00 00 	movl   $0x7,-0x8(%ebp)
 8049422:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049425:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049428:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804942b:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804942e:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049431:	cd 2e                	int    $0x2e
 8049433:	89 c6                	mov    %eax,%esi
 8049435:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049438:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 804943f:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049442:	cd 2e                	int    $0x2e
 8049444:	89 c2                	mov    %eax,%edx
 8049446:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 804944c:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804944e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8049451:	83 c4 24             	add    $0x24,%esp
 8049454:	5e                   	pop    %esi
 8049455:	5d                   	pop    %ebp
 8049456:	c3                   	ret    

08049457 <waitpid>:

pid_t waitpid(pid_t pid, int options, int *status)
{
 8049457:	55                   	push   %ebp
 8049458:	89 e5                	mov    %esp,%ebp
 804945a:	56                   	push   %esi
 804945b:	83 ec 24             	sub    $0x24,%esp
 804945e:	e8 8b fc ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 8049463:	81 c1 1d 6d 00 00    	add    $0x6d1d,%ecx
        waitpid_args_t args;

        args.wpa_pid = pid;
 8049469:	8b 45 08             	mov    0x8(%ebp),%eax
 804946c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.wpa_options = options;
 804946f:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049472:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.wpa_status = status;
 8049475:	8b 45 10             	mov    0x10(%ebp),%eax
 8049478:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_waitpid, (uint32_t) &args);
 804947b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804947e:	c7 45 f8 07 00 00 00 	movl   $0x7,-0x8(%ebp)
 8049485:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049488:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804948b:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804948e:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049491:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049494:	cd 2e                	int    $0x2e
 8049496:	89 c6                	mov    %eax,%esi
 8049498:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804949b:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 80494a2:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80494a5:	cd 2e                	int    $0x2e
 80494a7:	89 c2                	mov    %eax,%edx
 80494a9:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80494af:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80494b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 80494b4:	83 c4 24             	add    $0x24,%esp
 80494b7:	5e                   	pop    %esi
 80494b8:	5d                   	pop    %ebp
 80494b9:	c3                   	ret    

080494ba <thr_exit>:

void thr_exit(int status)
{
 80494ba:	55                   	push   %ebp
 80494bb:	89 e5                	mov    %esp,%ebp
 80494bd:	56                   	push   %esi
 80494be:	83 ec 14             	sub    $0x14,%esp
 80494c1:	e8 28 fc ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 80494c6:	81 c1 ba 6c 00 00    	add    $0x6cba,%ecx
        trap(SYS_thr_exit, (uint32_t) status);
 80494cc:	8b 45 08             	mov    0x8(%ebp),%eax
 80494cf:	c7 45 f8 1f 00 00 00 	movl   $0x1f,-0x8(%ebp)
 80494d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80494d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80494dc:	89 45 e8             	mov    %eax,-0x18(%ebp)
 80494df:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80494e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80494e5:	cd 2e                	int    $0x2e
 80494e7:	89 c6                	mov    %eax,%esi
 80494e9:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80494ec:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 80494f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80494f6:	cd 2e                	int    $0x2e
 80494f8:	89 c2                	mov    %eax,%edx
 80494fa:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8049500:	89 10                	mov    %edx,(%eax)
}
 8049502:	83 c4 14             	add    $0x14,%esp
 8049505:	5e                   	pop    %esi
 8049506:	5d                   	pop    %ebp
 8049507:	c3                   	ret    

08049508 <getpid>:

pid_t getpid(void)
{
 8049508:	55                   	push   %ebp
 8049509:	89 e5                	mov    %esp,%ebp
 804950b:	56                   	push   %esi
 804950c:	83 ec 14             	sub    $0x14,%esp
 804950f:	e8 da fb ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 8049514:	81 c1 6c 6c 00 00    	add    $0x6c6c,%ecx
 804951a:	c7 45 f8 23 00 00 00 	movl   $0x23,-0x8(%ebp)
 8049521:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049528:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804952b:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804952e:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049531:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049534:	cd 2e                	int    $0x2e
 8049536:	89 c6                	mov    %eax,%esi
 8049538:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804953b:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8049542:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049545:	cd 2e                	int    $0x2e
 8049547:	89 c2                	mov    %eax,%edx
 8049549:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 804954f:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049551:	8b 45 f0             	mov    -0x10(%ebp),%eax
        return trap(SYS_getpid, 0);
}
 8049554:	83 c4 14             	add    $0x14,%esp
 8049557:	5e                   	pop    %esi
 8049558:	5d                   	pop    %ebp
 8049559:	c3                   	ret    

0804955a <halt>:

int halt(void)
{
 804955a:	55                   	push   %ebp
 804955b:	89 e5                	mov    %esp,%ebp
 804955d:	56                   	push   %esi
 804955e:	83 ec 14             	sub    $0x14,%esp
 8049561:	e8 88 fb ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 8049566:	81 c1 1a 6c 00 00    	add    $0x6c1a,%ecx
 804956c:	c7 45 f8 28 00 00 00 	movl   $0x28,-0x8(%ebp)
 8049573:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804957a:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804957d:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8049580:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049583:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049586:	cd 2e                	int    $0x2e
 8049588:	89 c6                	mov    %eax,%esi
 804958a:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804958d:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8049594:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049597:	cd 2e                	int    $0x2e
 8049599:	89 c2                	mov    %eax,%edx
 804959b:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80495a1:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80495a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
        return trap(SYS_halt, 0);
}
 80495a6:	83 c4 14             	add    $0x14,%esp
 80495a9:	5e                   	pop    %esi
 80495aa:	5d                   	pop    %ebp
 80495ab:	c3                   	ret    

080495ac <mmap>:

void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t off)
{
 80495ac:	55                   	push   %ebp
 80495ad:	89 e5                	mov    %esp,%ebp
 80495af:	56                   	push   %esi
 80495b0:	83 ec 34             	sub    $0x34,%esp
 80495b3:	e8 36 fb ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 80495b8:	81 c1 c8 6b 00 00    	add    $0x6bc8,%ecx
        mmap_args_t args;

        args.mma_addr = addr;
 80495be:	8b 45 08             	mov    0x8(%ebp),%eax
 80495c1:	89 45 d8             	mov    %eax,-0x28(%ebp)
        args.mma_len = len;
 80495c4:	8b 45 0c             	mov    0xc(%ebp),%eax
 80495c7:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.mma_prot = prot;
 80495ca:	8b 45 10             	mov    0x10(%ebp),%eax
 80495cd:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.mma_flags = flags;
 80495d0:	8b 45 14             	mov    0x14(%ebp),%eax
 80495d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.mma_fd = fd;
 80495d6:	8b 45 18             	mov    0x18(%ebp),%eax
 80495d9:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.mma_off = off;
 80495dc:	8b 45 1c             	mov    0x1c(%ebp),%eax
 80495df:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return (void *) trap(SYS_mmap, (uint32_t) &args);
 80495e2:	8d 45 d8             	lea    -0x28(%ebp),%eax
 80495e5:	c7 45 f8 18 00 00 00 	movl   $0x18,-0x8(%ebp)
 80495ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80495ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80495f2:	89 45 c8             	mov    %eax,-0x38(%ebp)
 80495f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80495f8:	8b 45 c8             	mov    -0x38(%ebp),%eax
 80495fb:	cd 2e                	int    $0x2e
 80495fd:	89 c6                	mov    %eax,%esi
 80495ff:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049602:	c7 45 c8 27 00 00 00 	movl   $0x27,-0x38(%ebp)
 8049609:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804960c:	cd 2e                	int    $0x2e
 804960e:	89 c2                	mov    %eax,%edx
 8049610:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8049616:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049618:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 804961b:	83 c4 34             	add    $0x34,%esp
 804961e:	5e                   	pop    %esi
 804961f:	5d                   	pop    %ebp
 8049620:	c3                   	ret    

08049621 <munmap>:

int munmap(void *addr, size_t len)
{
 8049621:	55                   	push   %ebp
 8049622:	89 e5                	mov    %esp,%ebp
 8049624:	56                   	push   %esi
 8049625:	83 ec 24             	sub    $0x24,%esp
 8049628:	e8 c1 fa ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 804962d:	81 c1 53 6b 00 00    	add    $0x6b53,%ecx
        munmap_args_t args;

        args.addr = addr;
 8049633:	8b 45 08             	mov    0x8(%ebp),%eax
 8049636:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.len = len;
 8049639:	8b 45 0c             	mov    0xc(%ebp),%eax
 804963c:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_munmap, (uint32_t) &args);
 804963f:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8049642:	c7 45 f8 1a 00 00 00 	movl   $0x1a,-0x8(%ebp)
 8049649:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804964c:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804964f:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8049652:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049655:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049658:	cd 2e                	int    $0x2e
 804965a:	89 c6                	mov    %eax,%esi
 804965c:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804965f:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 8049666:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049669:	cd 2e                	int    $0x2e
 804966b:	89 c2                	mov    %eax,%edx
 804966d:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8049673:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049675:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8049678:	83 c4 24             	add    $0x24,%esp
 804967b:	5e                   	pop    %esi
 804967c:	5d                   	pop    %ebp
 804967d:	c3                   	ret    

0804967e <sync>:

void sync(void)
{
 804967e:	55                   	push   %ebp
 804967f:	89 e5                	mov    %esp,%ebp
 8049681:	56                   	push   %esi
 8049682:	83 ec 14             	sub    $0x14,%esp
 8049685:	e8 64 fa ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 804968a:	81 c1 f6 6a 00 00    	add    $0x6af6,%ecx
 8049690:	c7 45 f8 0f 00 00 00 	movl   $0xf,-0x8(%ebp)
 8049697:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804969e:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80496a1:	89 45 e8             	mov    %eax,-0x18(%ebp)
 80496a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80496a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80496aa:	cd 2e                	int    $0x2e
 80496ac:	89 c6                	mov    %eax,%esi
 80496ae:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80496b1:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 80496b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80496bb:	cd 2e                	int    $0x2e
 80496bd:	89 c2                	mov    %eax,%edx
 80496bf:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80496c5:	89 10                	mov    %edx,(%eax)
        trap(SYS_sync, 0);
}
 80496c7:	83 c4 14             	add    $0x14,%esp
 80496ca:	5e                   	pop    %esi
 80496cb:	5d                   	pop    %ebp
 80496cc:	c3                   	ret    

080496cd <open>:

int open(const char *filename, int flags, int mode)
{
 80496cd:	55                   	push   %ebp
 80496ce:	89 e5                	mov    %esp,%ebp
 80496d0:	56                   	push   %esi
 80496d1:	53                   	push   %ebx
 80496d2:	83 ec 40             	sub    $0x40,%esp
 80496d5:	e8 47 ee ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 80496da:	81 c3 a6 6a 00 00    	add    $0x6aa6,%ebx
        open_args_t args;

        args.filename.as_len = strlen(filename);
 80496e0:	8b 45 08             	mov    0x8(%ebp),%eax
 80496e3:	89 04 24             	mov    %eax,(%esp)
 80496e6:	e8 86 f0 ff ff       	call   8048771 <strlen>
 80496eb:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.filename.as_str = filename;
 80496ee:	8b 45 08             	mov    0x8(%ebp),%eax
 80496f1:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.flags = flags;
 80496f4:	8b 45 0c             	mov    0xc(%ebp),%eax
 80496f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.mode = mode;
 80496fa:	8b 45 10             	mov    0x10(%ebp),%eax
 80496fd:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_open, (uint32_t) &args);
 8049700:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8049703:	c7 45 f4 05 00 00 00 	movl   $0x5,-0xc(%ebp)
 804970a:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804970d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049710:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8049713:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8049716:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049719:	cd 2e                	int    $0x2e
 804971b:	89 c6                	mov    %eax,%esi
 804971d:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049720:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8049727:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804972a:	cd 2e                	int    $0x2e
 804972c:	89 c2                	mov    %eax,%edx
 804972e:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8049734:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049736:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8049739:	83 c4 40             	add    $0x40,%esp
 804973c:	5b                   	pop    %ebx
 804973d:	5e                   	pop    %esi
 804973e:	5d                   	pop    %ebp
 804973f:	c3                   	ret    

08049740 <lseek>:

off_t lseek(int fd, off_t offset, int whence)
{
 8049740:	55                   	push   %ebp
 8049741:	89 e5                	mov    %esp,%ebp
 8049743:	56                   	push   %esi
 8049744:	83 ec 24             	sub    $0x24,%esp
 8049747:	e8 a2 f9 ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 804974c:	81 c1 34 6a 00 00    	add    $0x6a34,%ecx
        lseek_args_t args;

        args.fd = fd;
 8049752:	8b 45 08             	mov    0x8(%ebp),%eax
 8049755:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.offset = offset;
 8049758:	8b 45 0c             	mov    0xc(%ebp),%eax
 804975b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.whence = whence;
 804975e:	8b 45 10             	mov    0x10(%ebp),%eax
 8049761:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_lseek, (uint32_t) &args);
 8049764:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8049767:	c7 45 f8 0e 00 00 00 	movl   $0xe,-0x8(%ebp)
 804976e:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049771:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049774:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8049777:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804977a:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804977d:	cd 2e                	int    $0x2e
 804977f:	89 c6                	mov    %eax,%esi
 8049781:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049784:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 804978b:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804978e:	cd 2e                	int    $0x2e
 8049790:	89 c2                	mov    %eax,%edx
 8049792:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8049798:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804979a:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 804979d:	83 c4 24             	add    $0x24,%esp
 80497a0:	5e                   	pop    %esi
 80497a1:	5d                   	pop    %ebp
 80497a2:	c3                   	ret    

080497a3 <read>:


int read(int fd, void *buf, size_t nbytes)
{
 80497a3:	55                   	push   %ebp
 80497a4:	89 e5                	mov    %esp,%ebp
 80497a6:	56                   	push   %esi
 80497a7:	83 ec 24             	sub    $0x24,%esp
 80497aa:	e8 3f f9 ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 80497af:	81 c1 d1 69 00 00    	add    $0x69d1,%ecx
        read_args_t args;

        args.fd = fd;
 80497b5:	8b 45 08             	mov    0x8(%ebp),%eax
 80497b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.buf = buf;
 80497bb:	8b 45 0c             	mov    0xc(%ebp),%eax
 80497be:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.nbytes = nbytes;
 80497c1:	8b 45 10             	mov    0x10(%ebp),%eax
 80497c4:	89 45 ec             	mov    %eax,-0x14(%ebp)


        return trap(SYS_read, (uint32_t) &args);
 80497c7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 80497ca:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)
 80497d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80497d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80497d7:	89 45 d8             	mov    %eax,-0x28(%ebp)
 80497da:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80497dd:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80497e0:	cd 2e                	int    $0x2e
 80497e2:	89 c6                	mov    %eax,%esi
 80497e4:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80497e7:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 80497ee:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80497f1:	cd 2e                	int    $0x2e
 80497f3:	89 c2                	mov    %eax,%edx
 80497f5:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80497fb:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80497fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8049800:	83 c4 24             	add    $0x24,%esp
 8049803:	5e                   	pop    %esi
 8049804:	5d                   	pop    %ebp
 8049805:	c3                   	ret    

08049806 <write>:

int write(int fd, const void *buf, size_t nbytes)
{
 8049806:	55                   	push   %ebp
 8049807:	89 e5                	mov    %esp,%ebp
 8049809:	56                   	push   %esi
 804980a:	83 ec 24             	sub    $0x24,%esp
 804980d:	e8 dc f8 ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 8049812:	81 c1 6e 69 00 00    	add    $0x696e,%ecx
        write_args_t args;

        args.fd = fd;
 8049818:	8b 45 08             	mov    0x8(%ebp),%eax
 804981b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.buf = (void *) buf;
 804981e:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049821:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.nbytes = nbytes;
 8049824:	8b 45 10             	mov    0x10(%ebp),%eax
 8049827:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_write, (uint32_t) &args);
 804982a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804982d:	c7 45 f8 04 00 00 00 	movl   $0x4,-0x8(%ebp)
 8049834:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049837:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804983a:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804983d:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049840:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049843:	cd 2e                	int    $0x2e
 8049845:	89 c6                	mov    %eax,%esi
 8049847:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804984a:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 8049851:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049854:	cd 2e                	int    $0x2e
 8049856:	89 c2                	mov    %eax,%edx
 8049858:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 804985e:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049860:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8049863:	83 c4 24             	add    $0x24,%esp
 8049866:	5e                   	pop    %esi
 8049867:	5d                   	pop    %ebp
 8049868:	c3                   	ret    

08049869 <close>:

int close(int fd)
{
 8049869:	55                   	push   %ebp
 804986a:	89 e5                	mov    %esp,%ebp
 804986c:	56                   	push   %esi
 804986d:	83 ec 14             	sub    $0x14,%esp
 8049870:	e8 79 f8 ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 8049875:	81 c1 0b 69 00 00    	add    $0x690b,%ecx
        return trap(SYS_close, (uint32_t) fd);
 804987b:	8b 45 08             	mov    0x8(%ebp),%eax
 804987e:	c7 45 f8 06 00 00 00 	movl   $0x6,-0x8(%ebp)
 8049885:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049888:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804988b:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804988e:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049891:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049894:	cd 2e                	int    $0x2e
 8049896:	89 c6                	mov    %eax,%esi
 8049898:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804989b:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 80498a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80498a5:	cd 2e                	int    $0x2e
 80498a7:	89 c2                	mov    %eax,%edx
 80498a9:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80498af:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80498b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 80498b4:	83 c4 14             	add    $0x14,%esp
 80498b7:	5e                   	pop    %esi
 80498b8:	5d                   	pop    %ebp
 80498b9:	c3                   	ret    

080498ba <dup>:

int dup(int fd)
{
 80498ba:	55                   	push   %ebp
 80498bb:	89 e5                	mov    %esp,%ebp
 80498bd:	56                   	push   %esi
 80498be:	83 ec 14             	sub    $0x14,%esp
 80498c1:	e8 28 f8 ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 80498c6:	81 c1 ba 68 00 00    	add    $0x68ba,%ecx
        return trap(SYS_dup, (uint32_t) fd);
 80498cc:	8b 45 08             	mov    0x8(%ebp),%eax
 80498cf:	c7 45 f8 11 00 00 00 	movl   $0x11,-0x8(%ebp)
 80498d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80498d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80498dc:	89 45 e8             	mov    %eax,-0x18(%ebp)
 80498df:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80498e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80498e5:	cd 2e                	int    $0x2e
 80498e7:	89 c6                	mov    %eax,%esi
 80498e9:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80498ec:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 80498f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80498f6:	cd 2e                	int    $0x2e
 80498f8:	89 c2                	mov    %eax,%edx
 80498fa:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8049900:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049902:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8049905:	83 c4 14             	add    $0x14,%esp
 8049908:	5e                   	pop    %esi
 8049909:	5d                   	pop    %ebp
 804990a:	c3                   	ret    

0804990b <dup2>:

int dup2(int ofd, int nfd)
{
 804990b:	55                   	push   %ebp
 804990c:	89 e5                	mov    %esp,%ebp
 804990e:	56                   	push   %esi
 804990f:	83 ec 24             	sub    $0x24,%esp
 8049912:	e8 d7 f7 ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 8049917:	81 c1 69 68 00 00    	add    $0x6869,%ecx
        dup2_args_t args;

        args.ofd = ofd;
 804991d:	8b 45 08             	mov    0x8(%ebp),%eax
 8049920:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.nfd = nfd;
 8049923:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049926:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_dup2, (uint32_t) &args);
 8049929:	8d 45 e8             	lea    -0x18(%ebp),%eax
 804992c:	c7 45 f8 2b 00 00 00 	movl   $0x2b,-0x8(%ebp)
 8049933:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049936:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049939:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804993c:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804993f:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049942:	cd 2e                	int    $0x2e
 8049944:	89 c6                	mov    %eax,%esi
 8049946:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049949:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 8049950:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049953:	cd 2e                	int    $0x2e
 8049955:	89 c2                	mov    %eax,%edx
 8049957:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 804995d:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804995f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8049962:	83 c4 24             	add    $0x24,%esp
 8049965:	5e                   	pop    %esi
 8049966:	5d                   	pop    %ebp
 8049967:	c3                   	ret    

08049968 <mkdir>:

int mkdir(const char *path, int mode)
{
 8049968:	55                   	push   %ebp
 8049969:	89 e5                	mov    %esp,%ebp
 804996b:	56                   	push   %esi
 804996c:	53                   	push   %ebx
 804996d:	83 ec 40             	sub    $0x40,%esp
 8049970:	e8 ac eb ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 8049975:	81 c3 0b 68 00 00    	add    $0x680b,%ebx
        mkdir_args_t args;

        args.path.as_len = strlen(path);
 804997b:	8b 45 08             	mov    0x8(%ebp),%eax
 804997e:	89 04 24             	mov    %eax,(%esp)
 8049981:	e8 eb ed ff ff       	call   8048771 <strlen>
 8049986:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.path.as_str = path;
 8049989:	8b 45 08             	mov    0x8(%ebp),%eax
 804998c:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.mode = mode;
 804998f:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049992:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_mkdir, (uint32_t) &args);
 8049995:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8049998:	c7 45 f4 16 00 00 00 	movl   $0x16,-0xc(%ebp)
 804999f:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80499a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80499a5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 80499a8:	8b 55 f0             	mov    -0x10(%ebp),%edx
 80499ab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 80499ae:	cd 2e                	int    $0x2e
 80499b0:	89 c6                	mov    %eax,%esi
 80499b2:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80499b5:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 80499bc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 80499bf:	cd 2e                	int    $0x2e
 80499c1:	89 c2                	mov    %eax,%edx
 80499c3:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 80499c9:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80499cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 80499ce:	83 c4 40             	add    $0x40,%esp
 80499d1:	5b                   	pop    %ebx
 80499d2:	5e                   	pop    %esi
 80499d3:	5d                   	pop    %ebp
 80499d4:	c3                   	ret    

080499d5 <rmdir>:

int rmdir(const char *path)
{
 80499d5:	55                   	push   %ebp
 80499d6:	89 e5                	mov    %esp,%ebp
 80499d8:	56                   	push   %esi
 80499d9:	53                   	push   %ebx
 80499da:	83 ec 40             	sub    $0x40,%esp
 80499dd:	e8 3f eb ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 80499e2:	81 c3 9e 67 00 00    	add    $0x679e,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 80499e8:	8b 45 08             	mov    0x8(%ebp),%eax
 80499eb:	89 04 24             	mov    %eax,(%esp)
 80499ee:	e8 7e ed ff ff       	call   8048771 <strlen>
 80499f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 80499f6:	8b 45 08             	mov    0x8(%ebp),%eax
 80499f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_rmdir, (uint32_t) &args);
 80499fc:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 80499ff:	c7 45 f4 15 00 00 00 	movl   $0x15,-0xc(%ebp)
 8049a06:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049a09:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049a0c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8049a0f:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8049a12:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049a15:	cd 2e                	int    $0x2e
 8049a17:	89 c6                	mov    %eax,%esi
 8049a19:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049a1c:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8049a23:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049a26:	cd 2e                	int    $0x2e
 8049a28:	89 c2                	mov    %eax,%edx
 8049a2a:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8049a30:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049a32:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8049a35:	83 c4 40             	add    $0x40,%esp
 8049a38:	5b                   	pop    %ebx
 8049a39:	5e                   	pop    %esi
 8049a3a:	5d                   	pop    %ebp
 8049a3b:	c3                   	ret    

08049a3c <unlink>:

int unlink(const char *path)
{
 8049a3c:	55                   	push   %ebp
 8049a3d:	89 e5                	mov    %esp,%ebp
 8049a3f:	56                   	push   %esi
 8049a40:	53                   	push   %ebx
 8049a41:	83 ec 40             	sub    $0x40,%esp
 8049a44:	e8 d8 ea ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 8049a49:	81 c3 37 67 00 00    	add    $0x6737,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 8049a4f:	8b 45 08             	mov    0x8(%ebp),%eax
 8049a52:	89 04 24             	mov    %eax,(%esp)
 8049a55:	e8 17 ed ff ff       	call   8048771 <strlen>
 8049a5a:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 8049a5d:	8b 45 08             	mov    0x8(%ebp),%eax
 8049a60:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_unlink, (uint32_t) &args);
 8049a63:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8049a66:	c7 45 f4 09 00 00 00 	movl   $0x9,-0xc(%ebp)
 8049a6d:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049a70:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049a73:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8049a76:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8049a79:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049a7c:	cd 2e                	int    $0x2e
 8049a7e:	89 c6                	mov    %eax,%esi
 8049a80:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049a83:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8049a8a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049a8d:	cd 2e                	int    $0x2e
 8049a8f:	89 c2                	mov    %eax,%edx
 8049a91:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8049a97:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049a99:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8049a9c:	83 c4 40             	add    $0x40,%esp
 8049a9f:	5b                   	pop    %ebx
 8049aa0:	5e                   	pop    %esi
 8049aa1:	5d                   	pop    %ebp
 8049aa2:	c3                   	ret    

08049aa3 <link>:

int link(const char *from, const char *to)
{
 8049aa3:	55                   	push   %ebp
 8049aa4:	89 e5                	mov    %esp,%ebp
 8049aa6:	56                   	push   %esi
 8049aa7:	53                   	push   %ebx
 8049aa8:	83 ec 40             	sub    $0x40,%esp
 8049aab:	e8 71 ea ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 8049ab0:	81 c3 d0 66 00 00    	add    $0x66d0,%ebx
        link_args_t args;

        args.from.as_len = strlen(from);
 8049ab6:	8b 45 08             	mov    0x8(%ebp),%eax
 8049ab9:	89 04 24             	mov    %eax,(%esp)
 8049abc:	e8 b0 ec ff ff       	call   8048771 <strlen>
 8049ac1:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.from.as_str = from;
 8049ac4:	8b 45 08             	mov    0x8(%ebp),%eax
 8049ac7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.to.as_len = strlen(to);
 8049aca:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049acd:	89 04 24             	mov    %eax,(%esp)
 8049ad0:	e8 9c ec ff ff       	call   8048771 <strlen>
 8049ad5:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.to.as_str = to;
 8049ad8:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049adb:	89 45 dc             	mov    %eax,-0x24(%ebp)

        return trap(SYS_link, (uint32_t) &args);
 8049ade:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8049ae1:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
 8049ae8:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049aeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049aee:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8049af1:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8049af4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049af7:	cd 2e                	int    $0x2e
 8049af9:	89 c6                	mov    %eax,%esi
 8049afb:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049afe:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8049b05:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049b08:	cd 2e                	int    $0x2e
 8049b0a:	89 c2                	mov    %eax,%edx
 8049b0c:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8049b12:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049b14:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8049b17:	83 c4 40             	add    $0x40,%esp
 8049b1a:	5b                   	pop    %ebx
 8049b1b:	5e                   	pop    %esi
 8049b1c:	5d                   	pop    %ebp
 8049b1d:	c3                   	ret    

08049b1e <rename>:

int rename(const char *oldname, const char *newname)
{
 8049b1e:	55                   	push   %ebp
 8049b1f:	89 e5                	mov    %esp,%ebp
 8049b21:	56                   	push   %esi
 8049b22:	53                   	push   %ebx
 8049b23:	83 ec 40             	sub    $0x40,%esp
 8049b26:	e8 f6 e9 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 8049b2b:	81 c3 55 66 00 00    	add    $0x6655,%ebx
        rename_args_t args;

        args.oldname.as_len = strlen(oldname);
 8049b31:	8b 45 08             	mov    0x8(%ebp),%eax
 8049b34:	89 04 24             	mov    %eax,(%esp)
 8049b37:	e8 35 ec ff ff       	call   8048771 <strlen>
 8049b3c:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.oldname.as_str = oldname;
 8049b3f:	8b 45 08             	mov    0x8(%ebp),%eax
 8049b42:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.newname.as_len = strlen(newname);
 8049b45:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049b48:	89 04 24             	mov    %eax,(%esp)
 8049b4b:	e8 21 ec ff ff       	call   8048771 <strlen>
 8049b50:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.newname.as_str = newname;
 8049b53:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049b56:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        return trap(SYS_rename, (uint32_t) &args);
 8049b59:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8049b5c:	c7 45 f4 1b 00 00 00 	movl   $0x1b,-0xc(%ebp)
 8049b63:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049b66:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049b69:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8049b6c:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8049b6f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049b72:	cd 2e                	int    $0x2e
 8049b74:	89 c6                	mov    %eax,%esi
 8049b76:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049b79:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8049b80:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049b83:	cd 2e                	int    $0x2e
 8049b85:	89 c2                	mov    %eax,%edx
 8049b87:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8049b8d:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049b8f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8049b92:	83 c4 40             	add    $0x40,%esp
 8049b95:	5b                   	pop    %ebx
 8049b96:	5e                   	pop    %esi
 8049b97:	5d                   	pop    %ebp
 8049b98:	c3                   	ret    

08049b99 <chdir>:

int chdir(const char *path)
{
 8049b99:	55                   	push   %ebp
 8049b9a:	89 e5                	mov    %esp,%ebp
 8049b9c:	56                   	push   %esi
 8049b9d:	53                   	push   %ebx
 8049b9e:	83 ec 40             	sub    $0x40,%esp
 8049ba1:	e8 7b e9 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 8049ba6:	81 c3 da 65 00 00    	add    $0x65da,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 8049bac:	8b 45 08             	mov    0x8(%ebp),%eax
 8049baf:	89 04 24             	mov    %eax,(%esp)
 8049bb2:	e8 ba eb ff ff       	call   8048771 <strlen>
 8049bb7:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 8049bba:	8b 45 08             	mov    0x8(%ebp),%eax
 8049bbd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_chdir, (uint32_t) &args);
 8049bc0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8049bc3:	c7 45 f4 0b 00 00 00 	movl   $0xb,-0xc(%ebp)
 8049bca:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049bcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049bd0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8049bd3:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8049bd6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049bd9:	cd 2e                	int    $0x2e
 8049bdb:	89 c6                	mov    %eax,%esi
 8049bdd:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049be0:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8049be7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049bea:	cd 2e                	int    $0x2e
 8049bec:	89 c2                	mov    %eax,%edx
 8049bee:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8049bf4:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049bf6:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8049bf9:	83 c4 40             	add    $0x40,%esp
 8049bfc:	5b                   	pop    %ebx
 8049bfd:	5e                   	pop    %esi
 8049bfe:	5d                   	pop    %ebp
 8049bff:	c3                   	ret    

08049c00 <get_free_mem>:

size_t get_free_mem(void)
{
 8049c00:	55                   	push   %ebp
 8049c01:	89 e5                	mov    %esp,%ebp
 8049c03:	56                   	push   %esi
 8049c04:	83 ec 14             	sub    $0x14,%esp
 8049c07:	e8 e2 f4 ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 8049c0c:	81 c1 74 65 00 00    	add    $0x6574,%ecx
 8049c12:	c7 45 f8 29 00 00 00 	movl   $0x29,-0x8(%ebp)
 8049c19:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049c20:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049c23:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8049c26:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049c29:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049c2c:	cd 2e                	int    $0x2e
 8049c2e:	89 c6                	mov    %eax,%esi
 8049c30:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049c33:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8049c3a:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049c3d:	cd 2e                	int    $0x2e
 8049c3f:	89 c2                	mov    %eax,%edx
 8049c41:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8049c47:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049c49:	8b 45 f0             	mov    -0x10(%ebp),%eax
        return (size_t) trap(SYS_get_free_mem, 0);
}
 8049c4c:	83 c4 14             	add    $0x14,%esp
 8049c4f:	5e                   	pop    %esi
 8049c50:	5d                   	pop    %ebp
 8049c51:	c3                   	ret    

08049c52 <execve>:

int execve(const char *filename, char *const argv[], char *const envp[])
{
 8049c52:	55                   	push   %ebp
 8049c53:	89 e5                	mov    %esp,%ebp
 8049c55:	56                   	push   %esi
 8049c56:	53                   	push   %ebx
 8049c57:	83 ec 50             	sub    $0x50,%esp
 8049c5a:	e8 c2 e8 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 8049c5f:	81 c3 21 65 00 00    	add    $0x6521,%ebx
        execve_args_t           args;

        int i;

        args.filename.as_len = strlen(filename);
 8049c65:	8b 45 08             	mov    0x8(%ebp),%eax
 8049c68:	89 04 24             	mov    %eax,(%esp)
 8049c6b:	e8 01 eb ff ff       	call   8048771 <strlen>
 8049c70:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        args.filename.as_str = filename;
 8049c73:	8b 45 08             	mov    0x8(%ebp),%eax
 8049c76:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /* Build argv vector */
        for (i = 0; argv[i] != NULL; i++)
 8049c79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8049c80:	eb 04                	jmp    8049c86 <execve+0x34>
 8049c82:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 8049c86:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049c89:	c1 e0 02             	shl    $0x2,%eax
 8049c8c:	03 45 0c             	add    0xc(%ebp),%eax
 8049c8f:	8b 00                	mov    (%eax),%eax
 8049c91:	85 c0                	test   %eax,%eax
 8049c93:	75 ed                	jne    8049c82 <execve+0x30>
                ;
        args.argv.av_len = i;
 8049c95:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049c98:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.argv.av_vec = malloc((args.argv.av_len + 1) * sizeof(argstr_t));
 8049c9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8049c9e:	83 c0 01             	add    $0x1,%eax
 8049ca1:	c1 e0 03             	shl    $0x3,%eax
 8049ca4:	89 04 24             	mov    %eax,(%esp)
 8049ca7:	e8 dc 2e 00 00       	call   804cb88 <malloc>
 8049cac:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for (i = 0; argv[i] != NULL; i++) {
 8049caf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8049cb6:	eb 3e                	jmp    8049cf6 <execve+0xa4>
                args.argv.av_vec[i].as_len = strlen(argv[i]);
 8049cb8:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049cbb:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049cbe:	c1 e2 03             	shl    $0x3,%edx
 8049cc1:	8d 34 10             	lea    (%eax,%edx,1),%esi
 8049cc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049cc7:	c1 e0 02             	shl    $0x2,%eax
 8049cca:	03 45 0c             	add    0xc(%ebp),%eax
 8049ccd:	8b 00                	mov    (%eax),%eax
 8049ccf:	89 04 24             	mov    %eax,(%esp)
 8049cd2:	e8 9a ea ff ff       	call   8048771 <strlen>
 8049cd7:	89 46 04             	mov    %eax,0x4(%esi)
                args.argv.av_vec[i].as_str = argv[i];
 8049cda:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049cdd:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049ce0:	c1 e2 03             	shl    $0x3,%edx
 8049ce3:	01 c2                	add    %eax,%edx
 8049ce5:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049ce8:	c1 e0 02             	shl    $0x2,%eax
 8049ceb:	03 45 0c             	add    0xc(%ebp),%eax
 8049cee:	8b 00                	mov    (%eax),%eax
 8049cf0:	89 02                	mov    %eax,(%edx)
        /* Build argv vector */
        for (i = 0; argv[i] != NULL; i++)
                ;
        args.argv.av_len = i;
        args.argv.av_vec = malloc((args.argv.av_len + 1) * sizeof(argstr_t));
        for (i = 0; argv[i] != NULL; i++) {
 8049cf2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 8049cf6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049cf9:	c1 e0 02             	shl    $0x2,%eax
 8049cfc:	03 45 0c             	add    0xc(%ebp),%eax
 8049cff:	8b 00                	mov    (%eax),%eax
 8049d01:	85 c0                	test   %eax,%eax
 8049d03:	75 b3                	jne    8049cb8 <execve+0x66>
                args.argv.av_vec[i].as_len = strlen(argv[i]);
                args.argv.av_vec[i].as_str = argv[i];
        }
        args.argv.av_vec[i].as_len = 0;
 8049d05:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049d08:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049d0b:	c1 e2 03             	shl    $0x3,%edx
 8049d0e:	01 d0                	add    %edx,%eax
 8049d10:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        args.argv.av_vec[i].as_str = NULL;
 8049d17:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049d1a:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049d1d:	c1 e2 03             	shl    $0x3,%edx
 8049d20:	01 d0                	add    %edx,%eax
 8049d22:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

        /* Build envp vector */
        for (i = 0; envp[i] != NULL; i++)
 8049d28:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8049d2f:	eb 04                	jmp    8049d35 <execve+0xe3>
 8049d31:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 8049d35:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049d38:	c1 e0 02             	shl    $0x2,%eax
 8049d3b:	03 45 10             	add    0x10(%ebp),%eax
 8049d3e:	8b 00                	mov    (%eax),%eax
 8049d40:	85 c0                	test   %eax,%eax
 8049d42:	75 ed                	jne    8049d31 <execve+0xdf>
                ;
        args.envp.av_len = i;
 8049d44:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049d47:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.envp.av_vec = malloc((args.envp.av_len + 1) * sizeof(argstr_t));
 8049d4a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049d4d:	83 c0 01             	add    $0x1,%eax
 8049d50:	c1 e0 03             	shl    $0x3,%eax
 8049d53:	89 04 24             	mov    %eax,(%esp)
 8049d56:	e8 2d 2e 00 00       	call   804cb88 <malloc>
 8049d5b:	89 45 e0             	mov    %eax,-0x20(%ebp)
        for (i = 0; envp[i] != NULL; i++) {
 8049d5e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8049d65:	eb 3e                	jmp    8049da5 <execve+0x153>
                args.envp.av_vec[i].as_len = strlen(envp[i]);
 8049d67:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049d6a:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049d6d:	c1 e2 03             	shl    $0x3,%edx
 8049d70:	8d 34 10             	lea    (%eax,%edx,1),%esi
 8049d73:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049d76:	c1 e0 02             	shl    $0x2,%eax
 8049d79:	03 45 10             	add    0x10(%ebp),%eax
 8049d7c:	8b 00                	mov    (%eax),%eax
 8049d7e:	89 04 24             	mov    %eax,(%esp)
 8049d81:	e8 eb e9 ff ff       	call   8048771 <strlen>
 8049d86:	89 46 04             	mov    %eax,0x4(%esi)
                args.envp.av_vec[i].as_str = envp[i];
 8049d89:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049d8c:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049d8f:	c1 e2 03             	shl    $0x3,%edx
 8049d92:	01 c2                	add    %eax,%edx
 8049d94:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049d97:	c1 e0 02             	shl    $0x2,%eax
 8049d9a:	03 45 10             	add    0x10(%ebp),%eax
 8049d9d:	8b 00                	mov    (%eax),%eax
 8049d9f:	89 02                	mov    %eax,(%edx)
        /* Build envp vector */
        for (i = 0; envp[i] != NULL; i++)
                ;
        args.envp.av_len = i;
        args.envp.av_vec = malloc((args.envp.av_len + 1) * sizeof(argstr_t));
        for (i = 0; envp[i] != NULL; i++) {
 8049da1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 8049da5:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049da8:	c1 e0 02             	shl    $0x2,%eax
 8049dab:	03 45 10             	add    0x10(%ebp),%eax
 8049dae:	8b 00                	mov    (%eax),%eax
 8049db0:	85 c0                	test   %eax,%eax
 8049db2:	75 b3                	jne    8049d67 <execve+0x115>
                args.envp.av_vec[i].as_len = strlen(envp[i]);
                args.envp.av_vec[i].as_str = envp[i];
        }
        args.envp.av_vec[i].as_len = 0;
 8049db4:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049db7:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049dba:	c1 e2 03             	shl    $0x3,%edx
 8049dbd:	01 d0                	add    %edx,%eax
 8049dbf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        args.envp.av_vec[i].as_str = NULL;
 8049dc6:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049dc9:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049dcc:	c1 e2 03             	shl    $0x3,%edx
 8049dcf:	01 d0                	add    %edx,%eax
 8049dd1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

        /* Note that we don't need to worry about freeing since we are going to exec
         * (so all our memory will be cleaned up) */

        return trap(SYS_execve, (uint32_t) &args);
 8049dd7:	8d 45 d0             	lea    -0x30(%ebp),%eax
 8049dda:	c7 45 f0 0a 00 00 00 	movl   $0xa,-0x10(%ebp)
 8049de1:	89 45 ec             	mov    %eax,-0x14(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049de4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049de7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 8049dea:	8b 55 ec             	mov    -0x14(%ebp),%edx
 8049ded:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8049df0:	cd 2e                	int    $0x2e
 8049df2:	89 c6                	mov    %eax,%esi
 8049df4:	89 75 e8             	mov    %esi,-0x18(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049df7:	c7 45 c4 27 00 00 00 	movl   $0x27,-0x3c(%ebp)
 8049dfe:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8049e01:	cd 2e                	int    $0x2e
 8049e03:	89 c2                	mov    %eax,%edx
 8049e05:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8049e0b:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049e0d:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
 8049e10:	83 c4 50             	add    $0x50,%esp
 8049e13:	5b                   	pop    %ebx
 8049e14:	5e                   	pop    %esi
 8049e15:	5d                   	pop    %ebp
 8049e16:	c3                   	ret    

08049e17 <thr_set_errno>:

void thr_set_errno(int n)
{
 8049e17:	55                   	push   %ebp
 8049e18:	89 e5                	mov    %esp,%ebp
 8049e1a:	56                   	push   %esi
 8049e1b:	83 ec 14             	sub    $0x14,%esp
 8049e1e:	e8 cb f2 ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 8049e23:	81 c1 5d 63 00 00    	add    $0x635d,%ecx
        trap(SYS_set_errno, (uint32_t) n);
 8049e29:	8b 45 08             	mov    0x8(%ebp),%eax
 8049e2c:	c7 45 f8 2a 00 00 00 	movl   $0x2a,-0x8(%ebp)
 8049e33:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049e36:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049e39:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8049e3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049e3f:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049e42:	cd 2e                	int    $0x2e
 8049e44:	89 c6                	mov    %eax,%esi
 8049e46:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049e49:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8049e50:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049e53:	cd 2e                	int    $0x2e
 8049e55:	89 c2                	mov    %eax,%edx
 8049e57:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8049e5d:	89 10                	mov    %edx,(%eax)
}
 8049e5f:	83 c4 14             	add    $0x14,%esp
 8049e62:	5e                   	pop    %esi
 8049e63:	5d                   	pop    %ebp
 8049e64:	c3                   	ret    

08049e65 <thr_errno>:

int thr_errno(void)
{
 8049e65:	55                   	push   %ebp
 8049e66:	89 e5                	mov    %esp,%ebp
 8049e68:	56                   	push   %esi
 8049e69:	83 ec 14             	sub    $0x14,%esp
 8049e6c:	e8 7d f2 ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 8049e71:	81 c1 0f 63 00 00    	add    $0x630f,%ecx
 8049e77:	c7 45 f8 27 00 00 00 	movl   $0x27,-0x8(%ebp)
 8049e7e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049e85:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049e88:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8049e8b:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049e8e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049e91:	cd 2e                	int    $0x2e
 8049e93:	89 c6                	mov    %eax,%esi
 8049e95:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049e98:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8049e9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049ea2:	cd 2e                	int    $0x2e
 8049ea4:	89 c2                	mov    %eax,%edx
 8049ea6:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8049eac:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049eae:	8b 45 f0             	mov    -0x10(%ebp),%eax
        return trap(SYS_errno, 0);
}
 8049eb1:	83 c4 14             	add    $0x14,%esp
 8049eb4:	5e                   	pop    %esi
 8049eb5:	5d                   	pop    %ebp
 8049eb6:	c3                   	ret    

08049eb7 <getdents>:

int getdents(int fd, dirent_t *dir, size_t size)
{
 8049eb7:	55                   	push   %ebp
 8049eb8:	89 e5                	mov    %esp,%ebp
 8049eba:	56                   	push   %esi
 8049ebb:	83 ec 24             	sub    $0x24,%esp
 8049ebe:	e8 2b f2 ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 8049ec3:	81 c1 bd 62 00 00    	add    $0x62bd,%ecx
        getdents_args_t args;

        args.fd = fd;
 8049ec9:	8b 45 08             	mov    0x8(%ebp),%eax
 8049ecc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.dirp = dir;
 8049ecf:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049ed2:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.count = size;
 8049ed5:	8b 45 10             	mov    0x10(%ebp),%eax
 8049ed8:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_getdents, (uint32_t) &args);
 8049edb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8049ede:	c7 45 f8 17 00 00 00 	movl   $0x17,-0x8(%ebp)
 8049ee5:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049ee8:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049eeb:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8049eee:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049ef1:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049ef4:	cd 2e                	int    $0x2e
 8049ef6:	89 c6                	mov    %eax,%esi
 8049ef8:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049efb:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 8049f02:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049f05:	cd 2e                	int    $0x2e
 8049f07:	89 c2                	mov    %eax,%edx
 8049f09:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8049f0f:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049f11:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8049f14:	83 c4 24             	add    $0x24,%esp
 8049f17:	5e                   	pop    %esi
 8049f18:	5d                   	pop    %ebp
 8049f19:	c3                   	ret    

08049f1a <stat>:
}
#endif /* MOUNTING */

int
stat(const char *path, struct stat *buf)
{
 8049f1a:	55                   	push   %ebp
 8049f1b:	89 e5                	mov    %esp,%ebp
 8049f1d:	56                   	push   %esi
 8049f1e:	53                   	push   %ebx
 8049f1f:	83 ec 40             	sub    $0x40,%esp
 8049f22:	e8 fa e5 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 8049f27:	81 c3 59 62 00 00    	add    $0x6259,%ebx
        stat_args_t args;

        args.path.as_len = strlen(path);
 8049f2d:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f30:	89 04 24             	mov    %eax,(%esp)
 8049f33:	e8 39 e8 ff ff       	call   8048771 <strlen>
 8049f38:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.path.as_str = path;
 8049f3b:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f3e:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.buf = buf;
 8049f41:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049f44:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_stat, (uint32_t) &args);
 8049f47:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8049f4a:	c7 45 f4 2f 00 00 00 	movl   $0x2f,-0xc(%ebp)
 8049f51:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049f54:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049f57:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8049f5a:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8049f5d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049f60:	cd 2e                	int    $0x2e
 8049f62:	89 c6                	mov    %eax,%esi
 8049f64:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049f67:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8049f6e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049f71:	cd 2e                	int    $0x2e
 8049f73:	89 c2                	mov    %eax,%edx
 8049f75:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8049f7b:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049f7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8049f80:	83 c4 40             	add    $0x40,%esp
 8049f83:	5b                   	pop    %ebx
 8049f84:	5e                   	pop    %esi
 8049f85:	5d                   	pop    %ebp
 8049f86:	c3                   	ret    

08049f87 <uname>:

int
uname(struct utsname *buf)
{
 8049f87:	55                   	push   %ebp
 8049f88:	89 e5                	mov    %esp,%ebp
 8049f8a:	56                   	push   %esi
 8049f8b:	83 ec 14             	sub    $0x14,%esp
 8049f8e:	e8 5b f1 ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 8049f93:	81 c1 ed 61 00 00    	add    $0x61ed,%ecx
        return trap(SYS_uname, (uint32_t) buf);
 8049f99:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f9c:	c7 45 f8 1c 00 00 00 	movl   $0x1c,-0x8(%ebp)
 8049fa3:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049fa6:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049fa9:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8049fac:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049faf:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049fb2:	cd 2e                	int    $0x2e
 8049fb4:	89 c6                	mov    %eax,%esi
 8049fb6:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049fb9:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8049fc0:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049fc3:	cd 2e                	int    $0x2e
 8049fc5:	89 c2                	mov    %eax,%edx
 8049fc7:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8049fcd:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049fcf:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8049fd2:	83 c4 14             	add    $0x14,%esp
 8049fd5:	5e                   	pop    %esi
 8049fd6:	5d                   	pop    %ebp
 8049fd7:	c3                   	ret    

08049fd8 <debug>:

int
debug(const char *str)
{
 8049fd8:	55                   	push   %ebp
 8049fd9:	89 e5                	mov    %esp,%ebp
 8049fdb:	56                   	push   %esi
 8049fdc:	53                   	push   %ebx
 8049fdd:	83 ec 40             	sub    $0x40,%esp
 8049fe0:	e8 3c e5 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 8049fe5:	81 c3 9b 61 00 00    	add    $0x619b,%ebx
        argstr_t argstr;
        argstr.as_len = strlen(str);
 8049feb:	8b 45 08             	mov    0x8(%ebp),%eax
 8049fee:	89 04 24             	mov    %eax,(%esp)
 8049ff1:	e8 7b e7 ff ff       	call   8048771 <strlen>
 8049ff6:	89 45 e8             	mov    %eax,-0x18(%ebp)
        argstr.as_str = str;
 8049ff9:	8b 45 08             	mov    0x8(%ebp),%eax
 8049ffc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_debug, (uint32_t) &argstr);
 8049fff:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804a002:	c7 45 f4 29 23 00 00 	movl   $0x2329,-0xc(%ebp)
 804a009:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804a00c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a00f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804a012:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804a015:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804a018:	cd 2e                	int    $0x2e
 804a01a:	89 c6                	mov    %eax,%esi
 804a01c:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804a01f:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 804a026:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804a029:	cd 2e                	int    $0x2e
 804a02b:	89 c2                	mov    %eax,%edx
 804a02d:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 804a033:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804a035:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 804a038:	83 c4 40             	add    $0x40,%esp
 804a03b:	5b                   	pop    %ebx
 804a03c:	5e                   	pop    %esi
 804a03d:	5d                   	pop    %ebp
 804a03e:	c3                   	ret    
 804a03f:	90                   	nop

0804a040 <__tolower>:

#define isascii(c) (((unsigned char)(c))<=0x7f)
#define toascii(c) (((unsigned char)(c))&0x7f)

static inline unsigned char __tolower(unsigned char c)
{
 804a040:	55                   	push   %ebp
 804a041:	89 e5                	mov    %esp,%ebp
 804a043:	83 ec 04             	sub    $0x4,%esp
 804a046:	e8 a3 f0 ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 804a04b:	81 c1 35 61 00 00    	add    $0x6135,%ecx
 804a051:	8b 45 08             	mov    0x8(%ebp),%eax
 804a054:	88 45 fc             	mov    %al,-0x4(%ebp)
        if (isupper(c))
 804a057:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
 804a05b:	0f b6 84 01 60 00 00 	movzbl 0x60(%ecx,%eax,1),%eax
 804a062:	00 
 804a063:	0f b6 c0             	movzbl %al,%eax
 804a066:	83 e0 01             	and    $0x1,%eax
 804a069:	84 c0                	test   %al,%al
 804a06b:	74 04                	je     804a071 <__tolower+0x31>
                c -= 'A' - 'a';
 804a06d:	80 45 fc 20          	addb   $0x20,-0x4(%ebp)
        return c;
 804a071:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
}
 804a075:	c9                   	leave  
 804a076:	c3                   	ret    

0804a077 <__toupper>:

static inline unsigned char __toupper(unsigned char c)
{
 804a077:	55                   	push   %ebp
 804a078:	89 e5                	mov    %esp,%ebp
 804a07a:	83 ec 04             	sub    $0x4,%esp
 804a07d:	e8 6c f0 ff ff       	call   80490ee <__i686.get_pc_thunk.cx>
 804a082:	81 c1 fe 60 00 00    	add    $0x60fe,%ecx
 804a088:	8b 45 08             	mov    0x8(%ebp),%eax
 804a08b:	88 45 fc             	mov    %al,-0x4(%ebp)
        if (islower(c))
 804a08e:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
 804a092:	0f b6 84 01 60 00 00 	movzbl 0x60(%ecx,%eax,1),%eax
 804a099:	00 
 804a09a:	0f b6 c0             	movzbl %al,%eax
 804a09d:	83 e0 02             	and    $0x2,%eax
 804a0a0:	85 c0                	test   %eax,%eax
 804a0a2:	74 04                	je     804a0a8 <__toupper+0x31>
                c -= 'a' - 'A';
 804a0a4:	80 6d fc 20          	subb   $0x20,-0x4(%ebp)
        return c;
 804a0a8:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
}
 804a0ac:	c9                   	leave  
 804a0ad:	c3                   	ret    

0804a0ae <skip_atoi>:
#include "stddef.h"
#include "stdio.h"
#include "string.h"

static int skip_atoi(const char **s)
{
 804a0ae:	55                   	push   %ebp
 804a0af:	89 e5                	mov    %esp,%ebp
 804a0b1:	53                   	push   %ebx
 804a0b2:	83 ec 10             	sub    $0x10,%esp
 804a0b5:	e8 67 e4 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804a0ba:	81 c3 c6 60 00 00    	add    $0x60c6,%ebx
        int i = 0;
 804a0c0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

        while (isdigit(**s))
 804a0c7:	eb 29                	jmp    804a0f2 <skip_atoi+0x44>
                i = i * 10 + *((*s)++) - '0';
 804a0c9:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804a0cc:	89 d0                	mov    %edx,%eax
 804a0ce:	c1 e0 02             	shl    $0x2,%eax
 804a0d1:	01 d0                	add    %edx,%eax
 804a0d3:	01 c0                	add    %eax,%eax
 804a0d5:	89 c1                	mov    %eax,%ecx
 804a0d7:	8b 45 08             	mov    0x8(%ebp),%eax
 804a0da:	8b 00                	mov    (%eax),%eax
 804a0dc:	0f b6 10             	movzbl (%eax),%edx
 804a0df:	0f be d2             	movsbl %dl,%edx
 804a0e2:	01 ca                	add    %ecx,%edx
 804a0e4:	83 ea 30             	sub    $0x30,%edx
 804a0e7:	89 55 f8             	mov    %edx,-0x8(%ebp)
 804a0ea:	8d 50 01             	lea    0x1(%eax),%edx
 804a0ed:	8b 45 08             	mov    0x8(%ebp),%eax
 804a0f0:	89 10                	mov    %edx,(%eax)

static int skip_atoi(const char **s)
{
        int i = 0;

        while (isdigit(**s))
 804a0f2:	8b 45 08             	mov    0x8(%ebp),%eax
 804a0f5:	8b 00                	mov    (%eax),%eax
 804a0f7:	0f b6 00             	movzbl (%eax),%eax
 804a0fa:	0f b6 c0             	movzbl %al,%eax
 804a0fd:	0f b6 84 03 60 00 00 	movzbl 0x60(%ebx,%eax,1),%eax
 804a104:	00 
 804a105:	0f b6 c0             	movzbl %al,%eax
 804a108:	83 e0 04             	and    $0x4,%eax
 804a10b:	85 c0                	test   %eax,%eax
 804a10d:	75 ba                	jne    804a0c9 <skip_atoi+0x1b>
                i = i * 10 + *((*s)++) - '0';
        return i;
 804a10f:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
 804a112:	83 c4 10             	add    $0x10,%esp
 804a115:	5b                   	pop    %ebx
 804a116:	5d                   	pop    %ebp
 804a117:	c3                   	ret    

0804a118 <number>:
#define LEFT    16              /* left justified */
#define SPECIAL 32              /* 0x */
#define LARGE   64              /* use 'ABCDEF' instead of 'abcdef' */

static char *number(char *buf, char *end, long long num, int base, int size, int precision, int type)
{
 804a118:	55                   	push   %ebp
 804a119:	89 e5                	mov    %esp,%ebp
 804a11b:	57                   	push   %edi
 804a11c:	56                   	push   %esi
 804a11d:	53                   	push   %ebx
 804a11e:	81 ec dc 00 00 00    	sub    $0xdc,%esp
 804a124:	e8 f8 e3 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804a129:	81 c3 57 60 00 00    	add    $0x6057,%ebx
 804a12f:	8b 45 10             	mov    0x10(%ebp),%eax
 804a132:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
 804a138:	8b 45 14             	mov    0x14(%ebp),%eax
 804a13b:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
        char c, sign, tmp[66];
        const char *digits;
        const char small_digits[] = "0123456789abcdefghijklmnopqrstuvwxyz";
 804a141:	c7 85 65 ff ff ff 30 	movl   $0x33323130,-0x9b(%ebp)
 804a148:	31 32 33 
 804a14b:	c7 85 69 ff ff ff 34 	movl   $0x37363534,-0x97(%ebp)
 804a152:	35 36 37 
 804a155:	c7 85 6d ff ff ff 38 	movl   $0x62613938,-0x93(%ebp)
 804a15c:	39 61 62 
 804a15f:	c7 85 71 ff ff ff 63 	movl   $0x66656463,-0x8f(%ebp)
 804a166:	64 65 66 
 804a169:	c7 85 75 ff ff ff 67 	movl   $0x6a696867,-0x8b(%ebp)
 804a170:	68 69 6a 
 804a173:	c7 85 79 ff ff ff 6b 	movl   $0x6e6d6c6b,-0x87(%ebp)
 804a17a:	6c 6d 6e 
 804a17d:	c7 85 7d ff ff ff 6f 	movl   $0x7271706f,-0x83(%ebp)
 804a184:	70 71 72 
 804a187:	c7 45 81 73 74 75 76 	movl   $0x76757473,-0x7f(%ebp)
 804a18e:	c7 45 85 77 78 79 7a 	movl   $0x7a797877,-0x7b(%ebp)
 804a195:	c6 45 89 00          	movb   $0x0,-0x77(%ebp)
        const char large_digits[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 804a199:	c7 85 40 ff ff ff 30 	movl   $0x33323130,-0xc0(%ebp)
 804a1a0:	31 32 33 
 804a1a3:	c7 85 44 ff ff ff 34 	movl   $0x37363534,-0xbc(%ebp)
 804a1aa:	35 36 37 
 804a1ad:	c7 85 48 ff ff ff 38 	movl   $0x42413938,-0xb8(%ebp)
 804a1b4:	39 41 42 
 804a1b7:	c7 85 4c ff ff ff 43 	movl   $0x46454443,-0xb4(%ebp)
 804a1be:	44 45 46 
 804a1c1:	c7 85 50 ff ff ff 47 	movl   $0x4a494847,-0xb0(%ebp)
 804a1c8:	48 49 4a 
 804a1cb:	c7 85 54 ff ff ff 4b 	movl   $0x4e4d4c4b,-0xac(%ebp)
 804a1d2:	4c 4d 4e 
 804a1d5:	c7 85 58 ff ff ff 4f 	movl   $0x5251504f,-0xa8(%ebp)
 804a1dc:	50 51 52 
 804a1df:	c7 85 5c ff ff ff 53 	movl   $0x56555453,-0xa4(%ebp)
 804a1e6:	54 55 56 
 804a1e9:	c7 85 60 ff ff ff 57 	movl   $0x5a595857,-0xa0(%ebp)
 804a1f0:	58 59 5a 
 804a1f3:	c6 85 64 ff ff ff 00 	movb   $0x0,-0x9c(%ebp)
        int i;

        digits = (type & LARGE) ? large_digits : small_digits;
 804a1fa:	8b 45 24             	mov    0x24(%ebp),%eax
 804a1fd:	83 e0 40             	and    $0x40,%eax
 804a200:	85 c0                	test   %eax,%eax
 804a202:	74 08                	je     804a20c <number+0xf4>
 804a204:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
 804a20a:	eb 06                	jmp    804a212 <number+0xfa>
 804a20c:	8d 85 65 ff ff ff    	lea    -0x9b(%ebp),%eax
 804a212:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        if (type & LEFT)
 804a215:	8b 45 24             	mov    0x24(%ebp),%eax
 804a218:	83 e0 10             	and    $0x10,%eax
 804a21b:	85 c0                	test   %eax,%eax
 804a21d:	74 04                	je     804a223 <number+0x10b>
                type &= ~ZEROPAD;
 804a21f:	83 65 24 fe          	andl   $0xfffffffe,0x24(%ebp)
        if (base < 2 || base > 36)
 804a223:	83 7d 18 01          	cmpl   $0x1,0x18(%ebp)
 804a227:	7e 06                	jle    804a22f <number+0x117>
 804a229:	83 7d 18 24          	cmpl   $0x24,0x18(%ebp)
 804a22d:	7e 08                	jle    804a237 <number+0x11f>
                return buf;
 804a22f:	8b 45 08             	mov    0x8(%ebp),%eax
 804a232:	e9 99 02 00 00       	jmp    804a4d0 <number+0x3b8>
        c = (type & ZEROPAD) ? '0' : ' ';
 804a237:	8b 45 24             	mov    0x24(%ebp),%eax
 804a23a:	83 e0 01             	and    $0x1,%eax
 804a23d:	84 c0                	test   %al,%al
 804a23f:	74 07                	je     804a248 <number+0x130>
 804a241:	b8 30 00 00 00       	mov    $0x30,%eax
 804a246:	eb 05                	jmp    804a24d <number+0x135>
 804a248:	b8 20 00 00 00       	mov    $0x20,%eax
 804a24d:	88 45 d3             	mov    %al,-0x2d(%ebp)
        sign = 0;
 804a250:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
        if (type & SIGN) {
 804a254:	8b 45 24             	mov    0x24(%ebp),%eax
 804a257:	83 e0 02             	and    $0x2,%eax
 804a25a:	85 c0                	test   %eax,%eax
 804a25c:	74 4c                	je     804a2aa <number+0x192>
                if (num < 0) {
 804a25e:	83 bd 34 ff ff ff 00 	cmpl   $0x0,-0xcc(%ebp)
 804a265:	79 1d                	jns    804a284 <number+0x16c>
                        sign = '-';
 804a267:	c6 45 e7 2d          	movb   $0x2d,-0x19(%ebp)
                        num = -num;
 804a26b:	f7 9d 30 ff ff ff    	negl   -0xd0(%ebp)
 804a271:	83 95 34 ff ff ff 00 	adcl   $0x0,-0xcc(%ebp)
 804a278:	f7 9d 34 ff ff ff    	negl   -0xcc(%ebp)
                        size--;
 804a27e:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
 804a282:	eb 26                	jmp    804a2aa <number+0x192>
                } else if (type & PLUS) {
 804a284:	8b 45 24             	mov    0x24(%ebp),%eax
 804a287:	83 e0 04             	and    $0x4,%eax
 804a28a:	85 c0                	test   %eax,%eax
 804a28c:	74 0a                	je     804a298 <number+0x180>
                        sign = '+';
 804a28e:	c6 45 e7 2b          	movb   $0x2b,-0x19(%ebp)
                        size--;
 804a292:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
 804a296:	eb 12                	jmp    804a2aa <number+0x192>
                } else if (type & SPACE) {
 804a298:	8b 45 24             	mov    0x24(%ebp),%eax
 804a29b:	83 e0 08             	and    $0x8,%eax
 804a29e:	85 c0                	test   %eax,%eax
 804a2a0:	74 08                	je     804a2aa <number+0x192>
                        sign = ' ';
 804a2a2:	c6 45 e7 20          	movb   $0x20,-0x19(%ebp)
                        size--;
 804a2a6:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
                }
        }
        if (type & SPECIAL) {
 804a2aa:	8b 45 24             	mov    0x24(%ebp),%eax
 804a2ad:	83 e0 20             	and    $0x20,%eax
 804a2b0:	85 c0                	test   %eax,%eax
 804a2b2:	74 16                	je     804a2ca <number+0x1b2>
                if (base == 16)
 804a2b4:	83 7d 18 10          	cmpl   $0x10,0x18(%ebp)
 804a2b8:	75 06                	jne    804a2c0 <number+0x1a8>
                        size -= 2;
 804a2ba:	83 6d 1c 02          	subl   $0x2,0x1c(%ebp)
 804a2be:	eb 0a                	jmp    804a2ca <number+0x1b2>
                else if (base == 8)
 804a2c0:	83 7d 18 08          	cmpl   $0x8,0x18(%ebp)
 804a2c4:	75 04                	jne    804a2ca <number+0x1b2>
                        size--;
 804a2c6:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
        }
        i = 0;
 804a2ca:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
        if (num == 0) {
 804a2d1:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
 804a2d7:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
 804a2dd:	09 d0                	or     %edx,%eax
 804a2df:	85 c0                	test   %eax,%eax
 804a2e1:	75 12                	jne    804a2f5 <number+0x1dd>
                tmp[i++] = '0';
 804a2e3:	8d 45 8a             	lea    -0x76(%ebp),%eax
 804a2e6:	03 45 e0             	add    -0x20(%ebp),%eax
 804a2e9:	c6 00 30             	movb   $0x30,(%eax)
 804a2ec:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
 804a2f0:	e9 82 00 00 00       	jmp    804a377 <number+0x25f>
        } else {
                /* XXX KAF: force unsigned mod and div. */
                /* XXX kernel does not support long long division */
                unsigned long long num2 = (unsigned long long)num;
 804a2f5:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
 804a2fb:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
 804a301:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804a304:	89 55 dc             	mov    %edx,-0x24(%ebp)
                unsigned int base2 = (unsigned int)base;
 804a307:	8b 45 18             	mov    0x18(%ebp),%eax
 804a30a:	89 45 cc             	mov    %eax,-0x34(%ebp)
                while (num2 != 0) {
 804a30d:	eb 5c                	jmp    804a36b <number+0x253>
                        tmp[i++] = digits[num2 % base2];
 804a30f:	8b 75 cc             	mov    -0x34(%ebp),%esi
 804a312:	bf 00 00 00 00       	mov    $0x0,%edi
 804a317:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a31a:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804a31d:	89 74 24 08          	mov    %esi,0x8(%esp)
 804a321:	89 7c 24 0c          	mov    %edi,0xc(%esp)
 804a325:	89 04 24             	mov    %eax,(%esp)
 804a328:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a32c:	e8 1d 33 00 00       	call   804d64e <__umoddi3>
 804a331:	03 45 d4             	add    -0x2c(%ebp),%eax
 804a334:	0f b6 10             	movzbl (%eax),%edx
 804a337:	8d 45 8a             	lea    -0x76(%ebp),%eax
 804a33a:	03 45 e0             	add    -0x20(%ebp),%eax
 804a33d:	88 10                	mov    %dl,(%eax)
 804a33f:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
                        num2 /= base2;
 804a343:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804a346:	ba 00 00 00 00       	mov    $0x0,%edx
 804a34b:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a34f:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804a353:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a356:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804a359:	89 04 24             	mov    %eax,(%esp)
 804a35c:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a360:	e8 91 32 00 00       	call   804d5f6 <__udivdi3>
 804a365:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804a368:	89 55 dc             	mov    %edx,-0x24(%ebp)
        } else {
                /* XXX KAF: force unsigned mod and div. */
                /* XXX kernel does not support long long division */
                unsigned long long num2 = (unsigned long long)num;
                unsigned int base2 = (unsigned int)base;
                while (num2 != 0) {
 804a36b:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a36e:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804a371:	09 d0                	or     %edx,%eax
 804a373:	85 c0                	test   %eax,%eax
 804a375:	75 98                	jne    804a30f <number+0x1f7>
                        tmp[i++] = digits[num2 % base2];
                        num2 /= base2;
                }
        }
        if (i > precision)
 804a377:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a37a:	3b 45 20             	cmp    0x20(%ebp),%eax
 804a37d:	7e 06                	jle    804a385 <number+0x26d>
                precision = i;
 804a37f:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a382:	89 45 20             	mov    %eax,0x20(%ebp)
        size -= precision;
 804a385:	8b 45 20             	mov    0x20(%ebp),%eax
 804a388:	29 45 1c             	sub    %eax,0x1c(%ebp)
        if (!(type & (ZEROPAD + LEFT))) {
 804a38b:	8b 45 24             	mov    0x24(%ebp),%eax
 804a38e:	83 e0 11             	and    $0x11,%eax
 804a391:	85 c0                	test   %eax,%eax
 804a393:	75 23                	jne    804a3b8 <number+0x2a0>
                while (size-- > 0) {
 804a395:	eb 12                	jmp    804a3a9 <number+0x291>
                        if (buf <= end)
 804a397:	8b 45 08             	mov    0x8(%ebp),%eax
 804a39a:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a39d:	77 06                	ja     804a3a5 <number+0x28d>
                                *buf = ' ';
 804a39f:	8b 45 08             	mov    0x8(%ebp),%eax
 804a3a2:	c6 00 20             	movb   $0x20,(%eax)
                        ++buf;
 804a3a5:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        }
        if (i > precision)
                precision = i;
        size -= precision;
        if (!(type & (ZEROPAD + LEFT))) {
                while (size-- > 0) {
 804a3a9:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
 804a3ad:	0f 9f c0             	setg   %al
 804a3b0:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
 804a3b4:	84 c0                	test   %al,%al
 804a3b6:	75 df                	jne    804a397 <number+0x27f>
                        if (buf <= end)
                                *buf = ' ';
                        ++buf;
                }
        }
        if (sign) {
 804a3b8:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
 804a3bc:	74 15                	je     804a3d3 <number+0x2bb>
                if (buf <= end)
 804a3be:	8b 45 08             	mov    0x8(%ebp),%eax
 804a3c1:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a3c4:	77 09                	ja     804a3cf <number+0x2b7>
                        *buf = sign;
 804a3c6:	8b 45 08             	mov    0x8(%ebp),%eax
 804a3c9:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
 804a3cd:	88 10                	mov    %dl,(%eax)
                ++buf;
 804a3cf:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        }
        if (type & SPECIAL) {
 804a3d3:	8b 45 24             	mov    0x24(%ebp),%eax
 804a3d6:	83 e0 20             	and    $0x20,%eax
 804a3d9:	85 c0                	test   %eax,%eax
 804a3db:	74 4a                	je     804a427 <number+0x30f>
                if (base == 8) {
 804a3dd:	83 7d 18 08          	cmpl   $0x8,0x18(%ebp)
 804a3e1:	75 14                	jne    804a3f7 <number+0x2df>
                        if (buf <= end)
 804a3e3:	8b 45 08             	mov    0x8(%ebp),%eax
 804a3e6:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a3e9:	77 06                	ja     804a3f1 <number+0x2d9>
                                *buf = '0';
 804a3eb:	8b 45 08             	mov    0x8(%ebp),%eax
 804a3ee:	c6 00 30             	movb   $0x30,(%eax)
                        ++buf;
 804a3f1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804a3f5:	eb 30                	jmp    804a427 <number+0x30f>
                } else if (base == 16) {
 804a3f7:	83 7d 18 10          	cmpl   $0x10,0x18(%ebp)
 804a3fb:	75 2a                	jne    804a427 <number+0x30f>
                        if (buf <= end)
 804a3fd:	8b 45 08             	mov    0x8(%ebp),%eax
 804a400:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a403:	77 06                	ja     804a40b <number+0x2f3>
                                *buf = '0';
 804a405:	8b 45 08             	mov    0x8(%ebp),%eax
 804a408:	c6 00 30             	movb   $0x30,(%eax)
                        ++buf;
 804a40b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
                        if (buf <= end)
 804a40f:	8b 45 08             	mov    0x8(%ebp),%eax
 804a412:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a415:	77 0c                	ja     804a423 <number+0x30b>
                                *buf = digits[33];
 804a417:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804a41a:	0f b6 50 21          	movzbl 0x21(%eax),%edx
 804a41e:	8b 45 08             	mov    0x8(%ebp),%eax
 804a421:	88 10                	mov    %dl,(%eax)
                        ++buf;
 804a423:	83 45 08 01          	addl   $0x1,0x8(%ebp)
                }
        }
        if (!(type & LEFT)) {
 804a427:	8b 45 24             	mov    0x24(%ebp),%eax
 804a42a:	83 e0 10             	and    $0x10,%eax
 804a42d:	85 c0                	test   %eax,%eax
 804a42f:	75 3c                	jne    804a46d <number+0x355>
                while (size-- > 0) {
 804a431:	eb 15                	jmp    804a448 <number+0x330>
                        if (buf <= end)
 804a433:	8b 45 08             	mov    0x8(%ebp),%eax
 804a436:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a439:	77 09                	ja     804a444 <number+0x32c>
                                *buf = c;
 804a43b:	8b 45 08             	mov    0x8(%ebp),%eax
 804a43e:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
 804a442:	88 10                	mov    %dl,(%eax)
                        ++buf;
 804a444:	83 45 08 01          	addl   $0x1,0x8(%ebp)
                                *buf = digits[33];
                        ++buf;
                }
        }
        if (!(type & LEFT)) {
                while (size-- > 0) {
 804a448:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
 804a44c:	0f 9f c0             	setg   %al
 804a44f:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
 804a453:	84 c0                	test   %al,%al
 804a455:	75 dc                	jne    804a433 <number+0x31b>
                        if (buf <= end)
                                *buf = c;
                        ++buf;
                }
        }
        while (i < precision--) {
 804a457:	eb 14                	jmp    804a46d <number+0x355>
                if (buf <= end)
 804a459:	8b 45 08             	mov    0x8(%ebp),%eax
 804a45c:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a45f:	77 06                	ja     804a467 <number+0x34f>
                        *buf = '0';
 804a461:	8b 45 08             	mov    0x8(%ebp),%eax
 804a464:	c6 00 30             	movb   $0x30,(%eax)
                ++buf;
 804a467:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804a46b:	eb 01                	jmp    804a46e <number+0x356>
                        if (buf <= end)
                                *buf = c;
                        ++buf;
                }
        }
        while (i < precision--) {
 804a46d:	90                   	nop
 804a46e:	8b 45 20             	mov    0x20(%ebp),%eax
 804a471:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804a474:	0f 9f c0             	setg   %al
 804a477:	83 6d 20 01          	subl   $0x1,0x20(%ebp)
 804a47b:	84 c0                	test   %al,%al
 804a47d:	75 da                	jne    804a459 <number+0x341>
                if (buf <= end)
                        *buf = '0';
                ++buf;
        }
        while (i-- > 0) {
 804a47f:	eb 1a                	jmp    804a49b <number+0x383>
                if (buf <= end)
 804a481:	8b 45 08             	mov    0x8(%ebp),%eax
 804a484:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a487:	77 0e                	ja     804a497 <number+0x37f>
                        *buf = tmp[i];
 804a489:	8d 45 8a             	lea    -0x76(%ebp),%eax
 804a48c:	03 45 e0             	add    -0x20(%ebp),%eax
 804a48f:	0f b6 10             	movzbl (%eax),%edx
 804a492:	8b 45 08             	mov    0x8(%ebp),%eax
 804a495:	88 10                	mov    %dl,(%eax)
                ++buf;
 804a497:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        while (i < precision--) {
                if (buf <= end)
                        *buf = '0';
                ++buf;
        }
        while (i-- > 0) {
 804a49b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
 804a49f:	0f 9f c0             	setg   %al
 804a4a2:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
 804a4a6:	84 c0                	test   %al,%al
 804a4a8:	75 d7                	jne    804a481 <number+0x369>
                if (buf <= end)
                        *buf = tmp[i];
                ++buf;
        }
        while (size-- > 0) {
 804a4aa:	eb 12                	jmp    804a4be <number+0x3a6>
                if (buf <= end)
 804a4ac:	8b 45 08             	mov    0x8(%ebp),%eax
 804a4af:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a4b2:	77 06                	ja     804a4ba <number+0x3a2>
                        *buf = ' ';
 804a4b4:	8b 45 08             	mov    0x8(%ebp),%eax
 804a4b7:	c6 00 20             	movb   $0x20,(%eax)
                ++buf;
 804a4ba:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        while (i-- > 0) {
                if (buf <= end)
                        *buf = tmp[i];
                ++buf;
        }
        while (size-- > 0) {
 804a4be:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
 804a4c2:	0f 9f c0             	setg   %al
 804a4c5:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
 804a4c9:	84 c0                	test   %al,%al
 804a4cb:	75 df                	jne    804a4ac <number+0x394>
                if (buf <= end)
                        *buf = ' ';
                ++buf;
        }
        return buf;
 804a4cd:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804a4d0:	81 c4 dc 00 00 00    	add    $0xdc,%esp
 804a4d6:	5b                   	pop    %ebx
 804a4d7:	5e                   	pop    %esi
 804a4d8:	5f                   	pop    %edi
 804a4d9:	5d                   	pop    %ebp
 804a4da:	c3                   	ret    

0804a4db <vsnprintf>:
*
* Call this function if you are already dealing with a va_list.
* You probably want snprintf instead.
 */
int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
{
 804a4db:	55                   	push   %ebp
 804a4dc:	89 e5                	mov    %esp,%ebp
 804a4de:	53                   	push   %ebx
 804a4df:	83 ec 64             	sub    $0x64,%esp
 804a4e2:	e8 3a e0 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804a4e7:	81 c3 99 5c 00 00    	add    $0x5c99,%ebx
                                   number of chars for from string */
        int qualifier;              /* 'h', 'l', or 'L' for integer fields */
        /* 'z' support added 23/7/1999 S.H.    */
        /* 'z' changed to 'Z' --davidm 1/25/99 */

        str = buf;
 804a4ed:	8b 45 08             	mov    0x8(%ebp),%eax
 804a4f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        end = buf + size - 1;
 804a4f3:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a4f6:	83 e8 01             	sub    $0x1,%eax
 804a4f9:	03 45 08             	add    0x8(%ebp),%eax
 804a4fc:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if (end < buf - 1) {
 804a4ff:	8b 45 08             	mov    0x8(%ebp),%eax
 804a502:	83 e8 01             	sub    $0x1,%eax
 804a505:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804a508:	0f 86 65 07 00 00    	jbe    804ac73 <vsnprintf+0x798>
                end = ((void *) - 1);
 804a50e:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
                size = end - buf + 1;
 804a515:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804a518:	8b 45 08             	mov    0x8(%ebp),%eax
 804a51b:	89 d1                	mov    %edx,%ecx
 804a51d:	29 c1                	sub    %eax,%ecx
 804a51f:	89 c8                	mov    %ecx,%eax
 804a521:	83 c0 01             	add    $0x1,%eax
 804a524:	89 45 0c             	mov    %eax,0xc(%ebp)
        }

        for (; *fmt ; ++fmt) {
 804a527:	e9 47 07 00 00       	jmp    804ac73 <vsnprintf+0x798>
                if (*fmt != '%') {
 804a52c:	8b 45 10             	mov    0x10(%ebp),%eax
 804a52f:	0f b6 00             	movzbl (%eax),%eax
 804a532:	3c 25                	cmp    $0x25,%al
 804a534:	74 1c                	je     804a552 <vsnprintf+0x77>
                        if (str <= end)
 804a536:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a539:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804a53c:	77 0b                	ja     804a549 <vsnprintf+0x6e>
                                *str = *fmt;
 804a53e:	8b 45 10             	mov    0x10(%ebp),%eax
 804a541:	0f b6 10             	movzbl (%eax),%edx
 804a544:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a547:	88 10                	mov    %dl,(%eax)
                        ++str;
 804a549:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                        continue;
 804a54d:	e9 16 07 00 00       	jmp    804ac68 <vsnprintf+0x78d>
                }

                /* process flags */
                flags = 0;
 804a552:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
repeat:
                ++fmt;          /* this also skips first '%' */
 804a559:	8b 45 10             	mov    0x10(%ebp),%eax
 804a55c:	83 c0 01             	add    $0x1,%eax
 804a55f:	89 45 10             	mov    %eax,0x10(%ebp)
                switch (*fmt) {
 804a562:	8b 45 10             	mov    0x10(%ebp),%eax
 804a565:	0f b6 00             	movzbl (%eax),%eax
 804a568:	0f be c0             	movsbl %al,%eax
 804a56b:	83 e8 20             	sub    $0x20,%eax
 804a56e:	83 f8 10             	cmp    $0x10,%eax
 804a571:	0f 87 83 00 00 00    	ja     804a5fa <vsnprintf+0x11f>
 804a577:	c1 e0 02             	shl    $0x2,%eax
 804a57a:	8b 84 18 0c a4 ff ff 	mov    -0x5bf4(%eax,%ebx,1),%eax
 804a581:	89 da                	mov    %ebx,%edx
 804a583:	29 c2                	sub    %eax,%edx
 804a585:	89 d0                	mov    %edx,%eax
 804a587:	ff e0                	jmp    *%eax
 804a589:	8d 76 00             	lea    0x0(%esi),%esi
 804a58c:	a1 5b 00 00 86       	mov    0x8600005b,%eax
 804a591:	5b                   	pop    %ebx
 804a592:	00 00                	add    %al,(%eax)
 804a594:	86 5b 00             	xchg   %bl,0x0(%ebx)
 804a597:	00 98 5b 00 00 86    	add    %bl,-0x79ffffa5(%eax)
 804a59d:	5b                   	pop    %ebx
 804a59e:	00 00                	add    %al,(%eax)
 804a5a0:	86 5b 00             	xchg   %bl,0x0(%ebx)
 804a5a3:	00 86 5b 00 00 86    	add    %al,-0x79ffffa5(%esi)
 804a5a9:	5b                   	pop    %ebx
 804a5aa:	00 00                	add    %al,(%eax)
 804a5ac:	86 5b 00             	xchg   %bl,0x0(%ebx)
 804a5af:	00 86 5b 00 00 86    	add    %al,-0x79ffffa5(%esi)
 804a5b5:	5b                   	pop    %ebx
 804a5b6:	00 00                	add    %al,(%eax)
 804a5b8:	aa                   	stos   %al,%es:(%edi)
 804a5b9:	5b                   	pop    %ebx
 804a5ba:	00 00                	add    %al,(%eax)
 804a5bc:	86 5b 00             	xchg   %bl,0x0(%ebx)
 804a5bf:	00 b0 5b 00 00 86    	add    %dh,-0x79ffffa5(%eax)
 804a5c5:	5b                   	pop    %ebx
 804a5c6:	00 00                	add    %al,(%eax)
 804a5c8:	86 5b 00             	xchg   %bl,0x0(%ebx)
 804a5cb:	00 8f 5b 00 00 83    	add    %cl,-0x7cffffa5(%edi)
                        case '-': flags |= LEFT; goto repeat;
 804a5d1:	4d                   	dec    %ebp
 804a5d2:	d8 10                	fcoms  (%eax)
 804a5d4:	eb 83                	jmp    804a559 <vsnprintf+0x7e>
                        case '+': flags |= PLUS; goto repeat;
 804a5d6:	83 4d d8 04          	orl    $0x4,-0x28(%ebp)
 804a5da:	e9 7a ff ff ff       	jmp    804a559 <vsnprintf+0x7e>
                        case ' ': flags |= SPACE; goto repeat;
 804a5df:	83 4d d8 08          	orl    $0x8,-0x28(%ebp)
 804a5e3:	e9 71 ff ff ff       	jmp    804a559 <vsnprintf+0x7e>
                        case '#': flags |= SPECIAL; goto repeat;
 804a5e8:	83 4d d8 20          	orl    $0x20,-0x28(%ebp)
 804a5ec:	e9 68 ff ff ff       	jmp    804a559 <vsnprintf+0x7e>
                        case '0': flags |= ZEROPAD; goto repeat;
 804a5f1:	83 4d d8 01          	orl    $0x1,-0x28(%ebp)
 804a5f5:	e9 5f ff ff ff       	jmp    804a559 <vsnprintf+0x7e>
                }

                /* get field width */
                field_width = -1;
 804a5fa:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%ebp)
                if (isdigit(*fmt))
 804a601:	8b 45 10             	mov    0x10(%ebp),%eax
 804a604:	0f b6 00             	movzbl (%eax),%eax
 804a607:	0f b6 c0             	movzbl %al,%eax
 804a60a:	0f b6 84 03 60 00 00 	movzbl 0x60(%ebx,%eax,1),%eax
 804a611:	00 
 804a612:	0f b6 c0             	movzbl %al,%eax
 804a615:	83 e0 04             	and    $0x4,%eax
 804a618:	85 c0                	test   %eax,%eax
 804a61a:	74 10                	je     804a62c <vsnprintf+0x151>
                        field_width = skip_atoi(&fmt);
 804a61c:	8d 45 10             	lea    0x10(%ebp),%eax
 804a61f:	89 04 24             	mov    %eax,(%esp)
 804a622:	e8 87 fa ff ff       	call   804a0ae <skip_atoi>
 804a627:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804a62a:	eb 2e                	jmp    804a65a <vsnprintf+0x17f>
                else if (*fmt == '*') {
 804a62c:	8b 45 10             	mov    0x10(%ebp),%eax
 804a62f:	0f b6 00             	movzbl (%eax),%eax
 804a632:	3c 2a                	cmp    $0x2a,%al
 804a634:	75 24                	jne    804a65a <vsnprintf+0x17f>
                        ++fmt;
 804a636:	8b 45 10             	mov    0x10(%ebp),%eax
 804a639:	83 c0 01             	add    $0x1,%eax
 804a63c:	89 45 10             	mov    %eax,0x10(%ebp)
                        /* it's the next argument */
                        field_width = va_arg(args, int);
 804a63f:	8b 45 14             	mov    0x14(%ebp),%eax
 804a642:	8d 50 04             	lea    0x4(%eax),%edx
 804a645:	89 55 14             	mov    %edx,0x14(%ebp)
 804a648:	8b 00                	mov    (%eax),%eax
 804a64a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
                        if (field_width < 0) {
 804a64d:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804a651:	79 07                	jns    804a65a <vsnprintf+0x17f>
                                field_width = -field_width;
 804a653:	f7 5d d4             	negl   -0x2c(%ebp)
                                flags |= LEFT;
 804a656:	83 4d d8 10          	orl    $0x10,-0x28(%ebp)
                        }
                }

                /* get the precision */
                precision = -1;
 804a65a:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
                if (*fmt == '.') {
 804a661:	8b 45 10             	mov    0x10(%ebp),%eax
 804a664:	0f b6 00             	movzbl (%eax),%eax
 804a667:	3c 2e                	cmp    $0x2e,%al
 804a669:	75 62                	jne    804a6cd <vsnprintf+0x1f2>
                        ++fmt;
 804a66b:	8b 45 10             	mov    0x10(%ebp),%eax
 804a66e:	83 c0 01             	add    $0x1,%eax
 804a671:	89 45 10             	mov    %eax,0x10(%ebp)
                        if (isdigit(*fmt))
 804a674:	8b 45 10             	mov    0x10(%ebp),%eax
 804a677:	0f b6 00             	movzbl (%eax),%eax
 804a67a:	0f b6 c0             	movzbl %al,%eax
 804a67d:	0f b6 84 03 60 00 00 	movzbl 0x60(%ebx,%eax,1),%eax
 804a684:	00 
 804a685:	0f b6 c0             	movzbl %al,%eax
 804a688:	83 e0 04             	and    $0x4,%eax
 804a68b:	85 c0                	test   %eax,%eax
 804a68d:	74 10                	je     804a69f <vsnprintf+0x1c4>
                                precision = skip_atoi(&fmt);
 804a68f:	8d 45 10             	lea    0x10(%ebp),%eax
 804a692:	89 04 24             	mov    %eax,(%esp)
 804a695:	e8 14 fa ff ff       	call   804a0ae <skip_atoi>
 804a69a:	89 45 d0             	mov    %eax,-0x30(%ebp)
 804a69d:	eb 21                	jmp    804a6c0 <vsnprintf+0x1e5>
                        else if (*fmt == '*') {
 804a69f:	8b 45 10             	mov    0x10(%ebp),%eax
 804a6a2:	0f b6 00             	movzbl (%eax),%eax
 804a6a5:	3c 2a                	cmp    $0x2a,%al
 804a6a7:	75 17                	jne    804a6c0 <vsnprintf+0x1e5>
                                ++fmt;
 804a6a9:	8b 45 10             	mov    0x10(%ebp),%eax
 804a6ac:	83 c0 01             	add    $0x1,%eax
 804a6af:	89 45 10             	mov    %eax,0x10(%ebp)
                                /* it's the next argument */
                                precision = va_arg(args, int);
 804a6b2:	8b 45 14             	mov    0x14(%ebp),%eax
 804a6b5:	8d 50 04             	lea    0x4(%eax),%edx
 804a6b8:	89 55 14             	mov    %edx,0x14(%ebp)
 804a6bb:	8b 00                	mov    (%eax),%eax
 804a6bd:	89 45 d0             	mov    %eax,-0x30(%ebp)
                        }
                        if (precision < 0)
 804a6c0:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804a6c4:	79 07                	jns    804a6cd <vsnprintf+0x1f2>
                                precision = 0;
 804a6c6:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
                }

                /* get the conversion qualifier */
                qualifier = -1;
 804a6cd:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,-0x34(%ebp)
                if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt == 'Z') {
 804a6d4:	8b 45 10             	mov    0x10(%ebp),%eax
 804a6d7:	0f b6 00             	movzbl (%eax),%eax
 804a6da:	3c 68                	cmp    $0x68,%al
 804a6dc:	74 1e                	je     804a6fc <vsnprintf+0x221>
 804a6de:	8b 45 10             	mov    0x10(%ebp),%eax
 804a6e1:	0f b6 00             	movzbl (%eax),%eax
 804a6e4:	3c 6c                	cmp    $0x6c,%al
 804a6e6:	74 14                	je     804a6fc <vsnprintf+0x221>
 804a6e8:	8b 45 10             	mov    0x10(%ebp),%eax
 804a6eb:	0f b6 00             	movzbl (%eax),%eax
 804a6ee:	3c 4c                	cmp    $0x4c,%al
 804a6f0:	74 0a                	je     804a6fc <vsnprintf+0x221>
 804a6f2:	8b 45 10             	mov    0x10(%ebp),%eax
 804a6f5:	0f b6 00             	movzbl (%eax),%eax
 804a6f8:	3c 5a                	cmp    $0x5a,%al
 804a6fa:	75 35                	jne    804a731 <vsnprintf+0x256>
                        qualifier = *fmt;
 804a6fc:	8b 45 10             	mov    0x10(%ebp),%eax
 804a6ff:	0f b6 00             	movzbl (%eax),%eax
 804a702:	0f be c0             	movsbl %al,%eax
 804a705:	89 45 cc             	mov    %eax,-0x34(%ebp)
                        ++fmt;
 804a708:	8b 45 10             	mov    0x10(%ebp),%eax
 804a70b:	83 c0 01             	add    $0x1,%eax
 804a70e:	89 45 10             	mov    %eax,0x10(%ebp)
                        if (qualifier == 'l' && *fmt == 'l') {
 804a711:	83 7d cc 6c          	cmpl   $0x6c,-0x34(%ebp)
 804a715:	75 1a                	jne    804a731 <vsnprintf+0x256>
 804a717:	8b 45 10             	mov    0x10(%ebp),%eax
 804a71a:	0f b6 00             	movzbl (%eax),%eax
 804a71d:	3c 6c                	cmp    $0x6c,%al
 804a71f:	75 10                	jne    804a731 <vsnprintf+0x256>
                                qualifier = 'L';
 804a721:	c7 45 cc 4c 00 00 00 	movl   $0x4c,-0x34(%ebp)
                                ++fmt;
 804a728:	8b 45 10             	mov    0x10(%ebp),%eax
 804a72b:	83 c0 01             	add    $0x1,%eax
 804a72e:	89 45 10             	mov    %eax,0x10(%ebp)
                        }
                }
                if (*fmt == 'q') {
 804a731:	8b 45 10             	mov    0x10(%ebp),%eax
 804a734:	0f b6 00             	movzbl (%eax),%eax
 804a737:	3c 71                	cmp    $0x71,%al
 804a739:	75 10                	jne    804a74b <vsnprintf+0x270>
                        qualifier = 'L';
 804a73b:	c7 45 cc 4c 00 00 00 	movl   $0x4c,-0x34(%ebp)
                        ++fmt;
 804a742:	8b 45 10             	mov    0x10(%ebp),%eax
 804a745:	83 c0 01             	add    $0x1,%eax
 804a748:	89 45 10             	mov    %eax,0x10(%ebp)
                }

                /* default base */
                base = 10;
 804a74b:	c7 45 e8 0a 00 00 00 	movl   $0xa,-0x18(%ebp)

                switch (*fmt) {
 804a752:	8b 45 10             	mov    0x10(%ebp),%eax
 804a755:	0f b6 00             	movzbl (%eax),%eax
 804a758:	0f be c0             	movsbl %al,%eax
 804a75b:	83 e8 25             	sub    $0x25,%eax
 804a75e:	83 f8 53             	cmp    $0x53,%eax
 804a761:	0f 87 9d 03 00 00    	ja     804ab04 <vsnprintf+0x629>
 804a767:	c1 e0 02             	shl    $0x2,%eax
 804a76a:	8b 84 18 fc a5 ff ff 	mov    -0x5a04(%eax,%ebx,1),%eax
 804a771:	89 d9                	mov    %ebx,%ecx
 804a773:	29 c1                	sub    %eax,%ecx
 804a775:	89 c8                	mov    %ecx,%eax
 804a777:	ff e0                	jmp    *%eax
 804a779:	8d 76 00             	lea    0x0(%esi),%esi
 804a77c:	b9 56 00 00 7c       	mov    $0x7c000056,%ecx
 804a781:	56                   	push   %esi
 804a782:	00 00                	add    %al,(%eax)
 804a784:	7c 56                	jl     804a7dc <vsnprintf+0x301>
 804a786:	00 00                	add    %al,(%eax)
 804a788:	7c 56                	jl     804a7e0 <vsnprintf+0x305>
 804a78a:	00 00                	add    %al,(%eax)
 804a78c:	7c 56                	jl     804a7e4 <vsnprintf+0x309>
 804a78e:	00 00                	add    %al,(%eax)
 804a790:	7c 56                	jl     804a7e8 <vsnprintf+0x30d>
 804a792:	00 00                	add    %al,(%eax)
 804a794:	7c 56                	jl     804a7ec <vsnprintf+0x311>
 804a796:	00 00                	add    %al,(%eax)
 804a798:	7c 56                	jl     804a7f0 <vsnprintf+0x315>
 804a79a:	00 00                	add    %al,(%eax)
 804a79c:	7c 56                	jl     804a7f4 <vsnprintf+0x319>
 804a79e:	00 00                	add    %al,(%eax)
 804a7a0:	7c 56                	jl     804a7f8 <vsnprintf+0x31d>
 804a7a2:	00 00                	add    %al,(%eax)
 804a7a4:	7c 56                	jl     804a7fc <vsnprintf+0x321>
 804a7a6:	00 00                	add    %al,(%eax)
 804a7a8:	7c 56                	jl     804a800 <vsnprintf+0x325>
 804a7aa:	00 00                	add    %al,(%eax)
 804a7ac:	7c 56                	jl     804a804 <vsnprintf+0x329>
 804a7ae:	00 00                	add    %al,(%eax)
 804a7b0:	7c 56                	jl     804a808 <vsnprintf+0x32d>
 804a7b2:	00 00                	add    %al,(%eax)
 804a7b4:	7c 56                	jl     804a80c <vsnprintf+0x331>
 804a7b6:	00 00                	add    %al,(%eax)
 804a7b8:	7c 56                	jl     804a810 <vsnprintf+0x335>
 804a7ba:	00 00                	add    %al,(%eax)
 804a7bc:	7c 56                	jl     804a814 <vsnprintf+0x339>
 804a7be:	00 00                	add    %al,(%eax)
 804a7c0:	7c 56                	jl     804a818 <vsnprintf+0x33d>
 804a7c2:	00 00                	add    %al,(%eax)
 804a7c4:	7c 56                	jl     804a81c <vsnprintf+0x341>
 804a7c6:	00 00                	add    %al,(%eax)
 804a7c8:	7c 56                	jl     804a820 <vsnprintf+0x345>
 804a7ca:	00 00                	add    %al,(%eax)
 804a7cc:	7c 56                	jl     804a824 <vsnprintf+0x349>
 804a7ce:	00 00                	add    %al,(%eax)
 804a7d0:	7c 56                	jl     804a828 <vsnprintf+0x34d>
 804a7d2:	00 00                	add    %al,(%eax)
 804a7d4:	7c 56                	jl     804a82c <vsnprintf+0x351>
 804a7d6:	00 00                	add    %al,(%eax)
 804a7d8:	7c 56                	jl     804a830 <vsnprintf+0x355>
 804a7da:	00 00                	add    %al,(%eax)
 804a7dc:	7c 56                	jl     804a834 <vsnprintf+0x359>
 804a7de:	00 00                	add    %al,(%eax)
 804a7e0:	7c 56                	jl     804a838 <vsnprintf+0x35d>
 804a7e2:	00 00                	add    %al,(%eax)
 804a7e4:	7c 56                	jl     804a83c <vsnprintf+0x361>
 804a7e6:	00 00                	add    %al,(%eax)
 804a7e8:	7c 56                	jl     804a840 <vsnprintf+0x365>
 804a7ea:	00 00                	add    %al,(%eax)
 804a7ec:	7c 56                	jl     804a844 <vsnprintf+0x369>
 804a7ee:	00 00                	add    %al,(%eax)
 804a7f0:	7c 56                	jl     804a848 <vsnprintf+0x36d>
 804a7f2:	00 00                	add    %al,(%eax)
 804a7f4:	7c 56                	jl     804a84c <vsnprintf+0x371>
 804a7f6:	00 00                	add    %al,(%eax)
 804a7f8:	7c 56                	jl     804a850 <vsnprintf+0x375>
 804a7fa:	00 00                	add    %al,(%eax)
 804a7fc:	7c 56                	jl     804a854 <vsnprintf+0x379>
 804a7fe:	00 00                	add    %al,(%eax)
 804a800:	86 56 00             	xchg   %dl,0x0(%esi)
 804a803:	00 86 56 00 00 7c    	add    %al,0x7c000056(%esi)
 804a809:	56                   	push   %esi
 804a80a:	00 00                	add    %al,(%eax)
 804a80c:	7c 56                	jl     804a864 <vsnprintf+0x389>
 804a80e:	00 00                	add    %al,(%eax)
 804a810:	7c 56                	jl     804a868 <vsnprintf+0x38d>
 804a812:	00 00                	add    %al,(%eax)
 804a814:	7c 56                	jl     804a86c <vsnprintf+0x391>
 804a816:	00 00                	add    %al,(%eax)
 804a818:	7c 56                	jl     804a870 <vsnprintf+0x395>
 804a81a:	00 00                	add    %al,(%eax)
 804a81c:	7c 56                	jl     804a874 <vsnprintf+0x399>
 804a81e:	00 00                	add    %al,(%eax)
 804a820:	7c 56                	jl     804a878 <vsnprintf+0x39d>
 804a822:	00 00                	add    %al,(%eax)
 804a824:	7c 56                	jl     804a87c <vsnprintf+0x3a1>
 804a826:	00 00                	add    %al,(%eax)
 804a828:	7c 56                	jl     804a880 <vsnprintf+0x3a5>
 804a82a:	00 00                	add    %al,(%eax)
 804a82c:	7c 56                	jl     804a884 <vsnprintf+0x3a9>
 804a82e:	00 00                	add    %al,(%eax)
 804a830:	7c 56                	jl     804a888 <vsnprintf+0x3ad>
 804a832:	00 00                	add    %al,(%eax)
 804a834:	7c 56                	jl     804a88c <vsnprintf+0x3b1>
 804a836:	00 00                	add    %al,(%eax)
 804a838:	7c 56                	jl     804a890 <vsnprintf+0x3b5>
 804a83a:	00 00                	add    %al,(%eax)
 804a83c:	7c 56                	jl     804a894 <vsnprintf+0x3b9>
 804a83e:	00 00                	add    %al,(%eax)
 804a840:	7c 56                	jl     804a898 <vsnprintf+0x3bd>
 804a842:	00 00                	add    %al,(%eax)
 804a844:	7c 56                	jl     804a89c <vsnprintf+0x3c1>
 804a846:	00 00                	add    %al,(%eax)
 804a848:	99                   	cltd   
 804a849:	56                   	push   %esi
 804a84a:	00 00                	add    %al,(%eax)
 804a84c:	7c 56                	jl     804a8a4 <vsnprintf+0x3c9>
 804a84e:	00 00                	add    %al,(%eax)
 804a850:	7c 56                	jl     804a8a8 <vsnprintf+0x3cd>
 804a852:	00 00                	add    %al,(%eax)
 804a854:	7c 56                	jl     804a8ac <vsnprintf+0x3d1>
 804a856:	00 00                	add    %al,(%eax)
 804a858:	7c 56                	jl     804a8b0 <vsnprintf+0x3d5>
 804a85a:	00 00                	add    %al,(%eax)
 804a85c:	7c 56                	jl     804a8b4 <vsnprintf+0x3d9>
 804a85e:	00 00                	add    %al,(%eax)
 804a860:	7c 56                	jl     804a8b8 <vsnprintf+0x3dd>
 804a862:	00 00                	add    %al,(%eax)
 804a864:	7c 56                	jl     804a8bc <vsnprintf+0x3e1>
 804a866:	00 00                	add    %al,(%eax)
 804a868:	7c 56                	jl     804a8c0 <vsnprintf+0x3e5>
 804a86a:	00 00                	add    %al,(%eax)
 804a86c:	7c 56                	jl     804a8c4 <vsnprintf+0x3e9>
 804a86e:	00 00                	add    %al,(%eax)
 804a870:	7c 56                	jl     804a8c8 <vsnprintf+0x3ed>
 804a872:	00 00                	add    %al,(%eax)
 804a874:	b4 58                	mov    $0x58,%ah
 804a876:	00 00                	add    %al,(%eax)
 804a878:	8c 56 00             	mov    %ss,0x0(%esi)
 804a87b:	00 7c 56 00          	add    %bh,0x0(%esi,%edx,2)
 804a87f:	00 86 56 00 00 86    	add    %al,-0x79ffffaa(%esi)
 804a885:	56                   	push   %esi
 804a886:	00 00                	add    %al,(%eax)
 804a888:	7c 56                	jl     804a8e0 <vsnprintf+0x405>
 804a88a:	00 00                	add    %al,(%eax)
 804a88c:	8c 56 00             	mov    %ss,0x0(%esi)
 804a88f:	00 7c 56 00          	add    %bh,0x0(%esi,%edx,2)
 804a893:	00 7c 56 00          	add    %bh,0x0(%esi,%edx,2)
 804a897:	00 7c 56 00          	add    %bh,0x0(%esi,%edx,2)
 804a89b:	00 7c 56 00          	add    %bh,0x0(%esi,%edx,2)
 804a89f:	00 2b                	add    %ch,(%ebx)
 804a8a1:	57                   	push   %edi
 804a8a2:	00 00                	add    %al,(%eax)
 804a8a4:	a2 56 00 00 8b       	mov    %al,0x8b000056
 804a8a9:	57                   	push   %edi
 804a8aa:	00 00                	add    %al,(%eax)
 804a8ac:	7c 56                	jl     804a904 <vsnprintf+0x429>
 804a8ae:	00 00                	add    %al,(%eax)
 804a8b0:	7c 56                	jl     804a908 <vsnprintf+0x42d>
 804a8b2:	00 00                	add    %al,(%eax)
 804a8b4:	46                   	inc    %esi
 804a8b5:	58                   	pop    %eax
 804a8b6:	00 00                	add    %al,(%eax)
 804a8b8:	7c 56                	jl     804a910 <vsnprintf+0x435>
 804a8ba:	00 00                	add    %al,(%eax)
 804a8bc:	36                   	ss
 804a8bd:	56                   	push   %esi
 804a8be:	00 00                	add    %al,(%eax)
 804a8c0:	7c 56                	jl     804a918 <vsnprintf+0x43d>
 804a8c2:	00 00                	add    %al,(%eax)
 804a8c4:	7c 56                	jl     804a91c <vsnprintf+0x441>
 804a8c6:	00 00                	add    %al,(%eax)
 804a8c8:	95                   	xchg   %eax,%ebp
 804a8c9:	56                   	push   %esi
 804a8ca:	00 00                	add    %al,(%eax)
                        case 'c':
                                if (!(flags & LEFT)) {
 804a8cc:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a8cf:	83 e0 10             	and    $0x10,%eax
 804a8d2:	85 c0                	test   %eax,%eax
 804a8d4:	75 1e                	jne    804a8f4 <vsnprintf+0x419>
                                        while (--field_width > 0) {
 804a8d6:	eb 12                	jmp    804a8ea <vsnprintf+0x40f>
                                                if (str <= end)
 804a8d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a8db:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804a8de:	77 06                	ja     804a8e6 <vsnprintf+0x40b>
                                                        *str = ' ';
 804a8e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a8e3:	c6 00 20             	movb   $0x20,(%eax)
                                                ++str;
 804a8e6:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                base = 10;

                switch (*fmt) {
                        case 'c':
                                if (!(flags & LEFT)) {
                                        while (--field_width > 0) {
 804a8ea:	83 6d d4 01          	subl   $0x1,-0x2c(%ebp)
 804a8ee:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804a8f2:	7f e4                	jg     804a8d8 <vsnprintf+0x3fd>
                                                if (str <= end)
                                                        *str = ' ';
                                                ++str;
                                        }
                                }
                                c = (unsigned char) va_arg(args, int);
 804a8f4:	8b 45 14             	mov    0x14(%ebp),%eax
 804a8f7:	8d 50 04             	lea    0x4(%eax),%edx
 804a8fa:	89 55 14             	mov    %edx,0x14(%ebp)
 804a8fd:	8b 00                	mov    (%eax),%eax
 804a8ff:	88 45 cb             	mov    %al,-0x35(%ebp)
                                if (str <= end)
 804a902:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a905:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804a908:	77 09                	ja     804a913 <vsnprintf+0x438>
                                        *str = c;
 804a90a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a90d:	0f b6 55 cb          	movzbl -0x35(%ebp),%edx
 804a911:	88 10                	mov    %dl,(%eax)
                                ++str;
 804a913:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                                while (--field_width > 0) {
 804a917:	eb 12                	jmp    804a92b <vsnprintf+0x450>
                                        if (str <= end)
 804a919:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a91c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804a91f:	77 06                	ja     804a927 <vsnprintf+0x44c>
                                                *str = ' ';
 804a921:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a924:	c6 00 20             	movb   $0x20,(%eax)
                                        ++str;
 804a927:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                                }
                                c = (unsigned char) va_arg(args, int);
                                if (str <= end)
                                        *str = c;
                                ++str;
                                while (--field_width > 0) {
 804a92b:	83 6d d4 01          	subl   $0x1,-0x2c(%ebp)
 804a92f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804a933:	7f e4                	jg     804a919 <vsnprintf+0x43e>
                                        if (str <= end)
                                                *str = ' ';
                                        ++str;
                                }
                                continue;
 804a935:	e9 2e 03 00 00       	jmp    804ac68 <vsnprintf+0x78d>

                        case 's':
                                s = va_arg(args, char *);
 804a93a:	8b 45 14             	mov    0x14(%ebp),%eax
 804a93d:	8d 50 04             	lea    0x4(%eax),%edx
 804a940:	89 55 14             	mov    %edx,0x14(%ebp)
 804a943:	8b 00                	mov    (%eax),%eax
 804a945:	89 45 dc             	mov    %eax,-0x24(%ebp)
                                if (!s)
 804a948:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 804a94c:	75 09                	jne    804a957 <vsnprintf+0x47c>
                                        s = "<NULL>";
 804a94e:	8d 83 72 e0 ff ff    	lea    -0x1f8e(%ebx),%eax
 804a954:	89 45 dc             	mov    %eax,-0x24(%ebp)

                                len = strnlen(s, precision);
 804a957:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a95a:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a95e:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a961:	89 04 24             	mov    %eax,(%esp)
 804a964:	e8 8b dd ff ff       	call   80486f4 <strnlen>
 804a969:	89 45 c4             	mov    %eax,-0x3c(%ebp)

                                if (!(flags & LEFT)) {
 804a96c:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a96f:	83 e0 10             	and    $0x10,%eax
 804a972:	85 c0                	test   %eax,%eax
 804a974:	75 25                	jne    804a99b <vsnprintf+0x4c0>
                                        while (len < field_width--) {
 804a976:	eb 12                	jmp    804a98a <vsnprintf+0x4af>
                                                if (str <= end)
 804a978:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a97b:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804a97e:	77 06                	ja     804a986 <vsnprintf+0x4ab>
                                                        *str = ' ';
 804a980:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a983:	c6 00 20             	movb   $0x20,(%eax)
                                                ++str;
 804a986:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                                        s = "<NULL>";

                                len = strnlen(s, precision);

                                if (!(flags & LEFT)) {
                                        while (len < field_width--) {
 804a98a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804a98d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
 804a990:	0f 9f c0             	setg   %al
 804a993:	83 6d d4 01          	subl   $0x1,-0x2c(%ebp)
 804a997:	84 c0                	test   %al,%al
 804a999:	75 dd                	jne    804a978 <vsnprintf+0x49d>
                                                if (str <= end)
                                                        *str = ' ';
                                                ++str;
                                        }
                                }
                                for (i = 0; i < len; ++i) {
 804a99b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 804a9a2:	eb 1f                	jmp    804a9c3 <vsnprintf+0x4e8>
                                        if (str <= end)
 804a9a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a9a7:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804a9aa:	77 0b                	ja     804a9b7 <vsnprintf+0x4dc>
                                                *str = *s;
 804a9ac:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a9af:	0f b6 10             	movzbl (%eax),%edx
 804a9b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a9b5:	88 10                	mov    %dl,(%eax)
                                        ++str; ++s;
 804a9b7:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
 804a9bb:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
                                                if (str <= end)
                                                        *str = ' ';
                                                ++str;
                                        }
                                }
                                for (i = 0; i < len; ++i) {
 804a9bf:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
 804a9c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a9c6:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
 804a9c9:	7c d9                	jl     804a9a4 <vsnprintf+0x4c9>
                                        if (str <= end)
                                                *str = *s;
                                        ++str; ++s;
                                }
                                while (len < field_width--) {
 804a9cb:	eb 12                	jmp    804a9df <vsnprintf+0x504>
                                        if (str <= end)
 804a9cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a9d0:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804a9d3:	77 06                	ja     804a9db <vsnprintf+0x500>
                                                *str = ' ';
 804a9d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a9d8:	c6 00 20             	movb   $0x20,(%eax)
                                        ++str;
 804a9db:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                                for (i = 0; i < len; ++i) {
                                        if (str <= end)
                                                *str = *s;
                                        ++str; ++s;
                                }
                                while (len < field_width--) {
 804a9df:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804a9e2:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
 804a9e5:	0f 9f c0             	setg   %al
 804a9e8:	83 6d d4 01          	subl   $0x1,-0x2c(%ebp)
 804a9ec:	84 c0                	test   %al,%al
 804a9ee:	75 dd                	jne    804a9cd <vsnprintf+0x4f2>
                                        if (str <= end)
                                                *str = ' ';
                                        ++str;
                                }
                                continue;
 804a9f0:	e9 73 02 00 00       	jmp    804ac68 <vsnprintf+0x78d>

                        case 'p':
                                if (field_width == -1) {
 804a9f5:	83 7d d4 ff          	cmpl   $0xffffffff,-0x2c(%ebp)
 804a9f9:	75 0b                	jne    804aa06 <vsnprintf+0x52b>
                                        field_width = 2 * sizeof(void *);
 804a9fb:	c7 45 d4 08 00 00 00 	movl   $0x8,-0x2c(%ebp)
                                        flags |= ZEROPAD;
 804aa02:	83 4d d8 01          	orl    $0x1,-0x28(%ebp)
                                }
                                str = number(str, end,
                                             (unsigned long) va_arg(args, void *),
 804aa06:	8b 45 14             	mov    0x14(%ebp),%eax
 804aa09:	8d 50 04             	lea    0x4(%eax),%edx
 804aa0c:	89 55 14             	mov    %edx,0x14(%ebp)
 804aa0f:	8b 00                	mov    (%eax),%eax
                        case 'p':
                                if (field_width == -1) {
                                        field_width = 2 * sizeof(void *);
                                        flags |= ZEROPAD;
                                }
                                str = number(str, end,
 804aa11:	ba 00 00 00 00       	mov    $0x0,%edx
 804aa16:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 804aa19:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
 804aa1d:	8b 4d d0             	mov    -0x30(%ebp),%ecx
 804aa20:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 804aa24:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 804aa27:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 804aa2b:	c7 44 24 10 10 00 00 	movl   $0x10,0x10(%esp)
 804aa32:	00 
 804aa33:	89 44 24 08          	mov    %eax,0x8(%esp)
 804aa37:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804aa3b:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804aa3e:	89 44 24 04          	mov    %eax,0x4(%esp)
 804aa42:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804aa45:	89 04 24             	mov    %eax,(%esp)
 804aa48:	e8 cb f6 ff ff       	call   804a118 <number>
 804aa4d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                                             (unsigned long) va_arg(args, void *),
                                             16, field_width, precision, flags);
                                continue;
 804aa50:	e9 13 02 00 00       	jmp    804ac68 <vsnprintf+0x78d>


                        case 'n':
                                /* FIXME:
                                 * What does C99 say about the overflow case here? */
                                if (qualifier == 'l') {
 804aa55:	83 7d cc 6c          	cmpl   $0x6c,-0x34(%ebp)
 804aa59:	75 20                	jne    804aa7b <vsnprintf+0x5a0>
                                        long *ip = va_arg(args, long *);
 804aa5b:	8b 45 14             	mov    0x14(%ebp),%eax
 804aa5e:	8d 50 04             	lea    0x4(%eax),%edx
 804aa61:	89 55 14             	mov    %edx,0x14(%ebp)
 804aa64:	8b 00                	mov    (%eax),%eax
 804aa66:	89 45 c0             	mov    %eax,-0x40(%ebp)
                                        *ip = (str - buf);
 804aa69:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804aa6c:	8b 45 08             	mov    0x8(%ebp),%eax
 804aa6f:	29 c2                	sub    %eax,%edx
 804aa71:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804aa74:	89 10                	mov    %edx,(%eax)
                                        *ip = (str - buf);
                                } else {
                                        int *ip = va_arg(args, int *);
                                        *ip = (str - buf);
                                }
                                continue;
 804aa76:	e9 ed 01 00 00       	jmp    804ac68 <vsnprintf+0x78d>
                                /* FIXME:
                                 * What does C99 say about the overflow case here? */
                                if (qualifier == 'l') {
                                        long *ip = va_arg(args, long *);
                                        *ip = (str - buf);
                                } else if (qualifier == 'Z') {
 804aa7b:	83 7d cc 5a          	cmpl   $0x5a,-0x34(%ebp)
 804aa7f:	75 26                	jne    804aaa7 <vsnprintf+0x5cc>
                                        size_t *ip = va_arg(args, size_t *);
 804aa81:	8b 45 14             	mov    0x14(%ebp),%eax
 804aa84:	8d 50 04             	lea    0x4(%eax),%edx
 804aa87:	89 55 14             	mov    %edx,0x14(%ebp)
 804aa8a:	8b 00                	mov    (%eax),%eax
 804aa8c:	89 45 bc             	mov    %eax,-0x44(%ebp)
                                        *ip = (str - buf);
 804aa8f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804aa92:	8b 45 08             	mov    0x8(%ebp),%eax
 804aa95:	89 d1                	mov    %edx,%ecx
 804aa97:	29 c1                	sub    %eax,%ecx
 804aa99:	89 c8                	mov    %ecx,%eax
 804aa9b:	89 c2                	mov    %eax,%edx
 804aa9d:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804aaa0:	89 10                	mov    %edx,(%eax)
                                } else {
                                        int *ip = va_arg(args, int *);
                                        *ip = (str - buf);
                                }
                                continue;
 804aaa2:	e9 c1 01 00 00       	jmp    804ac68 <vsnprintf+0x78d>
                                        *ip = (str - buf);
                                } else if (qualifier == 'Z') {
                                        size_t *ip = va_arg(args, size_t *);
                                        *ip = (str - buf);
                                } else {
                                        int *ip = va_arg(args, int *);
 804aaa7:	8b 45 14             	mov    0x14(%ebp),%eax
 804aaaa:	8d 50 04             	lea    0x4(%eax),%edx
 804aaad:	89 55 14             	mov    %edx,0x14(%ebp)
 804aab0:	8b 00                	mov    (%eax),%eax
 804aab2:	89 45 b8             	mov    %eax,-0x48(%ebp)
                                        *ip = (str - buf);
 804aab5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804aab8:	8b 45 08             	mov    0x8(%ebp),%eax
 804aabb:	29 c2                	sub    %eax,%edx
 804aabd:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804aac0:	89 10                	mov    %edx,(%eax)
                                }
                                continue;
 804aac2:	e9 a1 01 00 00       	jmp    804ac68 <vsnprintf+0x78d>

                        case '%':
                                if (str <= end)
 804aac7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804aaca:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804aacd:	77 06                	ja     804aad5 <vsnprintf+0x5fa>
                                        *str = '%';
 804aacf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804aad2:	c6 00 25             	movb   $0x25,(%eax)
                                ++str;
 804aad5:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                                continue;
 804aad9:	e9 8a 01 00 00       	jmp    804ac68 <vsnprintf+0x78d>

                                /* integer number formats - set up the flags and "break" */
                        case 'o':
                                base = 8;
 804aade:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
                                break;
 804aae5:	eb 64                	jmp    804ab4b <vsnprintf+0x670>

                        case 'X':
                                flags |= LARGE;
 804aae7:	83 4d d8 40          	orl    $0x40,-0x28(%ebp)
                        case 'x':
                                base = 16;
 804aaeb:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%ebp)
                                break;
 804aaf2:	eb 57                	jmp    804ab4b <vsnprintf+0x670>

                        case 'd':
                        case 'i':
                                flags |= SIGN;
 804aaf4:	83 4d d8 02          	orl    $0x2,-0x28(%ebp)
                        case 'u':
                                break;
 804aaf8:	eb 50                	jmp    804ab4a <vsnprintf+0x66f>
                                /* Added - TODO - alvin */
                        case 'f':
                        case 'F':
                        case 'g':
                        case 'G':
                                return -1;
 804aafa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804aaff:	e9 a6 01 00 00       	jmp    804acaa <vsnprintf+0x7cf>


                        default:
                                if (str <= end)
 804ab04:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804ab07:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804ab0a:	77 06                	ja     804ab12 <vsnprintf+0x637>
                                        *str = '%';
 804ab0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804ab0f:	c6 00 25             	movb   $0x25,(%eax)
                                ++str;
 804ab12:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                                if (*fmt) {
 804ab16:	8b 45 10             	mov    0x10(%ebp),%eax
 804ab19:	0f b6 00             	movzbl (%eax),%eax
 804ab1c:	84 c0                	test   %al,%al
 804ab1e:	74 1c                	je     804ab3c <vsnprintf+0x661>
                                        if (str <= end)
 804ab20:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804ab23:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804ab26:	77 0b                	ja     804ab33 <vsnprintf+0x658>
                                                *str = *fmt;
 804ab28:	8b 45 10             	mov    0x10(%ebp),%eax
 804ab2b:	0f b6 10             	movzbl (%eax),%edx
 804ab2e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804ab31:	88 10                	mov    %dl,(%eax)
                                        ++str;
 804ab33:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                                } else {
                                        --fmt;
                                }
                                continue;
 804ab37:	e9 2c 01 00 00       	jmp    804ac68 <vsnprintf+0x78d>
                                if (*fmt) {
                                        if (str <= end)
                                                *str = *fmt;
                                        ++str;
                                } else {
                                        --fmt;
 804ab3c:	8b 45 10             	mov    0x10(%ebp),%eax
 804ab3f:	83 e8 01             	sub    $0x1,%eax
 804ab42:	89 45 10             	mov    %eax,0x10(%ebp)
                                }
                                continue;
 804ab45:	e9 1e 01 00 00       	jmp    804ac68 <vsnprintf+0x78d>

                        case 'd':
                        case 'i':
                                flags |= SIGN;
                        case 'u':
                                break;
 804ab4a:	90                   	nop
                                } else {
                                        --fmt;
                                }
                                continue;
                }
                if (qualifier == 'L')
 804ab4b:	83 7d cc 4c          	cmpl   $0x4c,-0x34(%ebp)
 804ab4f:	75 19                	jne    804ab6a <vsnprintf+0x68f>
                        num = va_arg(args, long long);
 804ab51:	8b 45 14             	mov    0x14(%ebp),%eax
 804ab54:	8d 50 08             	lea    0x8(%eax),%edx
 804ab57:	89 55 14             	mov    %edx,0x14(%ebp)
 804ab5a:	8b 50 04             	mov    0x4(%eax),%edx
 804ab5d:	8b 00                	mov    (%eax),%eax
 804ab5f:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804ab62:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804ab65:	e9 bf 00 00 00       	jmp    804ac29 <vsnprintf+0x74e>
                else if (qualifier == 'l') {
 804ab6a:	83 7d cc 6c          	cmpl   $0x6c,-0x34(%ebp)
 804ab6e:	75 36                	jne    804aba6 <vsnprintf+0x6cb>
                        num = va_arg(args, unsigned long);
 804ab70:	8b 45 14             	mov    0x14(%ebp),%eax
 804ab73:	8d 50 04             	lea    0x4(%eax),%edx
 804ab76:	89 55 14             	mov    %edx,0x14(%ebp)
 804ab79:	8b 00                	mov    (%eax),%eax
 804ab7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804ab7e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        if (flags & SIGN)
 804ab85:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804ab88:	83 e0 02             	and    $0x2,%eax
 804ab8b:	85 c0                	test   %eax,%eax
 804ab8d:	0f 84 96 00 00 00    	je     804ac29 <vsnprintf+0x74e>
                                num = (signed long) num;
 804ab93:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ab96:	89 c2                	mov    %eax,%edx
 804ab98:	c1 fa 1f             	sar    $0x1f,%edx
 804ab9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804ab9e:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804aba1:	e9 83 00 00 00       	jmp    804ac29 <vsnprintf+0x74e>
                } else if (qualifier == 'Z') {
 804aba6:	83 7d cc 5a          	cmpl   $0x5a,-0x34(%ebp)
 804abaa:	75 17                	jne    804abc3 <vsnprintf+0x6e8>
                        num = va_arg(args, size_t);
 804abac:	8b 45 14             	mov    0x14(%ebp),%eax
 804abaf:	8d 50 04             	lea    0x4(%eax),%edx
 804abb2:	89 55 14             	mov    %edx,0x14(%ebp)
 804abb5:	8b 00                	mov    (%eax),%eax
 804abb7:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804abba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804abc1:	eb 66                	jmp    804ac29 <vsnprintf+0x74e>
                } else if (qualifier == 'h') {
 804abc3:	83 7d cc 68          	cmpl   $0x68,-0x34(%ebp)
 804abc7:	75 33                	jne    804abfc <vsnprintf+0x721>
                        num = (unsigned short) va_arg(args, int);
 804abc9:	8b 45 14             	mov    0x14(%ebp),%eax
 804abcc:	8d 50 04             	lea    0x4(%eax),%edx
 804abcf:	89 55 14             	mov    %edx,0x14(%ebp)
 804abd2:	8b 00                	mov    (%eax),%eax
 804abd4:	0f b7 c0             	movzwl %ax,%eax
 804abd7:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804abda:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        if (flags & SIGN)
 804abe1:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804abe4:	83 e0 02             	and    $0x2,%eax
 804abe7:	85 c0                	test   %eax,%eax
 804abe9:	74 3e                	je     804ac29 <vsnprintf+0x74e>
                                num = (signed short) num;
 804abeb:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804abee:	98                   	cwtl   
 804abef:	89 c2                	mov    %eax,%edx
 804abf1:	c1 fa 1f             	sar    $0x1f,%edx
 804abf4:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804abf7:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804abfa:	eb 2d                	jmp    804ac29 <vsnprintf+0x74e>
                } else {
                        num = va_arg(args, unsigned int);
 804abfc:	8b 45 14             	mov    0x14(%ebp),%eax
 804abff:	8d 50 04             	lea    0x4(%eax),%edx
 804ac02:	89 55 14             	mov    %edx,0x14(%ebp)
 804ac05:	8b 00                	mov    (%eax),%eax
 804ac07:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804ac0a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        if (flags & SIGN)
 804ac11:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804ac14:	83 e0 02             	and    $0x2,%eax
 804ac17:	85 c0                	test   %eax,%eax
 804ac19:	74 0e                	je     804ac29 <vsnprintf+0x74e>
                                num = (signed int) num;
 804ac1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ac1e:	89 c2                	mov    %eax,%edx
 804ac20:	c1 fa 1f             	sar    $0x1f,%edx
 804ac23:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804ac26:	89 55 f4             	mov    %edx,-0xc(%ebp)
                }

                str = number(str, end, num, base,
 804ac29:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ac2c:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804ac2f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 804ac32:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
 804ac36:	8b 4d d0             	mov    -0x30(%ebp),%ecx
 804ac39:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 804ac3d:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 804ac40:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 804ac44:	8b 4d e8             	mov    -0x18(%ebp),%ecx
 804ac47:	89 4c 24 10          	mov    %ecx,0x10(%esp)
 804ac4b:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ac4f:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804ac53:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804ac56:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ac5a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804ac5d:	89 04 24             	mov    %eax,(%esp)
 804ac60:	e8 b3 f4 ff ff       	call   804a118 <number>
 804ac65:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (end < buf - 1) {
                end = ((void *) - 1);
                size = end - buf + 1;
        }

        for (; *fmt ; ++fmt) {
 804ac68:	8b 45 10             	mov    0x10(%ebp),%eax
 804ac6b:	83 c0 01             	add    $0x1,%eax
 804ac6e:	89 45 10             	mov    %eax,0x10(%ebp)
 804ac71:	eb 01                	jmp    804ac74 <vsnprintf+0x799>
 804ac73:	90                   	nop
 804ac74:	8b 45 10             	mov    0x10(%ebp),%eax
 804ac77:	0f b6 00             	movzbl (%eax),%eax
 804ac7a:	84 c0                	test   %al,%al
 804ac7c:	0f 85 aa f8 ff ff    	jne    804a52c <vsnprintf+0x51>
                }

                str = number(str, end, num, base,
                             field_width, precision, flags);
        }
        if (str <= end)
 804ac82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804ac85:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804ac88:	77 08                	ja     804ac92 <vsnprintf+0x7b7>
                *str = '\0';
 804ac8a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804ac8d:	c6 00 00             	movb   $0x0,(%eax)
 804ac90:	eb 0c                	jmp    804ac9e <vsnprintf+0x7c3>
        else if (size > 0)
 804ac92:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804ac96:	74 06                	je     804ac9e <vsnprintf+0x7c3>
                /* don't write out a null byte if the buf size is zero */
                *end = '\0';
 804ac98:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804ac9b:	c6 00 00             	movb   $0x0,(%eax)
        /* the trailing null byte doesn't count towards the total
         * ++str;
         */
        return str - buf;
 804ac9e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804aca1:	8b 45 08             	mov    0x8(%ebp),%eax
 804aca4:	89 d1                	mov    %edx,%ecx
 804aca6:	29 c1                	sub    %eax,%ecx
 804aca8:	89 c8                	mov    %ecx,%eax
}
 804acaa:	83 c4 64             	add    $0x64,%esp
 804acad:	5b                   	pop    %ebx
 804acae:	5d                   	pop    %ebp
 804acaf:	c3                   	ret    

0804acb0 <wrterror>:
#define abort() exit(1)
#endif

static void
wrterror(char *p)
{
 804acb0:	55                   	push   %ebp
 804acb1:	89 e5                	mov    %esp,%ebp
 804acb3:	53                   	push   %ebx
 804acb4:	83 ec 24             	sub    $0x24,%esp
 804acb7:	e8 65 d8 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804acbc:	81 c3 c4 54 00 00    	add    $0x54c4,%ebx
        char *q = " error: ";
 804acc2:	8d 83 7d e0 ff ff    	lea    -0x1f83(%ebx),%eax
 804acc8:	89 45 f4             	mov    %eax,-0xc(%ebp)
        _write(STDERR_FILENO, __progname, strlen(__progname));
 804accb:	8b 83 64 01 00 00    	mov    0x164(%ebx),%eax
 804acd1:	89 04 24             	mov    %eax,(%esp)
 804acd4:	e8 98 da ff ff       	call   8048771 <strlen>
 804acd9:	8b 93 64 01 00 00    	mov    0x164(%ebx),%edx
 804acdf:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ace3:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ace7:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804acee:	e8 13 eb ff ff       	call   8049806 <write>
        _write(STDERR_FILENO, malloc_func, strlen(malloc_func));
 804acf3:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804acf9:	89 04 24             	mov    %eax,(%esp)
 804acfc:	e8 70 da ff ff       	call   8048771 <strlen>
 804ad01:	8b 93 9c 02 00 00    	mov    0x29c(%ebx),%edx
 804ad07:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ad0b:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ad0f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804ad16:	e8 eb ea ff ff       	call   8049806 <write>
        _write(STDERR_FILENO, q, strlen(q));
 804ad1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ad1e:	89 04 24             	mov    %eax,(%esp)
 804ad21:	e8 4b da ff ff       	call   8048771 <strlen>
 804ad26:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ad2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ad2d:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ad31:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804ad38:	e8 c9 ea ff ff       	call   8049806 <write>
        _write(STDERR_FILENO, p, strlen(p));
 804ad3d:	8b 45 08             	mov    0x8(%ebp),%eax
 804ad40:	89 04 24             	mov    %eax,(%esp)
 804ad43:	e8 29 da ff ff       	call   8048771 <strlen>
 804ad48:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ad4c:	8b 45 08             	mov    0x8(%ebp),%eax
 804ad4f:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ad53:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804ad5a:	e8 a7 ea ff ff       	call   8049806 <write>
        suicide = 1;
 804ad5f:	c7 83 78 02 00 00 01 	movl   $0x1,0x278(%ebx)
 804ad66:	00 00 00 
        abort();
 804ad69:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804ad70:	e8 eb e5 ff ff       	call   8049360 <exit>
}
 804ad75:	83 c4 24             	add    $0x24,%esp
 804ad78:	5b                   	pop    %ebx
 804ad79:	5d                   	pop    %ebp
 804ad7a:	c3                   	ret    

0804ad7b <wrtwarning>:

static void
wrtwarning(char *p)
{
 804ad7b:	55                   	push   %ebp
 804ad7c:	89 e5                	mov    %esp,%ebp
 804ad7e:	53                   	push   %ebx
 804ad7f:	83 ec 24             	sub    $0x24,%esp
 804ad82:	e8 9a d7 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804ad87:	81 c3 f9 53 00 00    	add    $0x53f9,%ebx
        char *q = " warning: ";
 804ad8d:	8d 83 86 e0 ff ff    	lea    -0x1f7a(%ebx),%eax
 804ad93:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (malloc_abort)
 804ad96:	8b 83 74 02 00 00    	mov    0x274(%ebx),%eax
 804ad9c:	85 c0                	test   %eax,%eax
 804ad9e:	74 0b                	je     804adab <wrtwarning+0x30>
                wrterror(p);
 804ada0:	8b 45 08             	mov    0x8(%ebp),%eax
 804ada3:	89 04 24             	mov    %eax,(%esp)
 804ada6:	e8 05 ff ff ff       	call   804acb0 <wrterror>
        _write(STDERR_FILENO, __progname, strlen(__progname));
 804adab:	8b 83 64 01 00 00    	mov    0x164(%ebx),%eax
 804adb1:	89 04 24             	mov    %eax,(%esp)
 804adb4:	e8 b8 d9 ff ff       	call   8048771 <strlen>
 804adb9:	8b 93 64 01 00 00    	mov    0x164(%ebx),%edx
 804adbf:	89 44 24 08          	mov    %eax,0x8(%esp)
 804adc3:	89 54 24 04          	mov    %edx,0x4(%esp)
 804adc7:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804adce:	e8 33 ea ff ff       	call   8049806 <write>
        _write(STDERR_FILENO, malloc_func, strlen(malloc_func));
 804add3:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804add9:	89 04 24             	mov    %eax,(%esp)
 804addc:	e8 90 d9 ff ff       	call   8048771 <strlen>
 804ade1:	8b 93 9c 02 00 00    	mov    0x29c(%ebx),%edx
 804ade7:	89 44 24 08          	mov    %eax,0x8(%esp)
 804adeb:	89 54 24 04          	mov    %edx,0x4(%esp)
 804adef:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804adf6:	e8 0b ea ff ff       	call   8049806 <write>
        _write(STDERR_FILENO, q, strlen(q));
 804adfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804adfe:	89 04 24             	mov    %eax,(%esp)
 804ae01:	e8 6b d9 ff ff       	call   8048771 <strlen>
 804ae06:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ae0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ae0d:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ae11:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804ae18:	e8 e9 e9 ff ff       	call   8049806 <write>
        _write(STDERR_FILENO, p, strlen(p));
 804ae1d:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae20:	89 04 24             	mov    %eax,(%esp)
 804ae23:	e8 49 d9 ff ff       	call   8048771 <strlen>
 804ae28:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ae2c:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae2f:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ae33:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804ae3a:	e8 c7 e9 ff ff       	call   8049806 <write>
}
 804ae3f:	83 c4 24             	add    $0x24,%esp
 804ae42:	5b                   	pop    %ebx
 804ae43:	5d                   	pop    %ebp
 804ae44:	c3                   	ret    

0804ae45 <map_pages>:
/*
 * Allocate a number of pages from the OS
 */
static void *
map_pages(int pages)
{
 804ae45:	55                   	push   %ebp
 804ae46:	89 e5                	mov    %esp,%ebp
 804ae48:	53                   	push   %ebx
 804ae49:	83 ec 24             	sub    $0x24,%esp
 804ae4c:	e8 d0 d6 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804ae51:	81 c3 2f 53 00 00    	add    $0x532f,%ebx
        caddr_t result, tail;

        result = (caddr_t)pageround((u_long)sbrk(0));
 804ae57:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804ae5e:	e8 d5 e2 ff ff       	call   8049138 <sbrk>
 804ae63:	05 ff 0f 00 00       	add    $0xfff,%eax
 804ae68:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 804ae6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
        tail = result + (pages << malloc_pageshift);
 804ae70:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae73:	c1 e0 0c             	shl    $0xc,%eax
 804ae76:	03 45 f4             	add    -0xc(%ebp),%eax
 804ae79:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (brk(tail)) {
 804ae7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ae7f:	89 04 24             	mov    %eax,(%esp)
 804ae82:	e8 81 e3 ff ff       	call   8049208 <brk>
 804ae87:	85 c0                	test   %eax,%eax
 804ae89:	74 07                	je     804ae92 <map_pages+0x4d>
#ifdef EXTRA_SANITY
                wrterror("(ES): map_pages fails\n");
#endif /* EXTRA_SANITY */
                return 0;
 804ae8b:	b8 00 00 00 00       	mov    $0x0,%eax
 804ae90:	eb 55                	jmp    804aee7 <map_pages+0xa2>
        }

        last_index = ptr2index(tail) - 1;
 804ae92:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ae95:	89 c2                	mov    %eax,%edx
 804ae97:	c1 ea 0c             	shr    $0xc,%edx
 804ae9a:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804aea0:	89 d1                	mov    %edx,%ecx
 804aea2:	29 c1                	sub    %eax,%ecx
 804aea4:	89 c8                	mov    %ecx,%eax
 804aea6:	83 e8 01             	sub    $0x1,%eax
 804aea9:	89 83 54 02 00 00    	mov    %eax,0x254(%ebx)
        malloc_brk = tail;
 804aeaf:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804aeb2:	89 83 94 02 00 00    	mov    %eax,0x294(%ebx)

        if ((last_index + 1) >= malloc_ninfo && !extend_pgdir(last_index))
 804aeb8:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804aebe:	8d 50 01             	lea    0x1(%eax),%edx
 804aec1:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804aec7:	39 c2                	cmp    %eax,%edx
 804aec9:	72 19                	jb     804aee4 <map_pages+0x9f>
 804aecb:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804aed1:	89 04 24             	mov    %eax,(%esp)
 804aed4:	e8 14 00 00 00       	call   804aeed <extend_pgdir>
 804aed9:	85 c0                	test   %eax,%eax
 804aedb:	75 07                	jne    804aee4 <map_pages+0x9f>
                return 0;;
 804aedd:	b8 00 00 00 00       	mov    $0x0,%eax
 804aee2:	eb 03                	jmp    804aee7 <map_pages+0xa2>

        return result;
 804aee4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804aee7:	83 c4 24             	add    $0x24,%esp
 804aeea:	5b                   	pop    %ebx
 804aeeb:	5d                   	pop    %ebp
 804aeec:	c3                   	ret    

0804aeed <extend_pgdir>:
/*
 * Extend page directory
 */
static int
extend_pgdir(u_long index)
{
 804aeed:	55                   	push   %ebp
 804aeee:	89 e5                	mov    %esp,%ebp
 804aef0:	53                   	push   %ebx
 804aef1:	83 ec 34             	sub    $0x34,%esp
 804aef4:	e8 28 d6 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804aef9:	81 c3 87 52 00 00    	add    $0x5287,%ebx
        struct  pginfo **new, **old;
        int i, oldlen;

        /* Make it this many pages */
        i = index * sizeof * page_dir;
 804aeff:	8b 45 08             	mov    0x8(%ebp),%eax
 804af02:	c1 e0 02             	shl    $0x2,%eax
 804af05:	89 45 f4             	mov    %eax,-0xc(%ebp)
        i /= malloc_pagesize;
 804af08:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804af0b:	c1 e8 0c             	shr    $0xc,%eax
 804af0e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        i += 2;
 804af11:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)

        /* remember the old mapping size */
        oldlen = malloc_ninfo * sizeof * page_dir;
 804af15:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804af1b:	c1 e0 02             	shl    $0x2,%eax
 804af1e:	89 45 f0             	mov    %eax,-0x10(%ebp)
         * address, the old pages will be "magically" remapped..  But this means
         * keeping open a "secret" file descriptor.....
         */

        /* Get new pages */
        new = (struct pginfo **) MMAP(i * malloc_pagesize);
 804af21:	8b 83 44 02 00 00    	mov    0x244(%ebx),%eax
 804af27:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804af2a:	c1 e2 0c             	shl    $0xc,%edx
 804af2d:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804af34:	00 
 804af35:	89 44 24 10          	mov    %eax,0x10(%esp)
 804af39:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
 804af40:	00 
 804af41:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 804af48:	00 
 804af49:	89 54 24 04          	mov    %edx,0x4(%esp)
 804af4d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804af54:	e8 53 e6 ff ff       	call   80495ac <mmap>
 804af59:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (new == (struct pginfo **) - 1)
 804af5c:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
 804af60:	75 07                	jne    804af69 <extend_pgdir+0x7c>
                return 0;
 804af62:	b8 00 00 00 00       	mov    $0x0,%eax
 804af67:	eb 5e                	jmp    804afc7 <extend_pgdir+0xda>

        /* Copy the old stuff */
        memcpy(new, page_dir,
 804af69:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804af6f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804af76:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804af7c:	89 54 24 08          	mov    %edx,0x8(%esp)
 804af80:	89 44 24 04          	mov    %eax,0x4(%esp)
 804af84:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804af87:	89 04 24             	mov    %eax,(%esp)
 804af8a:	e8 e7 d5 ff ff       	call   8048576 <memcpy>
               malloc_ninfo * sizeof * page_dir);

        /* register the new size */
        malloc_ninfo = i * malloc_pagesize / sizeof * page_dir;
 804af8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804af92:	c1 e0 0c             	shl    $0xc,%eax
 804af95:	c1 e8 02             	shr    $0x2,%eax
 804af98:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)

        /* swap the pointers */
        old = page_dir;
 804af9e:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804afa4:	89 45 e8             	mov    %eax,-0x18(%ebp)
        page_dir = new;
 804afa7:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804afaa:	89 83 58 02 00 00    	mov    %eax,0x258(%ebx)

        /* Now free the old stuff */
        munmap((char *)old, oldlen);
 804afb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804afb3:	89 44 24 04          	mov    %eax,0x4(%esp)
 804afb7:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804afba:	89 04 24             	mov    %eax,(%esp)
 804afbd:	e8 5f e6 ff ff       	call   8049621 <munmap>
        return 1;
 804afc2:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804afc7:	83 c4 34             	add    $0x34,%esp
 804afca:	5b                   	pop    %ebx
 804afcb:	5d                   	pop    %ebp
 804afcc:	c3                   	ret    

0804afcd <malloc_init>:
/*
 * Initialize the world
 */
static void
malloc_init()
{
 804afcd:	55                   	push   %ebp
 804afce:	89 e5                	mov    %esp,%ebp
 804afd0:	53                   	push   %ebx
 804afd1:	83 ec 34             	sub    $0x34,%esp
 804afd4:	e8 48 d5 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804afd9:	81 c3 a7 51 00 00    	add    $0x51a7,%ebx
        char *p;
        int i, j;

        INIT_MMAP();
 804afdf:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804afe6:	00 
 804afe7:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
 804afee:	00 
 804afef:	8d 83 91 e0 ff ff    	lea    -0x1f6f(%ebx),%eax
 804aff5:	89 04 24             	mov    %eax,(%esp)
 804aff8:	e8 d0 e6 ff ff       	call   80496cd <open>
 804affd:	89 83 44 02 00 00    	mov    %eax,0x244(%ebx)
 804b003:	8b 83 44 02 00 00    	mov    0x244(%ebx),%eax
 804b009:	83 f8 ff             	cmp    $0xffffffff,%eax
 804b00c:	75 0e                	jne    804b01c <malloc_init+0x4f>
 804b00e:	8d 83 9b e0 ff ff    	lea    -0x1f65(%ebx),%eax
 804b014:	89 04 24             	mov    %eax,(%esp)
 804b017:	e8 94 fc ff ff       	call   804acb0 <wrterror>

#ifdef EXTRA_SANITY
        malloc_junk = 1;
#endif /* EXTRA_SANITY */

        for (i = 0; i < 3; i++) {
 804b01c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 804b023:	e9 7f 02 00 00       	jmp    804b2a7 <malloc_init+0x2da>
                if (i == 0) {
 804b028:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804b02c:	75 0c                	jne    804b03a <malloc_init+0x6d>
                        if (j <= 0)
                                continue;
                        b[j] = '\0';
                        p = b;
#else
                        p = NULL;
 804b02e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        p = NULL;
#endif
                } else {
                        p = malloc_options;
                }
                for (; p && *p; p++) {
 804b035:	e9 55 02 00 00       	jmp    804b28f <malloc_init+0x2c2>
                        b[j] = '\0';
                        p = b;
#else
                        p = NULL;
#endif
                } else if (i == 1) {
 804b03a:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
 804b03e:	75 0c                	jne    804b04c <malloc_init+0x7f>
#ifdef HAS_GETENV
                        p = getenv("MALLOC_OPTIONS");
#else
                        p = NULL;
 804b040:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#endif
                } else {
                        p = malloc_options;
                }
                for (; p && *p; p++) {
 804b047:	e9 43 02 00 00       	jmp    804b28f <malloc_init+0x2c2>
                        p = getenv("MALLOC_OPTIONS");
#else
                        p = NULL;
#endif
                } else {
                        p = malloc_options;
 804b04c:	8b 83 f8 ff ff ff    	mov    -0x8(%ebx),%eax
 804b052:	8b 00                	mov    (%eax),%eax
 804b054:	89 45 f4             	mov    %eax,-0xc(%ebp)
                }
                for (; p && *p; p++) {
 804b057:	e9 33 02 00 00       	jmp    804b28f <malloc_init+0x2c2>
                        switch (*p) {
 804b05c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b05f:	0f b6 00             	movzbl (%eax),%eax
 804b062:	0f be c0             	movsbl %al,%eax
 804b065:	83 e8 3c             	sub    $0x3c,%eax
 804b068:	83 f8 3e             	cmp    $0x3e,%eax
 804b06b:	0f 87 ef 01 00 00    	ja     804b260 <malloc_init+0x293>
 804b071:	c1 e0 02             	shl    $0x2,%eax
 804b074:	8b 84 18 04 af ff ff 	mov    -0x50fc(%eax,%ebx,1),%eax
 804b07b:	89 da                	mov    %ebx,%edx
 804b07d:	29 c2                	sub    %eax,%edx
 804b07f:	89 d0                	mov    %edx,%eax
 804b081:	ff e0                	jmp    *%eax
 804b083:	90                   	nop
 804b084:	ed                   	in     (%dx),%eax
 804b085:	4f                   	dec    %edi
 804b086:	00 00                	add    %al,(%eax)
 804b088:	20 4f 00             	and    %cl,0x0(%edi)
 804b08b:	00 00                	add    %al,(%eax)
 804b08d:	50                   	push   %eax
 804b08e:	00 00                	add    %al,(%eax)
 804b090:	20 4f 00             	and    %cl,0x0(%edi)
 804b093:	00 20                	add    %ah,(%eax)
 804b095:	4f                   	dec    %edi
 804b096:	00 00                	add    %al,(%eax)
 804b098:	cb                   	lret   
 804b099:	4f                   	dec    %edi
 804b09a:	00 00                	add    %al,(%eax)
 804b09c:	20 4f 00             	and    %cl,0x0(%edi)
 804b09f:	00 20                	add    %ah,(%eax)
 804b0a1:	4f                   	dec    %edi
 804b0a2:	00 00                	add    %al,(%eax)
 804b0a4:	20 4f 00             	and    %cl,0x0(%edi)
 804b0a7:	00 20                	add    %ah,(%eax)
 804b0a9:	4f                   	dec    %edi
 804b0aa:	00 00                	add    %al,(%eax)
 804b0ac:	20 4f 00             	and    %cl,0x0(%edi)
 804b0af:	00 20                	add    %ah,(%eax)
 804b0b1:	4f                   	dec    %edi
 804b0b2:	00 00                	add    %al,(%eax)
 804b0b4:	ad                   	lods   %ds:(%esi),%eax
 804b0b5:	4f                   	dec    %edi
 804b0b6:	00 00                	add    %al,(%eax)
 804b0b8:	20 4f 00             	and    %cl,0x0(%edi)
 804b0bb:	00 74 4f 00          	add    %dh,0x0(%edi,%ecx,2)
 804b0bf:	00 20                	add    %ah,(%eax)
 804b0c1:	4f                   	dec    %edi
 804b0c2:	00 00                	add    %al,(%eax)
 804b0c4:	20 4f 00             	and    %cl,0x0(%edi)
 804b0c7:	00 20                	add    %ah,(%eax)
 804b0c9:	4f                   	dec    %edi
 804b0ca:	00 00                	add    %al,(%eax)
 804b0cc:	20 4f 00             	and    %cl,0x0(%edi)
 804b0cf:	00 20                	add    %ah,(%eax)
 804b0d1:	4f                   	dec    %edi
 804b0d2:	00 00                	add    %al,(%eax)
 804b0d4:	20 4f 00             	and    %cl,0x0(%edi)
 804b0d7:	00 20                	add    %ah,(%eax)
 804b0d9:	4f                   	dec    %edi
 804b0da:	00 00                	add    %al,(%eax)
 804b0dc:	8f                   	(bad)  
 804b0dd:	4f                   	dec    %edi
 804b0de:	00 00                	add    %al,(%eax)
 804b0e0:	20 4f 00             	and    %cl,0x0(%edi)
 804b0e3:	00 20                	add    %ah,(%eax)
 804b0e5:	4f                   	dec    %edi
 804b0e6:	00 00                	add    %al,(%eax)
 804b0e8:	20 4f 00             	and    %cl,0x0(%edi)
 804b0eb:	00 5c 4f 00          	add    %bl,0x0(%edi,%ecx,2)
 804b0ef:	00 20                	add    %ah,(%eax)
 804b0f1:	4f                   	dec    %edi
 804b0f2:	00 00                	add    %al,(%eax)
 804b0f4:	44                   	inc    %esp
 804b0f5:	4f                   	dec    %edi
 804b0f6:	00 00                	add    %al,(%eax)
 804b0f8:	20 4f 00             	and    %cl,0x0(%edi)
 804b0fb:	00 2c 4f             	add    %ch,(%edi,%ecx,2)
 804b0fe:	00 00                	add    %al,(%eax)
 804b100:	20 4f 00             	and    %cl,0x0(%edi)
 804b103:	00 20                	add    %ah,(%eax)
 804b105:	4f                   	dec    %edi
 804b106:	00 00                	add    %al,(%eax)
 804b108:	20 4f 00             	and    %cl,0x0(%edi)
 804b10b:	00 20                	add    %ah,(%eax)
 804b10d:	4f                   	dec    %edi
 804b10e:	00 00                	add    %al,(%eax)
 804b110:	20 4f 00             	and    %cl,0x0(%edi)
 804b113:	00 20                	add    %ah,(%eax)
 804b115:	4f                   	dec    %edi
 804b116:	00 00                	add    %al,(%eax)
 804b118:	da 4f 00             	fimull 0x0(%edi)
 804b11b:	00 20                	add    %ah,(%eax)
 804b11d:	4f                   	dec    %edi
 804b11e:	00 00                	add    %al,(%eax)
 804b120:	20 4f 00             	and    %cl,0x0(%edi)
 804b123:	00 20                	add    %ah,(%eax)
 804b125:	4f                   	dec    %edi
 804b126:	00 00                	add    %al,(%eax)
 804b128:	20 4f 00             	and    %cl,0x0(%edi)
 804b12b:	00 20                	add    %ah,(%eax)
 804b12d:	4f                   	dec    %edi
 804b12e:	00 00                	add    %al,(%eax)
 804b130:	20 4f 00             	and    %cl,0x0(%edi)
 804b133:	00 bc 4f 00 00 20 4f 	add    %bh,0x4f200000(%edi,%ecx,2)
 804b13a:	00 00                	add    %al,(%eax)
 804b13c:	80 4f 00 00          	orb    $0x0,0x0(%edi)
 804b140:	20 4f 00             	and    %cl,0x0(%edi)
 804b143:	00 20                	add    %ah,(%eax)
 804b145:	4f                   	dec    %edi
 804b146:	00 00                	add    %al,(%eax)
 804b148:	20 4f 00             	and    %cl,0x0(%edi)
 804b14b:	00 20                	add    %ah,(%eax)
 804b14d:	4f                   	dec    %edi
 804b14e:	00 00                	add    %al,(%eax)
 804b150:	20 4f 00             	and    %cl,0x0(%edi)
 804b153:	00 20                	add    %ah,(%eax)
 804b155:	4f                   	dec    %edi
 804b156:	00 00                	add    %al,(%eax)
 804b158:	20 4f 00             	and    %cl,0x0(%edi)
 804b15b:	00 9e 4f 00 00 20    	add    %bl,0x2000004f(%esi)
 804b161:	4f                   	dec    %edi
 804b162:	00 00                	add    %al,(%eax)
 804b164:	20 4f 00             	and    %cl,0x0(%edi)
 804b167:	00 20                	add    %ah,(%eax)
 804b169:	4f                   	dec    %edi
 804b16a:	00 00                	add    %al,(%eax)
 804b16c:	68 4f 00 00 20       	push   $0x2000004f
 804b171:	4f                   	dec    %edi
 804b172:	00 00                	add    %al,(%eax)
 804b174:	50                   	push   %eax
 804b175:	4f                   	dec    %edi
 804b176:	00 00                	add    %al,(%eax)
 804b178:	20 4f 00             	and    %cl,0x0(%edi)
 804b17b:	00 38                	add    %bh,(%eax)
 804b17d:	4f                   	dec    %edi
 804b17e:	00 00                	add    %al,(%eax)
                                case '>': malloc_cache   <<= 1; break;
 804b180:	8b 83 60 01 00 00    	mov    0x160(%ebx),%eax
 804b186:	01 c0                	add    %eax,%eax
 804b188:	89 83 60 01 00 00    	mov    %eax,0x160(%ebx)
 804b18e:	e9 f8 00 00 00       	jmp    804b28b <malloc_init+0x2be>
                                case '<': malloc_cache   >>= 1; break;
 804b193:	8b 83 60 01 00 00    	mov    0x160(%ebx),%eax
 804b199:	d1 e8                	shr    %eax
 804b19b:	89 83 60 01 00 00    	mov    %eax,0x160(%ebx)
 804b1a1:	e9 e5 00 00 00       	jmp    804b28b <malloc_init+0x2be>
                                case 'a': malloc_abort   = 0; break;
 804b1a6:	c7 83 74 02 00 00 00 	movl   $0x0,0x274(%ebx)
 804b1ad:	00 00 00 
 804b1b0:	e9 d6 00 00 00       	jmp    804b28b <malloc_init+0x2be>
                                case 'A': malloc_abort   = 1; break;
 804b1b5:	c7 83 74 02 00 00 01 	movl   $0x1,0x274(%ebx)
 804b1bc:	00 00 00 
 804b1bf:	e9 c7 00 00 00       	jmp    804b28b <malloc_init+0x2be>
                                case 'h': malloc_hint    = 0; break;
 804b1c4:	c7 83 80 02 00 00 00 	movl   $0x0,0x280(%ebx)
 804b1cb:	00 00 00 
 804b1ce:	e9 b8 00 00 00       	jmp    804b28b <malloc_init+0x2be>
                                case 'H': malloc_hint    = 1; break;
 804b1d3:	c7 83 80 02 00 00 01 	movl   $0x1,0x280(%ebx)
 804b1da:	00 00 00 
 804b1dd:	e9 a9 00 00 00       	jmp    804b28b <malloc_init+0x2be>
                                case 'r': malloc_realloc = 0; break;
 804b1e2:	c7 83 7c 02 00 00 00 	movl   $0x0,0x27c(%ebx)
 804b1e9:	00 00 00 
 804b1ec:	e9 9a 00 00 00       	jmp    804b28b <malloc_init+0x2be>
                                case 'R': malloc_realloc = 1; break;
 804b1f1:	c7 83 7c 02 00 00 01 	movl   $0x1,0x27c(%ebx)
 804b1f8:	00 00 00 
 804b1fb:	e9 8b 00 00 00       	jmp    804b28b <malloc_init+0x2be>
                                case 'j': malloc_junk    = 0; break;
 804b200:	c7 83 90 02 00 00 00 	movl   $0x0,0x290(%ebx)
 804b207:	00 00 00 
 804b20a:	eb 7f                	jmp    804b28b <malloc_init+0x2be>
                                case 'J': malloc_junk    = 1; break;
 804b20c:	c7 83 90 02 00 00 01 	movl   $0x1,0x290(%ebx)
 804b213:	00 00 00 
 804b216:	eb 73                	jmp    804b28b <malloc_init+0x2be>
#ifdef HAS_UTRACE
                                case 'u': malloc_utrace  = 0; break;
                                case 'U': malloc_utrace  = 1; break;
#endif
                                case 'v': malloc_sysv    = 0; break;
 804b218:	c7 83 88 02 00 00 00 	movl   $0x0,0x288(%ebx)
 804b21f:	00 00 00 
 804b222:	eb 67                	jmp    804b28b <malloc_init+0x2be>
                                case 'V': malloc_sysv    = 1; break;
 804b224:	c7 83 88 02 00 00 01 	movl   $0x1,0x288(%ebx)
 804b22b:	00 00 00 
 804b22e:	eb 5b                	jmp    804b28b <malloc_init+0x2be>
                                case 'x': malloc_xmalloc = 0; break;
 804b230:	c7 83 84 02 00 00 00 	movl   $0x0,0x284(%ebx)
 804b237:	00 00 00 
 804b23a:	eb 4f                	jmp    804b28b <malloc_init+0x2be>
                                case 'X': malloc_xmalloc = 1; break;
 804b23c:	c7 83 84 02 00 00 01 	movl   $0x1,0x284(%ebx)
 804b243:	00 00 00 
 804b246:	eb 43                	jmp    804b28b <malloc_init+0x2be>
                                case 'z': malloc_zero    = 0; break;
 804b248:	c7 83 8c 02 00 00 00 	movl   $0x0,0x28c(%ebx)
 804b24f:	00 00 00 
 804b252:	eb 37                	jmp    804b28b <malloc_init+0x2be>
                                case 'Z': malloc_zero    = 1; break;
 804b254:	c7 83 8c 02 00 00 01 	movl   $0x1,0x28c(%ebx)
 804b25b:	00 00 00 
 804b25e:	eb 2b                	jmp    804b28b <malloc_init+0x2be>
                                default:
                                        j = malloc_abort;
 804b260:	8b 83 74 02 00 00    	mov    0x274(%ebx),%eax
 804b266:	89 45 ec             	mov    %eax,-0x14(%ebp)
                                        malloc_abort = 0;
 804b269:	c7 83 74 02 00 00 00 	movl   $0x0,0x274(%ebx)
 804b270:	00 00 00 
                                        wrtwarning("unknown char in MALLOC_OPTIONS\n");
 804b273:	8d 83 b0 e0 ff ff    	lea    -0x1f50(%ebx),%eax
 804b279:	89 04 24             	mov    %eax,(%esp)
 804b27c:	e8 fa fa ff ff       	call   804ad7b <wrtwarning>
                                        malloc_abort = j;
 804b281:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b284:	89 83 74 02 00 00    	mov    %eax,0x274(%ebx)
                                        break;
 804b28a:	90                   	nop
                        p = NULL;
#endif
                } else {
                        p = malloc_options;
                }
                for (; p && *p; p++) {
 804b28b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 804b28f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804b293:	74 0e                	je     804b2a3 <malloc_init+0x2d6>
 804b295:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b298:	0f b6 00             	movzbl (%eax),%eax
 804b29b:	84 c0                	test   %al,%al
 804b29d:	0f 85 b9 fd ff ff    	jne    804b05c <malloc_init+0x8f>

#ifdef EXTRA_SANITY
        malloc_junk = 1;
#endif /* EXTRA_SANITY */

        for (i = 0; i < 3; i++) {
 804b2a3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
 804b2a7:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
 804b2ab:	0f 8e 77 fd ff ff    	jle    804b028 <malloc_init+0x5b>

        /*
         * We want junk in the entire allocation, and zero only in the part
         * the user asked for.
         */
        if (malloc_zero)
 804b2b1:	8b 83 8c 02 00 00    	mov    0x28c(%ebx),%eax
 804b2b7:	85 c0                	test   %eax,%eax
 804b2b9:	74 0a                	je     804b2c5 <malloc_init+0x2f8>
                malloc_junk = 1;
 804b2bb:	c7 83 90 02 00 00 01 	movl   $0x1,0x290(%ebx)
 804b2c2:	00 00 00 

        /*
         * If we run with junk (or implicitly from above: zero), we want to
         * force realloc() to get new storage, so we can DTRT with it.
         */
        if (malloc_junk)
 804b2c5:	8b 83 90 02 00 00    	mov    0x290(%ebx),%eax
 804b2cb:	85 c0                	test   %eax,%eax
 804b2cd:	74 0a                	je     804b2d9 <malloc_init+0x30c>
                malloc_realloc = 1;
 804b2cf:	c7 83 7c 02 00 00 01 	movl   $0x1,0x27c(%ebx)
 804b2d6:	00 00 00 

        /* Allocate one page for the page directory */
        page_dir = (struct pginfo **) MMAP(malloc_pagesize);
 804b2d9:	8b 83 44 02 00 00    	mov    0x244(%ebx),%eax
 804b2df:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804b2e6:	00 
 804b2e7:	89 44 24 10          	mov    %eax,0x10(%esp)
 804b2eb:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
 804b2f2:	00 
 804b2f3:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 804b2fa:	00 
 804b2fb:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 804b302:	00 
 804b303:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b30a:	e8 9d e2 ff ff       	call   80495ac <mmap>
 804b30f:	89 83 58 02 00 00    	mov    %eax,0x258(%ebx)

        if (page_dir == (struct pginfo **) - 1)
 804b315:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804b31b:	83 f8 ff             	cmp    $0xffffffff,%eax
 804b31e:	75 0e                	jne    804b32e <malloc_init+0x361>
                wrterror("mmap(2) failed, check limits\n");
 804b320:	8d 83 d0 e0 ff ff    	lea    -0x1f30(%ebx),%eax
 804b326:	89 04 24             	mov    %eax,(%esp)
 804b329:	e8 82 f9 ff ff       	call   804acb0 <wrterror>

        /*
         * We need a maximum of malloc_pageshift buckets, steal these from the
         * front of the page_directory;
         */
        malloc_origo = ((u_long)pageround((u_long)sbrk(0))) >> malloc_pageshift;
 804b32e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b335:	e8 fe dd ff ff       	call   8049138 <sbrk>
 804b33a:	05 ff 0f 00 00       	add    $0xfff,%eax
 804b33f:	c1 e8 0c             	shr    $0xc,%eax
 804b342:	89 83 50 02 00 00    	mov    %eax,0x250(%ebx)
        malloc_origo -= malloc_pageshift;
 804b348:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804b34e:	83 e8 0c             	sub    $0xc,%eax
 804b351:	89 83 50 02 00 00    	mov    %eax,0x250(%ebx)

        malloc_ninfo = malloc_pagesize / sizeof * page_dir;
 804b357:	c7 83 5c 02 00 00 00 	movl   $0x400,0x25c(%ebx)
 804b35e:	04 00 00 

        /* Recalculate the cache size in bytes, and make sure it's nonzero */

        if (!malloc_cache)
 804b361:	8b 83 60 01 00 00    	mov    0x160(%ebx),%eax
 804b367:	85 c0                	test   %eax,%eax
 804b369:	75 0f                	jne    804b37a <malloc_init+0x3ad>
                malloc_cache++;
 804b36b:	8b 83 60 01 00 00    	mov    0x160(%ebx),%eax
 804b371:	83 c0 01             	add    $0x1,%eax
 804b374:	89 83 60 01 00 00    	mov    %eax,0x160(%ebx)

        malloc_cache <<= malloc_pageshift;
 804b37a:	8b 83 60 01 00 00    	mov    0x160(%ebx),%eax
 804b380:	c1 e0 0c             	shl    $0xc,%eax
 804b383:	89 83 60 01 00 00    	mov    %eax,0x160(%ebx)

        /*
         * This is a nice hack from Kaleb Keithly (kaleb@x.org).
         * We can sbrk(2) further back when we keep this on a low address.
         */
        px = (struct pgfree *) imalloc(sizeof * px);
 804b389:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 804b390:	e8 b9 07 00 00       	call   804bb4e <imalloc>
 804b395:	89 83 98 02 00 00    	mov    %eax,0x298(%ebx)

        /* Been here, done that */
        malloc_started++;
 804b39b:	8b 83 48 02 00 00    	mov    0x248(%ebx),%eax
 804b3a1:	83 c0 01             	add    $0x1,%eax
 804b3a4:	89 83 48 02 00 00    	mov    %eax,0x248(%ebx)
}
 804b3aa:	83 c4 34             	add    $0x34,%esp
 804b3ad:	5b                   	pop    %ebx
 804b3ae:	5d                   	pop    %ebp
 804b3af:	c3                   	ret    

0804b3b0 <malloc_pages>:
/*
 * Allocate a number of complete pages
 */
static void *
malloc_pages(size_t size)
{
 804b3b0:	55                   	push   %ebp
 804b3b1:	89 e5                	mov    %esp,%ebp
 804b3b3:	53                   	push   %ebx
 804b3b4:	83 ec 34             	sub    $0x34,%esp
 804b3b7:	e8 65 d1 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804b3bc:	81 c3 c4 4d 00 00    	add    $0x4dc4,%ebx
        void *p, *delay_free = 0;
 804b3c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
        unsigned int i;
        struct pgfree *pf;
        u_long index;

        size = pageround(size);
 804b3c9:	8b 45 08             	mov    0x8(%ebp),%eax
 804b3cc:	05 ff 0f 00 00       	add    $0xfff,%eax
 804b3d1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 804b3d6:	89 45 08             	mov    %eax,0x8(%ebp)

        p = 0;
 804b3d9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804b3e0:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 804b3e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804b3e9:	e9 82 00 00 00       	jmp    804b470 <malloc_pages+0xc0>
                        wrterror("(ES): non-free first page on free-list\n");
                if (page_dir[ptr2index(pf->end) - 1] != MALLOC_FREE)
                        wrterror("(ES): non-free last page on free-list\n");
#endif /* EXTRA_SANITY */

                if (pf->size < size)
 804b3ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b3f1:	8b 40 10             	mov    0x10(%eax),%eax
 804b3f4:	3b 45 08             	cmp    0x8(%ebp),%eax
 804b3f7:	73 0a                	jae    804b403 <malloc_pages+0x53>
        size = pageround(size);

        p = 0;

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804b3f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b3fc:	8b 00                	mov    (%eax),%eax
 804b3fe:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804b401:	eb 6d                	jmp    804b470 <malloc_pages+0xc0>
#endif /* EXTRA_SANITY */

                if (pf->size < size)
                        continue;

                if (pf->size == size) {
 804b403:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b406:	8b 40 10             	mov    0x10(%eax),%eax
 804b409:	3b 45 08             	cmp    0x8(%ebp),%eax
 804b40c:	75 35                	jne    804b443 <malloc_pages+0x93>
                        p = pf->page;
 804b40e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b411:	8b 40 08             	mov    0x8(%eax),%eax
 804b414:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        if (pf->next)
 804b417:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b41a:	8b 00                	mov    (%eax),%eax
 804b41c:	85 c0                	test   %eax,%eax
 804b41e:	74 0e                	je     804b42e <malloc_pages+0x7e>
                                pf->next->prev = pf->prev;
 804b420:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b423:	8b 00                	mov    (%eax),%eax
 804b425:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804b428:	8b 52 04             	mov    0x4(%edx),%edx
 804b42b:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev->next = pf->next;
 804b42e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b431:	8b 40 04             	mov    0x4(%eax),%eax
 804b434:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804b437:	8b 12                	mov    (%edx),%edx
 804b439:	89 10                	mov    %edx,(%eax)
                        delay_free = pf;
 804b43b:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b43e:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        break;
 804b441:	eb 37                	jmp    804b47a <malloc_pages+0xca>
                }

                p = pf->page;
 804b443:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b446:	8b 40 08             	mov    0x8(%eax),%eax
 804b449:	89 45 f4             	mov    %eax,-0xc(%ebp)
                pf->page = (char *)pf->page + size;
 804b44c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b44f:	8b 40 08             	mov    0x8(%eax),%eax
 804b452:	89 c2                	mov    %eax,%edx
 804b454:	03 55 08             	add    0x8(%ebp),%edx
 804b457:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b45a:	89 50 08             	mov    %edx,0x8(%eax)
                pf->size -= size;
 804b45d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b460:	8b 40 10             	mov    0x10(%eax),%eax
 804b463:	89 c2                	mov    %eax,%edx
 804b465:	2b 55 08             	sub    0x8(%ebp),%edx
 804b468:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b46b:	89 50 10             	mov    %edx,0x10(%eax)
                break;
 804b46e:	eb 0a                	jmp    804b47a <malloc_pages+0xca>
        size = pageround(size);

        p = 0;

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804b470:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804b474:	0f 85 74 ff ff ff    	jne    804b3ee <malloc_pages+0x3e>
#ifdef EXTRA_SANITY
        if (p && page_dir[ptr2index(p)] != MALLOC_FREE)
                wrterror("(ES): allocated non-free page on free-list\n");
#endif /* EXTRA_SANITY */

        size >>= malloc_pageshift;
 804b47a:	c1 6d 08 0c          	shrl   $0xc,0x8(%ebp)

        /* Map new pages */
        if (!p)
 804b47e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804b482:	75 0e                	jne    804b492 <malloc_pages+0xe2>
                p = map_pages(size);
 804b484:	8b 45 08             	mov    0x8(%ebp),%eax
 804b487:	89 04 24             	mov    %eax,(%esp)
 804b48a:	e8 b6 f9 ff ff       	call   804ae45 <map_pages>
 804b48f:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (p) {
 804b492:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804b496:	0f 84 80 00 00 00    	je     804b51c <malloc_pages+0x16c>

                index = ptr2index(p);
 804b49c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b49f:	89 c2                	mov    %eax,%edx
 804b4a1:	c1 ea 0c             	shr    $0xc,%edx
 804b4a4:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804b4aa:	89 d1                	mov    %edx,%ecx
 804b4ac:	29 c1                	sub    %eax,%ecx
 804b4ae:	89 c8                	mov    %ecx,%eax
 804b4b0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                page_dir[index] = MALLOC_FIRST;
 804b4b3:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804b4b9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804b4bc:	c1 e2 02             	shl    $0x2,%edx
 804b4bf:	01 d0                	add    %edx,%eax
 804b4c1:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
                for (i = 1; i < size; i++)
 804b4c7:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
 804b4ce:	eb 1d                	jmp    804b4ed <malloc_pages+0x13d>
                        page_dir[index + i] = MALLOC_FOLLOW;
 804b4d0:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804b4d6:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804b4d9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 804b4dc:	01 ca                	add    %ecx,%edx
 804b4de:	c1 e2 02             	shl    $0x2,%edx
 804b4e1:	01 d0                	add    %edx,%eax
 804b4e3:	c7 00 03 00 00 00    	movl   $0x3,(%eax)

        if (p) {

                index = ptr2index(p);
                page_dir[index] = MALLOC_FIRST;
                for (i = 1; i < size; i++)
 804b4e9:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
 804b4ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b4f0:	3b 45 08             	cmp    0x8(%ebp),%eax
 804b4f3:	72 db                	jb     804b4d0 <malloc_pages+0x120>
                        page_dir[index + i] = MALLOC_FOLLOW;

                if (malloc_junk)
 804b4f5:	8b 83 90 02 00 00    	mov    0x290(%ebx),%eax
 804b4fb:	85 c0                	test   %eax,%eax
 804b4fd:	74 1d                	je     804b51c <malloc_pages+0x16c>
                        memset(p, SOME_JUNK, size << malloc_pageshift);
 804b4ff:	8b 45 08             	mov    0x8(%ebp),%eax
 804b502:	c1 e0 0c             	shl    $0xc,%eax
 804b505:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b509:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804b510:	00 
 804b511:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b514:	89 04 24             	mov    %eax,(%esp)
 804b517:	e8 a8 d1 ff ff       	call   80486c4 <memset>
        }

        if (delay_free) {
 804b51c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804b520:	74 20                	je     804b542 <malloc_pages+0x192>
                if (!px)
 804b522:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804b528:	85 c0                	test   %eax,%eax
 804b52a:	75 0b                	jne    804b537 <malloc_pages+0x187>
                        px = delay_free;
 804b52c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b52f:	89 83 98 02 00 00    	mov    %eax,0x298(%ebx)
 804b535:	eb 0b                	jmp    804b542 <malloc_pages+0x192>
                else
                        ifree(delay_free);
 804b537:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b53a:	89 04 24             	mov    %eax,(%esp)
 804b53d:	e8 60 0f 00 00       	call   804c4a2 <ifree>
        }

        return p;
 804b542:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804b545:	83 c4 34             	add    $0x34,%esp
 804b548:	5b                   	pop    %ebx
 804b549:	5d                   	pop    %ebp
 804b54a:	c3                   	ret    

0804b54b <malloc_make_chunks>:
 * Allocate a page of fragments
 */

static __inline__ int
malloc_make_chunks(int bits)
{
 804b54b:	55                   	push   %ebp
 804b54c:	89 e5                	mov    %esp,%ebp
 804b54e:	57                   	push   %edi
 804b54f:	56                   	push   %esi
 804b550:	53                   	push   %ebx
 804b551:	83 ec 4c             	sub    $0x4c,%esp
 804b554:	e8 c8 cf ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804b559:	81 c3 27 4c 00 00    	add    $0x4c27,%ebx
        struct  pginfo *bp;
        void *pp;
        unsigned int i, k, l;

        /* Allocate a new bucket */
        pp = malloc_pages(malloc_pagesize);
 804b55f:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
 804b566:	e8 45 fe ff ff       	call   804b3b0 <malloc_pages>
 804b56b:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if (!pp)
 804b56e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
 804b572:	75 0a                	jne    804b57e <malloc_make_chunks+0x33>
                return 0;
 804b574:	b8 00 00 00 00       	mov    $0x0,%eax
 804b579:	e9 16 02 00 00       	jmp    804b794 <malloc_make_chunks+0x249>

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
 804b57e:	c7 45 dc 10 00 00 00 	movl   $0x10,-0x24(%ebp)
        l += sizeof bp->bits[0] *
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);
 804b585:	8b 45 08             	mov    0x8(%ebp),%eax
 804b588:	ba 00 10 00 00       	mov    $0x1000,%edx
 804b58d:	89 d6                	mov    %edx,%esi
 804b58f:	89 c1                	mov    %eax,%ecx
 804b591:	d3 ee                	shr    %cl,%esi
 804b593:	89 f0                	mov    %esi,%eax
 804b595:	83 c0 1f             	add    $0x1f,%eax
 804b598:	c1 e8 05             	shr    $0x5,%eax
        if (!pp)
                return 0;

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
        l += sizeof bp->bits[0] *
 804b59b:	c1 e0 02             	shl    $0x2,%eax
 804b59e:	01 45 dc             	add    %eax,-0x24(%ebp)
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);

        /* Don't waste more than two chunks on this */
        if ((1U << (bits)) <= l + l) {
 804b5a1:	8b 45 08             	mov    0x8(%ebp),%eax
 804b5a4:	ba 01 00 00 00       	mov    $0x1,%edx
 804b5a9:	89 c1                	mov    %eax,%ecx
 804b5ab:	d3 e2                	shl    %cl,%edx
 804b5ad:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b5b0:	01 c0                	add    %eax,%eax
 804b5b2:	39 c2                	cmp    %eax,%edx
 804b5b4:	77 08                	ja     804b5be <malloc_make_chunks+0x73>
                bp = (struct  pginfo *)pp;
 804b5b6:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804b5b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804b5bc:	eb 29                	jmp    804b5e7 <malloc_make_chunks+0x9c>
        } else {
                bp = (struct  pginfo *)imalloc(l);
 804b5be:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b5c1:	89 04 24             	mov    %eax,(%esp)
 804b5c4:	e8 85 05 00 00       	call   804bb4e <imalloc>
 804b5c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (!bp) {
 804b5cc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804b5d0:	75 15                	jne    804b5e7 <malloc_make_chunks+0x9c>
                        ifree(pp);
 804b5d2:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804b5d5:	89 04 24             	mov    %eax,(%esp)
 804b5d8:	e8 c5 0e 00 00       	call   804c4a2 <ifree>
                        return 0;
 804b5dd:	b8 00 00 00 00       	mov    $0x0,%eax
 804b5e2:	e9 ad 01 00 00       	jmp    804b794 <malloc_make_chunks+0x249>
                }
        }

        bp->size = (1 << bits);
 804b5e7:	8b 45 08             	mov    0x8(%ebp),%eax
 804b5ea:	ba 01 00 00 00       	mov    $0x1,%edx
 804b5ef:	89 d6                	mov    %edx,%esi
 804b5f1:	89 c1                	mov    %eax,%ecx
 804b5f3:	d3 e6                	shl    %cl,%esi
 804b5f5:	89 f0                	mov    %esi,%eax
 804b5f7:	89 c2                	mov    %eax,%edx
 804b5f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b5fc:	66 89 50 08          	mov    %dx,0x8(%eax)
        bp->shift = bits;
 804b600:	8b 45 08             	mov    0x8(%ebp),%eax
 804b603:	89 c2                	mov    %eax,%edx
 804b605:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b608:	66 89 50 0a          	mov    %dx,0xa(%eax)
        bp->total = bp->free = malloc_pagesize >> bits;
 804b60c:	8b 45 08             	mov    0x8(%ebp),%eax
 804b60f:	ba 00 10 00 00       	mov    $0x1000,%edx
 804b614:	89 d6                	mov    %edx,%esi
 804b616:	89 c1                	mov    %eax,%ecx
 804b618:	d3 ee                	shr    %cl,%esi
 804b61a:	89 f0                	mov    %esi,%eax
 804b61c:	89 c2                	mov    %eax,%edx
 804b61e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b621:	66 89 50 0c          	mov    %dx,0xc(%eax)
 804b625:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b628:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804b62c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b62f:	66 89 50 0e          	mov    %dx,0xe(%eax)
        bp->page = pp;
 804b633:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b636:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804b639:	89 50 04             	mov    %edx,0x4(%eax)

        /* set all valid bits in the bitmap */
        k = bp->total;
 804b63c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b63f:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804b643:	0f b7 c0             	movzwl %ax,%eax
 804b646:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        i = 0;
 804b649:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 804b650:	eb 19                	jmp    804b66b <malloc_make_chunks+0x120>
                bp->bits[i / MALLOC_BITS] = ~0;
 804b652:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b655:	89 c2                	mov    %eax,%edx
 804b657:	c1 ea 05             	shr    $0x5,%edx
 804b65a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b65d:	83 c2 04             	add    $0x4,%edx
 804b660:	c7 04 90 ff ff ff ff 	movl   $0xffffffff,(%eax,%edx,4)
        /* set all valid bits in the bitmap */
        k = bp->total;
        i = 0;

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 804b667:	83 45 e0 20          	addl   $0x20,-0x20(%ebp)
 804b66b:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b66e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804b671:	89 d7                	mov    %edx,%edi
 804b673:	29 c7                	sub    %eax,%edi
 804b675:	89 f8                	mov    %edi,%eax
 804b677:	83 f8 1f             	cmp    $0x1f,%eax
 804b67a:	77 d6                	ja     804b652 <malloc_make_chunks+0x107>
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 804b67c:	eb 36                	jmp    804b6b4 <malloc_make_chunks+0x169>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804b67e:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b681:	c1 e8 05             	shr    $0x5,%eax
 804b684:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804b687:	8d 48 04             	lea    0x4(%eax),%ecx
 804b68a:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 804b68d:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804b690:	83 e2 1f             	and    $0x1f,%edx
 804b693:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
 804b69a:	8b 7d c4             	mov    -0x3c(%ebp),%edi
 804b69d:	89 d1                	mov    %edx,%ecx
 804b69f:	d3 e7                	shl    %cl,%edi
 804b6a1:	89 fa                	mov    %edi,%edx
 804b6a3:	89 f1                	mov    %esi,%ecx
 804b6a5:	09 d1                	or     %edx,%ecx
 804b6a7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804b6aa:	83 c0 04             	add    $0x4,%eax
 804b6ad:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 804b6b0:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
 804b6b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b6b7:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
 804b6ba:	72 c2                	jb     804b67e <malloc_make_chunks+0x133>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
 804b6bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b6bf:	8b 40 04             	mov    0x4(%eax),%eax
 804b6c2:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804b6c5:	75 7c                	jne    804b743 <malloc_make_chunks+0x1f8>
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804b6c7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
 804b6ce:	eb 6d                	jmp    804b73d <malloc_make_chunks+0x1f2>
                        bp->bits[i / MALLOC_BITS] &= ~(1 << (i % MALLOC_BITS));
 804b6d0:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b6d3:	c1 e8 05             	shr    $0x5,%eax
 804b6d6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804b6d9:	8d 48 04             	lea    0x4(%eax),%ecx
 804b6dc:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 804b6df:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804b6e2:	83 e2 1f             	and    $0x1f,%edx
 804b6e5:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
 804b6ec:	8b 7d c4             	mov    -0x3c(%ebp),%edi
 804b6ef:	89 d1                	mov    %edx,%ecx
 804b6f1:	d3 e7                	shl    %cl,%edi
 804b6f3:	89 fa                	mov    %edi,%edx
 804b6f5:	f7 d2                	not    %edx
 804b6f7:	89 f1                	mov    %esi,%ecx
 804b6f9:	21 d1                	and    %edx,%ecx
 804b6fb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804b6fe:	83 c0 04             	add    $0x4,%eax
 804b701:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
                        bp->free--;
 804b704:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b707:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804b70b:	8d 50 ff             	lea    -0x1(%eax),%edx
 804b70e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b711:	66 89 50 0c          	mov    %dx,0xc(%eax)
                        bp->total--;
 804b715:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b718:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804b71c:	8d 50 ff             	lea    -0x1(%eax),%edx
 804b71f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b722:	66 89 50 0e          	mov    %dx,0xe(%eax)
                        l -= (1 << bits);
 804b726:	8b 45 08             	mov    0x8(%ebp),%eax
 804b729:	ba 01 00 00 00       	mov    $0x1,%edx
 804b72e:	89 d6                	mov    %edx,%esi
 804b730:	89 c1                	mov    %eax,%ecx
 804b732:	d3 e6                	shl    %cl,%esi
 804b734:	89 f0                	mov    %esi,%eax
 804b736:	29 45 dc             	sub    %eax,-0x24(%ebp)
        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804b739:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
 804b73d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 804b741:	75 8d                	jne    804b6d0 <malloc_make_chunks+0x185>
                }
        }

        /* MALLOC_LOCK */

        page_dir[ptr2index(pp)] = bp;
 804b743:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804b749:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804b74c:	89 d1                	mov    %edx,%ecx
 804b74e:	c1 e9 0c             	shr    $0xc,%ecx
 804b751:	8b 93 50 02 00 00    	mov    0x250(%ebx),%edx
 804b757:	89 cf                	mov    %ecx,%edi
 804b759:	29 d7                	sub    %edx,%edi
 804b75b:	89 fa                	mov    %edi,%edx
 804b75d:	c1 e2 02             	shl    $0x2,%edx
 804b760:	01 c2                	add    %eax,%edx
 804b762:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b765:	89 02                	mov    %eax,(%edx)

        bp->next = page_dir[bits];
 804b767:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804b76d:	8b 55 08             	mov    0x8(%ebp),%edx
 804b770:	c1 e2 02             	shl    $0x2,%edx
 804b773:	01 d0                	add    %edx,%eax
 804b775:	8b 10                	mov    (%eax),%edx
 804b777:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b77a:	89 10                	mov    %edx,(%eax)
        page_dir[bits] = bp;
 804b77c:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804b782:	8b 55 08             	mov    0x8(%ebp),%edx
 804b785:	c1 e2 02             	shl    $0x2,%edx
 804b788:	01 c2                	add    %eax,%edx
 804b78a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b78d:	89 02                	mov    %eax,(%edx)

        /* MALLOC_UNLOCK */

        return 1;
 804b78f:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804b794:	83 c4 4c             	add    $0x4c,%esp
 804b797:	5b                   	pop    %ebx
 804b798:	5e                   	pop    %esi
 804b799:	5f                   	pop    %edi
 804b79a:	5d                   	pop    %ebp
 804b79b:	c3                   	ret    

0804b79c <malloc_bytes>:
/*
 * Allocate a fragment
 */
static void *
malloc_bytes(size_t size)
{
 804b79c:	55                   	push   %ebp
 804b79d:	89 e5                	mov    %esp,%ebp
 804b79f:	57                   	push   %edi
 804b7a0:	56                   	push   %esi
 804b7a1:	53                   	push   %ebx
 804b7a2:	83 ec 5c             	sub    $0x5c,%esp
 804b7a5:	e8 77 cd ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804b7aa:	81 c3 d6 49 00 00    	add    $0x49d6,%ebx
        struct  pginfo *bp;
        int k;
        u_int *lp;

        /* Don't bother with anything less than this */
        if (size < malloc_minsize)
 804b7b0:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
 804b7b4:	77 07                	ja     804b7bd <malloc_bytes+0x21>
                size = malloc_minsize;
 804b7b6:	c7 45 08 10 00 00 00 	movl   $0x10,0x8(%ebp)

        /* Find the right bucket */
        j = 1;
 804b7bd:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        i = size - 1;
 804b7c4:	8b 45 08             	mov    0x8(%ebp),%eax
 804b7c7:	83 e8 01             	sub    $0x1,%eax
 804b7ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        while (i >>= 1)
 804b7cd:	eb 04                	jmp    804b7d3 <malloc_bytes+0x37>
                j++;
 804b7cf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
                size = malloc_minsize;

        /* Find the right bucket */
        j = 1;
        i = size - 1;
        while (i >>= 1)
 804b7d3:	d1 7d e4             	sarl   -0x1c(%ebp)
 804b7d6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804b7da:	75 f3                	jne    804b7cf <malloc_bytes+0x33>
                j++;

        /* If it's empty, make a page more of that size chunks */
        if (!page_dir[j] && !malloc_make_chunks(j))
 804b7dc:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804b7e2:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804b7e5:	c1 e2 02             	shl    $0x2,%edx
 804b7e8:	01 d0                	add    %edx,%eax
 804b7ea:	8b 00                	mov    (%eax),%eax
 804b7ec:	85 c0                	test   %eax,%eax
 804b7ee:	0f 85 49 02 00 00    	jne    804ba3d <malloc_bytes+0x2a1>
 804b7f4:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b7f7:	89 45 cc             	mov    %eax,-0x34(%ebp)
        struct  pginfo *bp;
        void *pp;
        unsigned int i, k, l;

        /* Allocate a new bucket */
        pp = malloc_pages(malloc_pagesize);
 804b7fa:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
 804b801:	e8 aa fb ff ff       	call   804b3b0 <malloc_pages>
 804b806:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if (!pp)
 804b809:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804b80d:	75 0a                	jne    804b819 <malloc_bytes+0x7d>
                return 0;
 804b80f:	b8 00 00 00 00       	mov    $0x0,%eax
 804b814:	e9 16 02 00 00       	jmp    804ba2f <malloc_bytes+0x293>

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
 804b819:	c7 45 c4 10 00 00 00 	movl   $0x10,-0x3c(%ebp)
        l += sizeof bp->bits[0] *
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);
 804b820:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b823:	ba 00 10 00 00       	mov    $0x1000,%edx
 804b828:	89 d6                	mov    %edx,%esi
 804b82a:	89 c1                	mov    %eax,%ecx
 804b82c:	d3 ee                	shr    %cl,%esi
 804b82e:	89 f0                	mov    %esi,%eax
 804b830:	83 c0 1f             	add    $0x1f,%eax
 804b833:	c1 e8 05             	shr    $0x5,%eax
        if (!pp)
                return 0;

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
        l += sizeof bp->bits[0] *
 804b836:	c1 e0 02             	shl    $0x2,%eax
 804b839:	01 45 c4             	add    %eax,-0x3c(%ebp)
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);

        /* Don't waste more than two chunks on this */
        if ((1U << (bits)) <= l + l) {
 804b83c:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b83f:	ba 01 00 00 00       	mov    $0x1,%edx
 804b844:	89 c1                	mov    %eax,%ecx
 804b846:	d3 e2                	shl    %cl,%edx
 804b848:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b84b:	01 c0                	add    %eax,%eax
 804b84d:	39 c2                	cmp    %eax,%edx
 804b84f:	77 08                	ja     804b859 <malloc_bytes+0xbd>
                bp = (struct  pginfo *)pp;
 804b851:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804b854:	89 45 c0             	mov    %eax,-0x40(%ebp)
 804b857:	eb 29                	jmp    804b882 <malloc_bytes+0xe6>
        } else {
                bp = (struct  pginfo *)imalloc(l);
 804b859:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b85c:	89 04 24             	mov    %eax,(%esp)
 804b85f:	e8 ea 02 00 00       	call   804bb4e <imalloc>
 804b864:	89 45 c0             	mov    %eax,-0x40(%ebp)
                if (!bp) {
 804b867:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
 804b86b:	75 15                	jne    804b882 <malloc_bytes+0xe6>
                        ifree(pp);
 804b86d:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804b870:	89 04 24             	mov    %eax,(%esp)
 804b873:	e8 2a 0c 00 00       	call   804c4a2 <ifree>
                        return 0;
 804b878:	b8 00 00 00 00       	mov    $0x0,%eax
 804b87d:	e9 ad 01 00 00       	jmp    804ba2f <malloc_bytes+0x293>
                }
        }

        bp->size = (1 << bits);
 804b882:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b885:	ba 01 00 00 00       	mov    $0x1,%edx
 804b88a:	89 d6                	mov    %edx,%esi
 804b88c:	89 c1                	mov    %eax,%ecx
 804b88e:	d3 e6                	shl    %cl,%esi
 804b890:	89 f0                	mov    %esi,%eax
 804b892:	89 c2                	mov    %eax,%edx
 804b894:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b897:	66 89 50 08          	mov    %dx,0x8(%eax)
        bp->shift = bits;
 804b89b:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b89e:	89 c2                	mov    %eax,%edx
 804b8a0:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b8a3:	66 89 50 0a          	mov    %dx,0xa(%eax)
        bp->total = bp->free = malloc_pagesize >> bits;
 804b8a7:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b8aa:	ba 00 10 00 00       	mov    $0x1000,%edx
 804b8af:	89 d6                	mov    %edx,%esi
 804b8b1:	89 c1                	mov    %eax,%ecx
 804b8b3:	d3 ee                	shr    %cl,%esi
 804b8b5:	89 f0                	mov    %esi,%eax
 804b8b7:	89 c2                	mov    %eax,%edx
 804b8b9:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b8bc:	66 89 50 0c          	mov    %dx,0xc(%eax)
 804b8c0:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b8c3:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804b8c7:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b8ca:	66 89 50 0e          	mov    %dx,0xe(%eax)
        bp->page = pp;
 804b8ce:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b8d1:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804b8d4:	89 50 04             	mov    %edx,0x4(%eax)

        /* set all valid bits in the bitmap */
        k = bp->total;
 804b8d7:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b8da:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804b8de:	0f b7 c0             	movzwl %ax,%eax
 804b8e1:	89 45 bc             	mov    %eax,-0x44(%ebp)
        i = 0;
 804b8e4:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 804b8eb:	eb 19                	jmp    804b906 <malloc_bytes+0x16a>

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;
 804b8ed:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804b8f0:	89 c2                	mov    %eax,%edx
 804b8f2:	c1 ea 05             	shr    $0x5,%edx
 804b8f5:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b8f8:	83 c2 04             	add    $0x4,%edx
 804b8fb:	c7 04 90 ff ff ff ff 	movl   $0xffffffff,(%eax,%edx,4)
        /* set all valid bits in the bitmap */
        k = bp->total;
        i = 0;

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 804b902:	83 45 b8 20          	addl   $0x20,-0x48(%ebp)
 804b906:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804b909:	8b 55 bc             	mov    -0x44(%ebp),%edx
 804b90c:	89 d7                	mov    %edx,%edi
 804b90e:	29 c7                	sub    %eax,%edi
 804b910:	89 f8                	mov    %edi,%eax
 804b912:	83 f8 1f             	cmp    $0x1f,%eax
 804b915:	77 d6                	ja     804b8ed <malloc_bytes+0x151>
 804b917:	eb 36                	jmp    804b94f <malloc_bytes+0x1b3>
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804b919:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804b91c:	c1 e8 05             	shr    $0x5,%eax
 804b91f:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804b922:	8d 48 04             	lea    0x4(%eax),%ecx
 804b925:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 804b928:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804b92b:	83 e2 1f             	and    $0x1f,%edx
 804b92e:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
 804b935:	8b 7d b4             	mov    -0x4c(%ebp),%edi
 804b938:	89 d1                	mov    %edx,%ecx
 804b93a:	d3 e7                	shl    %cl,%edi
 804b93c:	89 fa                	mov    %edi,%edx
 804b93e:	89 f1                	mov    %esi,%ecx
 804b940:	09 d1                	or     %edx,%ecx
 804b942:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804b945:	83 c0 04             	add    $0x4,%eax
 804b948:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 804b94b:	83 45 b8 01          	addl   $0x1,-0x48(%ebp)
 804b94f:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b952:	3b 45 b8             	cmp    -0x48(%ebp),%eax
 804b955:	77 c2                	ja     804b919 <malloc_bytes+0x17d>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
 804b957:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b95a:	8b 40 04             	mov    0x4(%eax),%eax
 804b95d:	39 45 c0             	cmp    %eax,-0x40(%ebp)
 804b960:	75 7c                	jne    804b9de <malloc_bytes+0x242>
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804b962:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 804b969:	eb 6d                	jmp    804b9d8 <malloc_bytes+0x23c>
                        bp->bits[i / MALLOC_BITS] &= ~(1 << (i % MALLOC_BITS));
 804b96b:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804b96e:	c1 e8 05             	shr    $0x5,%eax
 804b971:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804b974:	8d 48 04             	lea    0x4(%eax),%ecx
 804b977:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 804b97a:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804b97d:	83 e2 1f             	and    $0x1f,%edx
 804b980:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
 804b987:	8b 7d b4             	mov    -0x4c(%ebp),%edi
 804b98a:	89 d1                	mov    %edx,%ecx
 804b98c:	d3 e7                	shl    %cl,%edi
 804b98e:	89 fa                	mov    %edi,%edx
 804b990:	f7 d2                	not    %edx
 804b992:	89 f1                	mov    %esi,%ecx
 804b994:	21 d1                	and    %edx,%ecx
 804b996:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804b999:	83 c0 04             	add    $0x4,%eax
 804b99c:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
                        bp->free--;
 804b99f:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b9a2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804b9a6:	8d 50 ff             	lea    -0x1(%eax),%edx
 804b9a9:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b9ac:	66 89 50 0c          	mov    %dx,0xc(%eax)
                        bp->total--;
 804b9b0:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b9b3:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804b9b7:	8d 50 ff             	lea    -0x1(%eax),%edx
 804b9ba:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b9bd:	66 89 50 0e          	mov    %dx,0xe(%eax)
                        l -= (1 << bits);
 804b9c1:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b9c4:	ba 01 00 00 00       	mov    $0x1,%edx
 804b9c9:	89 d6                	mov    %edx,%esi
 804b9cb:	89 c1                	mov    %eax,%ecx
 804b9cd:	d3 e6                	shl    %cl,%esi
 804b9cf:	89 f0                	mov    %esi,%eax
 804b9d1:	29 45 c4             	sub    %eax,-0x3c(%ebp)
        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804b9d4:	83 45 b8 01          	addl   $0x1,-0x48(%ebp)
 804b9d8:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
 804b9dc:	75 8d                	jne    804b96b <malloc_bytes+0x1cf>
                }
        }

        /* MALLOC_LOCK */

        page_dir[ptr2index(pp)] = bp;
 804b9de:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804b9e4:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804b9e7:	89 d1                	mov    %edx,%ecx
 804b9e9:	c1 e9 0c             	shr    $0xc,%ecx
 804b9ec:	8b 93 50 02 00 00    	mov    0x250(%ebx),%edx
 804b9f2:	89 cf                	mov    %ecx,%edi
 804b9f4:	29 d7                	sub    %edx,%edi
 804b9f6:	89 fa                	mov    %edi,%edx
 804b9f8:	c1 e2 02             	shl    $0x2,%edx
 804b9fb:	01 c2                	add    %eax,%edx
 804b9fd:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ba00:	89 02                	mov    %eax,(%edx)

        bp->next = page_dir[bits];
 804ba02:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804ba08:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804ba0b:	c1 e2 02             	shl    $0x2,%edx
 804ba0e:	01 d0                	add    %edx,%eax
 804ba10:	8b 10                	mov    (%eax),%edx
 804ba12:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ba15:	89 10                	mov    %edx,(%eax)
        page_dir[bits] = bp;
 804ba17:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804ba1d:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804ba20:	c1 e2 02             	shl    $0x2,%edx
 804ba23:	01 c2                	add    %eax,%edx
 804ba25:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ba28:	89 02                	mov    %eax,(%edx)

        /* MALLOC_UNLOCK */

        return 1;
 804ba2a:	b8 01 00 00 00       	mov    $0x1,%eax
        i = size - 1;
        while (i >>= 1)
                j++;

        /* If it's empty, make a page more of that size chunks */
        if (!page_dir[j] && !malloc_make_chunks(j))
 804ba2f:	85 c0                	test   %eax,%eax
 804ba31:	75 0a                	jne    804ba3d <malloc_bytes+0x2a1>
                return 0;
 804ba33:	b8 00 00 00 00       	mov    $0x0,%eax
 804ba38:	e9 09 01 00 00       	jmp    804bb46 <malloc_bytes+0x3aa>

        bp = page_dir[j];
 804ba3d:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804ba43:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804ba46:	c1 e2 02             	shl    $0x2,%edx
 804ba49:	01 d0                	add    %edx,%eax
 804ba4b:	8b 00                	mov    (%eax),%eax
 804ba4d:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /* Find first word of bitmap which isn't empty */
        for (lp = bp->bits; !*lp; lp++)
 804ba50:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804ba53:	83 c0 10             	add    $0x10,%eax
 804ba56:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804ba59:	eb 04                	jmp    804ba5f <malloc_bytes+0x2c3>
 804ba5b:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
 804ba5f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804ba62:	8b 00                	mov    (%eax),%eax
 804ba64:	85 c0                	test   %eax,%eax
 804ba66:	74 f3                	je     804ba5b <malloc_bytes+0x2bf>
                ;

        /* Find that bit, and tweak it */
        u = 1;
 804ba68:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        k = 0;
 804ba6f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
        while (!(*lp & u)) {
 804ba76:	eb 0c                	jmp    804ba84 <malloc_bytes+0x2e8>
                u += u;
 804ba78:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804ba7b:	01 c0                	add    %eax,%eax
 804ba7d:	89 45 dc             	mov    %eax,-0x24(%ebp)
                k++;
 804ba80:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
                ;

        /* Find that bit, and tweak it */
        u = 1;
        k = 0;
        while (!(*lp & u)) {
 804ba84:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804ba87:	8b 00                	mov    (%eax),%eax
 804ba89:	23 45 dc             	and    -0x24(%ebp),%eax
 804ba8c:	85 c0                	test   %eax,%eax
 804ba8e:	74 e8                	je     804ba78 <malloc_bytes+0x2dc>
                u += u;
                k++;
        }
        *lp ^= u;
 804ba90:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804ba93:	8b 00                	mov    (%eax),%eax
 804ba95:	89 c2                	mov    %eax,%edx
 804ba97:	33 55 dc             	xor    -0x24(%ebp),%edx
 804ba9a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804ba9d:	89 10                	mov    %edx,(%eax)

        /* If there are no more free, remove from free-list */
        if (!--bp->free) {
 804ba9f:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804baa2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804baa6:	8d 50 ff             	lea    -0x1(%eax),%edx
 804baa9:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804baac:	66 89 50 0c          	mov    %dx,0xc(%eax)
 804bab0:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804bab3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804bab7:	66 85 c0             	test   %ax,%ax
 804baba:	75 1e                	jne    804bada <malloc_bytes+0x33e>
                page_dir[j] = bp->next;
 804babc:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804bac2:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804bac5:	c1 e2 02             	shl    $0x2,%edx
 804bac8:	01 c2                	add    %eax,%edx
 804baca:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804bacd:	8b 00                	mov    (%eax),%eax
 804bacf:	89 02                	mov    %eax,(%edx)
                bp->next = 0;
 804bad1:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804bad4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        }

        /* Adjust to the real offset of that chunk */
        k += (lp - bp->bits) * MALLOC_BITS;
 804bada:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804badd:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804bae0:	83 c0 10             	add    $0x10,%eax
 804bae3:	89 d1                	mov    %edx,%ecx
 804bae5:	29 c1                	sub    %eax,%ecx
 804bae7:	89 c8                	mov    %ecx,%eax
 804bae9:	c1 f8 02             	sar    $0x2,%eax
 804baec:	89 c2                	mov    %eax,%edx
 804baee:	c1 e2 05             	shl    $0x5,%edx
 804baf1:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804baf4:	01 d0                	add    %edx,%eax
 804baf6:	89 45 d8             	mov    %eax,-0x28(%ebp)
        k <<= bp->shift;
 804baf9:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804bafc:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804bb00:	0f b7 c0             	movzwl %ax,%eax
 804bb03:	89 c1                	mov    %eax,%ecx
 804bb05:	d3 65 d8             	shll   %cl,-0x28(%ebp)

        if (malloc_junk)
 804bb08:	8b 83 90 02 00 00    	mov    0x290(%ebx),%eax
 804bb0e:	85 c0                	test   %eax,%eax
 804bb10:	74 29                	je     804bb3b <malloc_bytes+0x39f>
                memset((u_char *)bp->page + k, SOME_JUNK, bp->size);
 804bb12:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804bb15:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804bb19:	0f b7 c0             	movzwl %ax,%eax
 804bb1c:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804bb1f:	8b 4a 04             	mov    0x4(%edx),%ecx
 804bb22:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804bb25:	01 ca                	add    %ecx,%edx
 804bb27:	89 44 24 08          	mov    %eax,0x8(%esp)
 804bb2b:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804bb32:	00 
 804bb33:	89 14 24             	mov    %edx,(%esp)
 804bb36:	e8 89 cb ff ff       	call   80486c4 <memset>

        return (u_char *)bp->page + k;
 804bb3b:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804bb3e:	8b 50 04             	mov    0x4(%eax),%edx
 804bb41:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804bb44:	01 d0                	add    %edx,%eax
}
 804bb46:	83 c4 5c             	add    $0x5c,%esp
 804bb49:	5b                   	pop    %ebx
 804bb4a:	5e                   	pop    %esi
 804bb4b:	5f                   	pop    %edi
 804bb4c:	5d                   	pop    %ebp
 804bb4d:	c3                   	ret    

0804bb4e <imalloc>:
/*
 * Allocate a piece of memory
 */
static void *
imalloc(size_t size)
{
 804bb4e:	55                   	push   %ebp
 804bb4f:	89 e5                	mov    %esp,%ebp
 804bb51:	53                   	push   %ebx
 804bb52:	83 ec 24             	sub    $0x24,%esp
 804bb55:	e8 c7 c9 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804bb5a:	81 c3 26 46 00 00    	add    $0x4626,%ebx
        void *result;

        if (suicide)
 804bb60:	8b 83 78 02 00 00    	mov    0x278(%ebx),%eax
 804bb66:	85 c0                	test   %eax,%eax
 804bb68:	74 0c                	je     804bb76 <imalloc+0x28>
                abort();
 804bb6a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804bb71:	e8 ea d7 ff ff       	call   8049360 <exit>

        if ((size + malloc_pagesize) < size)        /* Check for overflow */
 804bb76:	8b 45 08             	mov    0x8(%ebp),%eax
 804bb79:	05 00 10 00 00       	add    $0x1000,%eax
 804bb7e:	3b 45 08             	cmp    0x8(%ebp),%eax
 804bb81:	73 09                	jae    804bb8c <imalloc+0x3e>
                result = 0;
 804bb83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804bb8a:	eb 27                	jmp    804bbb3 <imalloc+0x65>
        else if (size <= malloc_maxsize)
 804bb8c:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
 804bb93:	77 10                	ja     804bba5 <imalloc+0x57>
                result =  malloc_bytes(size);
 804bb95:	8b 45 08             	mov    0x8(%ebp),%eax
 804bb98:	89 04 24             	mov    %eax,(%esp)
 804bb9b:	e8 fc fb ff ff       	call   804b79c <malloc_bytes>
 804bba0:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804bba3:	eb 0e                	jmp    804bbb3 <imalloc+0x65>
        else
                result =  malloc_pages(size);
 804bba5:	8b 45 08             	mov    0x8(%ebp),%eax
 804bba8:	89 04 24             	mov    %eax,(%esp)
 804bbab:	e8 00 f8 ff ff       	call   804b3b0 <malloc_pages>
 804bbb0:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (malloc_abort && !result)
 804bbb3:	8b 83 74 02 00 00    	mov    0x274(%ebx),%eax
 804bbb9:	85 c0                	test   %eax,%eax
 804bbbb:	74 14                	je     804bbd1 <imalloc+0x83>
 804bbbd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804bbc1:	75 0e                	jne    804bbd1 <imalloc+0x83>
                wrterror("allocation failed.\n");
 804bbc3:	8d 83 ee e0 ff ff    	lea    -0x1f12(%ebx),%eax
 804bbc9:	89 04 24             	mov    %eax,(%esp)
 804bbcc:	e8 df f0 ff ff       	call   804acb0 <wrterror>

        if (malloc_zero && result)
 804bbd1:	8b 83 8c 02 00 00    	mov    0x28c(%ebx),%eax
 804bbd7:	85 c0                	test   %eax,%eax
 804bbd9:	74 20                	je     804bbfb <imalloc+0xad>
 804bbdb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804bbdf:	74 1a                	je     804bbfb <imalloc+0xad>
                memset(result, 0, size);
 804bbe1:	8b 45 08             	mov    0x8(%ebp),%eax
 804bbe4:	89 44 24 08          	mov    %eax,0x8(%esp)
 804bbe8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804bbef:	00 
 804bbf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bbf3:	89 04 24             	mov    %eax,(%esp)
 804bbf6:	e8 c9 ca ff ff       	call   80486c4 <memset>

        return result;
 804bbfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804bbfe:	83 c4 24             	add    $0x24,%esp
 804bc01:	5b                   	pop    %ebx
 804bc02:	5d                   	pop    %ebp
 804bc03:	c3                   	ret    

0804bc04 <irealloc>:
/*
 * Change the size of an allocation.
 */
static void *
irealloc(void *ptr, size_t size)
{
 804bc04:	55                   	push   %ebp
 804bc05:	89 e5                	mov    %esp,%ebp
 804bc07:	57                   	push   %edi
 804bc08:	56                   	push   %esi
 804bc09:	53                   	push   %ebx
 804bc0a:	83 ec 3c             	sub    $0x3c,%esp
 804bc0d:	e8 0f c9 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804bc12:	81 c3 6e 45 00 00    	add    $0x456e,%ebx
        void *p;
        u_long osize, index;
        struct pginfo **mp;
        int i;

        if (suicide)
 804bc18:	8b 83 78 02 00 00    	mov    0x278(%ebx),%eax
 804bc1e:	85 c0                	test   %eax,%eax
 804bc20:	74 0c                	je     804bc2e <irealloc+0x2a>
                abort();
 804bc22:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804bc29:	e8 32 d7 ff ff       	call   8049360 <exit>

        index = ptr2index(ptr);
 804bc2e:	8b 45 08             	mov    0x8(%ebp),%eax
 804bc31:	89 c2                	mov    %eax,%edx
 804bc33:	c1 ea 0c             	shr    $0xc,%edx
 804bc36:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804bc3c:	89 d1                	mov    %edx,%ecx
 804bc3e:	29 c1                	sub    %eax,%ecx
 804bc40:	89 c8                	mov    %ecx,%eax
 804bc42:	89 45 dc             	mov    %eax,-0x24(%ebp)

        if (index < malloc_pageshift) {
 804bc45:	83 7d dc 0b          	cmpl   $0xb,-0x24(%ebp)
 804bc49:	77 18                	ja     804bc63 <irealloc+0x5f>
                wrtwarning("junk pointer, too low to make sense.\n");
 804bc4b:	8d 83 04 e1 ff ff    	lea    -0x1efc(%ebx),%eax
 804bc51:	89 04 24             	mov    %eax,(%esp)
 804bc54:	e8 22 f1 ff ff       	call   804ad7b <wrtwarning>
                return 0;
 804bc59:	b8 00 00 00 00       	mov    $0x0,%eax
 804bc5e:	e9 0c 02 00 00       	jmp    804be6f <irealloc+0x26b>
        }

        if (index > last_index) {
 804bc63:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804bc69:	39 45 dc             	cmp    %eax,-0x24(%ebp)
 804bc6c:	76 18                	jbe    804bc86 <irealloc+0x82>
                wrtwarning("junk pointer, too high to make sense.\n");
 804bc6e:	8d 83 2c e1 ff ff    	lea    -0x1ed4(%ebx),%eax
 804bc74:	89 04 24             	mov    %eax,(%esp)
 804bc77:	e8 ff f0 ff ff       	call   804ad7b <wrtwarning>
                return 0;
 804bc7c:	b8 00 00 00 00       	mov    $0x0,%eax
 804bc81:	e9 e9 01 00 00       	jmp    804be6f <irealloc+0x26b>
        }

        mp = &page_dir[index];
 804bc86:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804bc8c:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804bc8f:	c1 e2 02             	shl    $0x2,%edx
 804bc92:	01 d0                	add    %edx,%eax
 804bc94:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if (*mp == MALLOC_FIRST) {                  /* Page allocation */
 804bc97:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bc9a:	8b 00                	mov    (%eax),%eax
 804bc9c:	83 f8 02             	cmp    $0x2,%eax
 804bc9f:	75 75                	jne    804bd16 <irealloc+0x112>

                /* Check the pointer */
                if ((u_long)ptr & malloc_pagemask) {
 804bca1:	8b 45 08             	mov    0x8(%ebp),%eax
 804bca4:	25 ff 0f 00 00       	and    $0xfff,%eax
 804bca9:	85 c0                	test   %eax,%eax
 804bcab:	74 18                	je     804bcc5 <irealloc+0xc1>
                        wrtwarning("modified (page-) pointer.\n");
 804bcad:	8d 83 53 e1 ff ff    	lea    -0x1ead(%ebx),%eax
 804bcb3:	89 04 24             	mov    %eax,(%esp)
 804bcb6:	e8 c0 f0 ff ff       	call   804ad7b <wrtwarning>
                        return 0;
 804bcbb:	b8 00 00 00 00       	mov    $0x0,%eax
 804bcc0:	e9 aa 01 00 00       	jmp    804be6f <irealloc+0x26b>
                }

                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
 804bcc5:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
 804bccc:	eb 07                	jmp    804bcd5 <irealloc+0xd1>
                        osize += malloc_pagesize;
 804bcce:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
                        wrtwarning("modified (page-) pointer.\n");
                        return 0;
                }

                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
 804bcd5:	83 45 e0 04          	addl   $0x4,-0x20(%ebp)
 804bcd9:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bcdc:	8b 00                	mov    (%eax),%eax
 804bcde:	83 f8 03             	cmp    $0x3,%eax
 804bce1:	74 eb                	je     804bcce <irealloc+0xca>
                        osize += malloc_pagesize;

                if (!malloc_realloc &&                  /* unless we have to, */
 804bce3:	8b 83 7c 02 00 00    	mov    0x27c(%ebx),%eax
 804bce9:	85 c0                	test   %eax,%eax
 804bceb:	0f 85 14 01 00 00    	jne    804be05 <irealloc+0x201>
 804bcf1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bcf4:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804bcf7:	0f 87 08 01 00 00    	ja     804be05 <irealloc+0x201>
                    size <= osize &&                      /* .. or are too small, */
                    size > (osize - malloc_pagesize)) {   /* .. or can free a page, */
 804bcfd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804bd00:	2d 00 10 00 00       	sub    $0x1000,%eax
                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
                        osize += malloc_pagesize;

                if (!malloc_realloc &&                  /* unless we have to, */
                    size <= osize &&                      /* .. or are too small, */
 804bd05:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804bd08:	0f 83 f7 00 00 00    	jae    804be05 <irealloc+0x201>
                    size > (osize - malloc_pagesize)) {   /* .. or can free a page, */
                        return ptr;                         /* don't do anything. */
 804bd0e:	8b 45 08             	mov    0x8(%ebp),%eax
 804bd11:	e9 59 01 00 00       	jmp    804be6f <irealloc+0x26b>
                }

        } else if (*mp >= MALLOC_MAGIC) {           /* Chunk allocation */
 804bd16:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bd19:	8b 00                	mov    (%eax),%eax
 804bd1b:	83 f8 03             	cmp    $0x3,%eax
 804bd1e:	0f 86 cc 00 00 00    	jbe    804bdf0 <irealloc+0x1ec>

                /* Check the pointer for sane values */
                if (((u_long)ptr & ((*mp)->size - 1))) {
 804bd24:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bd27:	8b 00                	mov    (%eax),%eax
 804bd29:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804bd2d:	0f b7 c0             	movzwl %ax,%eax
 804bd30:	83 e8 01             	sub    $0x1,%eax
 804bd33:	89 c2                	mov    %eax,%edx
 804bd35:	8b 45 08             	mov    0x8(%ebp),%eax
 804bd38:	21 d0                	and    %edx,%eax
 804bd3a:	85 c0                	test   %eax,%eax
 804bd3c:	74 18                	je     804bd56 <irealloc+0x152>
                        wrtwarning("modified (chunk-) pointer.\n");
 804bd3e:	8d 83 6e e1 ff ff    	lea    -0x1e92(%ebx),%eax
 804bd44:	89 04 24             	mov    %eax,(%esp)
 804bd47:	e8 2f f0 ff ff       	call   804ad7b <wrtwarning>
                        return 0;
 804bd4c:	b8 00 00 00 00       	mov    $0x0,%eax
 804bd51:	e9 19 01 00 00       	jmp    804be6f <irealloc+0x26b>
                }

                /* Find the chunk index in the page */
                i = ((u_long)ptr & malloc_pagemask) >> (*mp)->shift;
 804bd56:	8b 45 08             	mov    0x8(%ebp),%eax
 804bd59:	89 c2                	mov    %eax,%edx
 804bd5b:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
 804bd61:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bd64:	8b 00                	mov    (%eax),%eax
 804bd66:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804bd6a:	0f b7 c0             	movzwl %ax,%eax
 804bd6d:	89 d6                	mov    %edx,%esi
 804bd6f:	89 c1                	mov    %eax,%ecx
 804bd71:	d3 ee                	shr    %cl,%esi
 804bd73:	89 f0                	mov    %esi,%eax
 804bd75:	89 45 d8             	mov    %eax,-0x28(%ebp)

                /* Verify that it isn't a free chunk already */
                if ((*mp)->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804bd78:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bd7b:	8b 00                	mov    (%eax),%eax
 804bd7d:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804bd80:	c1 ea 05             	shr    $0x5,%edx
 804bd83:	83 c2 04             	add    $0x4,%edx
 804bd86:	8b 14 90             	mov    (%eax,%edx,4),%edx
 804bd89:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804bd8c:	83 e0 1f             	and    $0x1f,%eax
 804bd8f:	be 01 00 00 00       	mov    $0x1,%esi
 804bd94:	89 f7                	mov    %esi,%edi
 804bd96:	89 c1                	mov    %eax,%ecx
 804bd98:	d3 e7                	shl    %cl,%edi
 804bd9a:	89 f8                	mov    %edi,%eax
 804bd9c:	21 d0                	and    %edx,%eax
 804bd9e:	85 c0                	test   %eax,%eax
 804bda0:	74 18                	je     804bdba <irealloc+0x1b6>
                        wrtwarning("chunk is already free.\n");
 804bda2:	8d 83 8a e1 ff ff    	lea    -0x1e76(%ebx),%eax
 804bda8:	89 04 24             	mov    %eax,(%esp)
 804bdab:	e8 cb ef ff ff       	call   804ad7b <wrtwarning>
                        return 0;
 804bdb0:	b8 00 00 00 00       	mov    $0x0,%eax
 804bdb5:	e9 b5 00 00 00       	jmp    804be6f <irealloc+0x26b>
                }

                osize = (*mp)->size;
 804bdba:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bdbd:	8b 00                	mov    (%eax),%eax
 804bdbf:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804bdc3:	0f b7 c0             	movzwl %ax,%eax
 804bdc6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

                if (!malloc_realloc &&          /* Unless we have to, */
 804bdc9:	8b 83 7c 02 00 00    	mov    0x27c(%ebx),%eax
 804bdcf:	85 c0                	test   %eax,%eax
 804bdd1:	75 32                	jne    804be05 <irealloc+0x201>
 804bdd3:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bdd6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804bdd9:	73 2a                	jae    804be05 <irealloc+0x201>
                    size < osize &&               /* ..or are too small, */
                    (size > osize / 2 ||          /* ..or could use a smaller size, */
 804bddb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804bdde:	d1 e8                	shr    %eax
                }

                osize = (*mp)->size;

                if (!malloc_realloc &&          /* Unless we have to, */
                    size < osize &&               /* ..or are too small, */
 804bde0:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804bde3:	72 06                	jb     804bdeb <irealloc+0x1e7>
                    (size > osize / 2 ||          /* ..or could use a smaller size, */
 804bde5:	83 7d e4 10          	cmpl   $0x10,-0x1c(%ebp)
 804bde9:	75 1a                	jne    804be05 <irealloc+0x201>
                     osize == malloc_minsize)) {   /* ..(if there is one) */
                        return ptr;                 /* ..Don't do anything */
 804bdeb:	8b 45 08             	mov    0x8(%ebp),%eax
 804bdee:	eb 7f                	jmp    804be6f <irealloc+0x26b>
                }

        } else {
                wrtwarning("pointer to wrong page.\n");
 804bdf0:	8d 83 a2 e1 ff ff    	lea    -0x1e5e(%ebx),%eax
 804bdf6:	89 04 24             	mov    %eax,(%esp)
 804bdf9:	e8 7d ef ff ff       	call   804ad7b <wrtwarning>
                return 0;
 804bdfe:	b8 00 00 00 00       	mov    $0x0,%eax
 804be03:	eb 6a                	jmp    804be6f <irealloc+0x26b>
        }

        p = imalloc(size);
 804be05:	8b 45 0c             	mov    0xc(%ebp),%eax
 804be08:	89 04 24             	mov    %eax,(%esp)
 804be0b:	e8 3e fd ff ff       	call   804bb4e <imalloc>
 804be10:	89 45 d4             	mov    %eax,-0x2c(%ebp)

        if (p) {
 804be13:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804be17:	74 53                	je     804be6c <irealloc+0x268>
                /* copy the lesser of the two sizes, and free the old one */
                if (!size || !osize)
 804be19:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804be1d:	74 42                	je     804be61 <irealloc+0x25d>
 804be1f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804be23:	74 3c                	je     804be61 <irealloc+0x25d>
                        ;
                else if (osize < size)
 804be25:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804be28:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804be2b:	73 1b                	jae    804be48 <irealloc+0x244>
                        memcpy(p, ptr, osize);
 804be2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804be30:	89 44 24 08          	mov    %eax,0x8(%esp)
 804be34:	8b 45 08             	mov    0x8(%ebp),%eax
 804be37:	89 44 24 04          	mov    %eax,0x4(%esp)
 804be3b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804be3e:	89 04 24             	mov    %eax,(%esp)
 804be41:	e8 30 c7 ff ff       	call   8048576 <memcpy>
 804be46:	eb 19                	jmp    804be61 <irealloc+0x25d>
                else
                        memcpy(p, ptr, size);
 804be48:	8b 45 0c             	mov    0xc(%ebp),%eax
 804be4b:	89 44 24 08          	mov    %eax,0x8(%esp)
 804be4f:	8b 45 08             	mov    0x8(%ebp),%eax
 804be52:	89 44 24 04          	mov    %eax,0x4(%esp)
 804be56:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804be59:	89 04 24             	mov    %eax,(%esp)
 804be5c:	e8 15 c7 ff ff       	call   8048576 <memcpy>
                ifree(ptr);
 804be61:	8b 45 08             	mov    0x8(%ebp),%eax
 804be64:	89 04 24             	mov    %eax,(%esp)
 804be67:	e8 36 06 00 00       	call   804c4a2 <ifree>
        }
        return p;
 804be6c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
}
 804be6f:	83 c4 3c             	add    $0x3c,%esp
 804be72:	5b                   	pop    %ebx
 804be73:	5e                   	pop    %esi
 804be74:	5f                   	pop    %edi
 804be75:	5d                   	pop    %ebp
 804be76:	c3                   	ret    

0804be77 <free_pages>:
 * Free a sequence of pages
 */

static __inline__ void
free_pages(void *ptr, int index, struct pginfo *info)
{
 804be77:	55                   	push   %ebp
 804be78:	89 e5                	mov    %esp,%ebp
 804be7a:	53                   	push   %ebx
 804be7b:	83 ec 34             	sub    $0x34,%esp
 804be7e:	e8 9e c6 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804be83:	81 c3 fd 42 00 00    	add    $0x42fd,%ebx
        unsigned int i;
        struct pgfree *pf, *pt = 0;
 804be89:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
        u_long l;
        void *tail;

        if (info == MALLOC_FREE) {
 804be90:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
 804be94:	75 13                	jne    804bea9 <free_pages+0x32>
                wrtwarning("page is already free.\n");
 804be96:	8d 83 ba e1 ff ff    	lea    -0x1e46(%ebx),%eax
 804be9c:	89 04 24             	mov    %eax,(%esp)
 804be9f:	e8 d7 ee ff ff       	call   804ad7b <wrtwarning>
                return;
 804bea4:	e9 d8 03 00 00       	jmp    804c281 <free_pages+0x40a>
        }

        if (info != MALLOC_FIRST) {
 804bea9:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
 804bead:	74 13                	je     804bec2 <free_pages+0x4b>
                wrtwarning("pointer to wrong page.\n");
 804beaf:	8d 83 a2 e1 ff ff    	lea    -0x1e5e(%ebx),%eax
 804beb5:	89 04 24             	mov    %eax,(%esp)
 804beb8:	e8 be ee ff ff       	call   804ad7b <wrtwarning>
                return;
 804bebd:	e9 bf 03 00 00       	jmp    804c281 <free_pages+0x40a>
        }

        if ((u_long)ptr & malloc_pagemask) {
 804bec2:	8b 45 08             	mov    0x8(%ebp),%eax
 804bec5:	25 ff 0f 00 00       	and    $0xfff,%eax
 804beca:	85 c0                	test   %eax,%eax
 804becc:	74 13                	je     804bee1 <free_pages+0x6a>
                wrtwarning("modified (page-) pointer.\n");
 804bece:	8d 83 53 e1 ff ff    	lea    -0x1ead(%ebx),%eax
 804bed4:	89 04 24             	mov    %eax,(%esp)
 804bed7:	e8 9f ee ff ff       	call   804ad7b <wrtwarning>
                return;
 804bedc:	e9 a0 03 00 00       	jmp    804c281 <free_pages+0x40a>
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
 804bee1:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804bee7:	8b 55 0c             	mov    0xc(%ebp),%edx
 804beea:	c1 e2 02             	shl    $0x2,%edx
 804beed:	01 d0                	add    %edx,%eax
 804beef:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804bef5:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
 804befc:	eb 1b                	jmp    804bf19 <free_pages+0xa2>
                page_dir[index + i] = MALLOC_FREE;
 804befe:	8b 93 58 02 00 00    	mov    0x258(%ebx),%edx
 804bf04:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bf07:	03 45 f4             	add    -0xc(%ebp),%eax
 804bf0a:	c1 e0 02             	shl    $0x2,%eax
 804bf0d:	01 d0                	add    %edx,%eax
 804bf0f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804bf15:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 804bf19:	8b 93 58 02 00 00    	mov    0x258(%ebx),%edx
 804bf1f:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bf22:	03 45 f4             	add    -0xc(%ebp),%eax
 804bf25:	c1 e0 02             	shl    $0x2,%eax
 804bf28:	01 d0                	add    %edx,%eax
 804bf2a:	8b 00                	mov    (%eax),%eax
 804bf2c:	83 f8 03             	cmp    $0x3,%eax
 804bf2f:	74 cd                	je     804befe <free_pages+0x87>
                page_dir[index + i] = MALLOC_FREE;

        l = i << malloc_pageshift;
 804bf31:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bf34:	c1 e0 0c             	shl    $0xc,%eax
 804bf37:	89 45 e8             	mov    %eax,-0x18(%ebp)

        if (malloc_junk)
 804bf3a:	8b 83 90 02 00 00    	mov    0x290(%ebx),%eax
 804bf40:	85 c0                	test   %eax,%eax
 804bf42:	74 1a                	je     804bf5e <free_pages+0xe7>
                memset(ptr, SOME_JUNK, l);
 804bf44:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804bf47:	89 44 24 08          	mov    %eax,0x8(%esp)
 804bf4b:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804bf52:	00 
 804bf53:	8b 45 08             	mov    0x8(%ebp),%eax
 804bf56:	89 04 24             	mov    %eax,(%esp)
 804bf59:	e8 66 c7 ff ff       	call   80486c4 <memset>
#ifdef HAS_MADVISE
        if (malloc_hint)
                madvise(ptr, l, MADV_FREE);
#endif

        tail = (char *)ptr + l;
 804bf5e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804bf61:	8b 55 08             	mov    0x8(%ebp),%edx
 804bf64:	01 d0                	add    %edx,%eax
 804bf66:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        /* add to free-list */
        if (!px)
 804bf69:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804bf6f:	85 c0                	test   %eax,%eax
 804bf71:	75 12                	jne    804bf85 <free_pages+0x10e>
                px = imalloc(sizeof * pt);      /* This cannot fail... */
 804bf73:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 804bf7a:	e8 cf fb ff ff       	call   804bb4e <imalloc>
 804bf7f:	89 83 98 02 00 00    	mov    %eax,0x298(%ebx)
        px->page = ptr;
 804bf85:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804bf8b:	8b 55 08             	mov    0x8(%ebp),%edx
 804bf8e:	89 50 08             	mov    %edx,0x8(%eax)
        px->end =  tail;
 804bf91:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804bf97:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804bf9a:	89 50 0c             	mov    %edx,0xc(%eax)
        px->size = l;
 804bf9d:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804bfa3:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804bfa6:	89 50 10             	mov    %edx,0x10(%eax)
        if (!free_list.next) {
 804bfa9:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 804bfaf:	85 c0                	test   %eax,%eax
 804bfb1:	75 41                	jne    804bff4 <free_pages+0x17d>

                /* Nothing on free list, put this at head */
                px->next = free_list.next;
 804bfb3:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804bfb9:	8b 93 60 02 00 00    	mov    0x260(%ebx),%edx
 804bfbf:	89 10                	mov    %edx,(%eax)
                px->prev = &free_list;
 804bfc1:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804bfc7:	8d 93 60 02 00 00    	lea    0x260(%ebx),%edx
 804bfcd:	89 50 04             	mov    %edx,0x4(%eax)
                free_list.next = px;
 804bfd0:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804bfd6:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
                pf = px;
 804bfdc:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804bfe2:	89 45 f0             	mov    %eax,-0x10(%ebp)
                px = 0;
 804bfe5:	c7 83 98 02 00 00 00 	movl   $0x0,0x298(%ebx)
 804bfec:	00 00 00 
 804bfef:	e9 a2 01 00 00       	jmp    804c196 <free_pages+0x31f>

        } else {

                /* Find the right spot, leave pf pointing to the modified entry. */
                tail = (char *)ptr + l;
 804bff4:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804bff7:	8b 55 08             	mov    0x8(%ebp),%edx
 804bffa:	01 d0                	add    %edx,%eax
 804bffc:	89 45 e4             	mov    %eax,-0x1c(%ebp)

                for (pf = free_list.next; pf->end < ptr && pf->next; pf = pf->next)
 804bfff:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 804c005:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c008:	eb 08                	jmp    804c012 <free_pages+0x19b>
 804c00a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c00d:	8b 00                	mov    (%eax),%eax
 804c00f:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c012:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c015:	8b 40 0c             	mov    0xc(%eax),%eax
 804c018:	3b 45 08             	cmp    0x8(%ebp),%eax
 804c01b:	73 09                	jae    804c026 <free_pages+0x1af>
 804c01d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c020:	8b 00                	mov    (%eax),%eax
 804c022:	85 c0                	test   %eax,%eax
 804c024:	75 e4                	jne    804c00a <free_pages+0x193>
                        ; /* Race ahead here */

                if (pf->page > tail) {
 804c026:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c029:	8b 40 08             	mov    0x8(%eax),%eax
 804c02c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804c02f:	76 4f                	jbe    804c080 <free_pages+0x209>
                        /* Insert before entry */
                        px->next = pf;
 804c031:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c037:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804c03a:	89 10                	mov    %edx,(%eax)
                        px->prev = pf->prev;
 804c03c:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c042:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804c045:	8b 52 04             	mov    0x4(%edx),%edx
 804c048:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev = px;
 804c04b:	8b 93 98 02 00 00    	mov    0x298(%ebx),%edx
 804c051:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c054:	89 50 04             	mov    %edx,0x4(%eax)
                        px->prev->next = px;
 804c057:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c05d:	8b 40 04             	mov    0x4(%eax),%eax
 804c060:	8b 93 98 02 00 00    	mov    0x298(%ebx),%edx
 804c066:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804c068:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c06e:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        px = 0;
 804c071:	c7 83 98 02 00 00 00 	movl   $0x0,0x298(%ebx)
 804c078:	00 00 00 
 804c07b:	e9 16 01 00 00       	jmp    804c196 <free_pages+0x31f>
                } else if (pf->end == ptr) {
 804c080:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c083:	8b 40 0c             	mov    0xc(%eax),%eax
 804c086:	3b 45 08             	cmp    0x8(%ebp),%eax
 804c089:	0f 85 91 00 00 00    	jne    804c120 <free_pages+0x2a9>
                        /* Append to the previous entry */
                        pf->end = (char *)pf->end + l;
 804c08f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c092:	8b 40 0c             	mov    0xc(%eax),%eax
 804c095:	89 c2                	mov    %eax,%edx
 804c097:	03 55 e8             	add    -0x18(%ebp),%edx
 804c09a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c09d:	89 50 0c             	mov    %edx,0xc(%eax)
                        pf->size += l;
 804c0a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c0a3:	8b 40 10             	mov    0x10(%eax),%eax
 804c0a6:	89 c2                	mov    %eax,%edx
 804c0a8:	03 55 e8             	add    -0x18(%ebp),%edx
 804c0ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c0ae:	89 50 10             	mov    %edx,0x10(%eax)
                        if (pf->next && pf->end == pf->next->page) {
 804c0b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c0b4:	8b 00                	mov    (%eax),%eax
 804c0b6:	85 c0                	test   %eax,%eax
 804c0b8:	0f 84 d8 00 00 00    	je     804c196 <free_pages+0x31f>
 804c0be:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c0c1:	8b 50 0c             	mov    0xc(%eax),%edx
 804c0c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c0c7:	8b 00                	mov    (%eax),%eax
 804c0c9:	8b 40 08             	mov    0x8(%eax),%eax
 804c0cc:	39 c2                	cmp    %eax,%edx
 804c0ce:	0f 85 c2 00 00 00    	jne    804c196 <free_pages+0x31f>
                                /* And collapse the next too. */
                                pt = pf->next;
 804c0d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c0d7:	8b 00                	mov    (%eax),%eax
 804c0d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
                                pf->end = pt->end;
 804c0dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c0df:	8b 50 0c             	mov    0xc(%eax),%edx
 804c0e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c0e5:	89 50 0c             	mov    %edx,0xc(%eax)
                                pf->size += pt->size;
 804c0e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c0eb:	8b 50 10             	mov    0x10(%eax),%edx
 804c0ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c0f1:	8b 40 10             	mov    0x10(%eax),%eax
 804c0f4:	01 c2                	add    %eax,%edx
 804c0f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c0f9:	89 50 10             	mov    %edx,0x10(%eax)
                                pf->next = pt->next;
 804c0fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c0ff:	8b 10                	mov    (%eax),%edx
 804c101:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c104:	89 10                	mov    %edx,(%eax)
                                if (pf->next)
 804c106:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c109:	8b 00                	mov    (%eax),%eax
 804c10b:	85 c0                	test   %eax,%eax
 804c10d:	0f 84 83 00 00 00    	je     804c196 <free_pages+0x31f>
                                        pf->next->prev = pf;
 804c113:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c116:	8b 00                	mov    (%eax),%eax
 804c118:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804c11b:	89 50 04             	mov    %edx,0x4(%eax)
 804c11e:	eb 76                	jmp    804c196 <free_pages+0x31f>
                        }
                } else if (pf->page == tail) {
 804c120:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c123:	8b 40 08             	mov    0x8(%eax),%eax
 804c126:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804c129:	75 1c                	jne    804c147 <free_pages+0x2d0>
                        /* Prepend to entry */
                        pf->size += l;
 804c12b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c12e:	8b 40 10             	mov    0x10(%eax),%eax
 804c131:	89 c2                	mov    %eax,%edx
 804c133:	03 55 e8             	add    -0x18(%ebp),%edx
 804c136:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c139:	89 50 10             	mov    %edx,0x10(%eax)
                        pf->page = ptr;
 804c13c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c13f:	8b 55 08             	mov    0x8(%ebp),%edx
 804c142:	89 50 08             	mov    %edx,0x8(%eax)
 804c145:	eb 4f                	jmp    804c196 <free_pages+0x31f>
                } else if (!pf->next) {
 804c147:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c14a:	8b 00                	mov    (%eax),%eax
 804c14c:	85 c0                	test   %eax,%eax
 804c14e:	75 38                	jne    804c188 <free_pages+0x311>
                        /* Append at tail of chain */
                        px->next = 0;
 804c150:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c156:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                        px->prev = pf;
 804c15c:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c162:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804c165:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->next = px;
 804c168:	8b 93 98 02 00 00    	mov    0x298(%ebx),%edx
 804c16e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c171:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804c173:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c179:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        px = 0;
 804c17c:	c7 83 98 02 00 00 00 	movl   $0x0,0x298(%ebx)
 804c183:	00 00 00 
 804c186:	eb 0e                	jmp    804c196 <free_pages+0x31f>
                } else {
                        wrterror("freelist is destroyed.\n");
 804c188:	8d 83 d1 e1 ff ff    	lea    -0x1e2f(%ebx),%eax
 804c18e:	89 04 24             	mov    %eax,(%esp)
 804c191:	e8 1a eb ff ff       	call   804acb0 <wrterror>
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804c196:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c199:	8b 00                	mov    (%eax),%eax
 804c19b:	85 c0                	test   %eax,%eax
 804c19d:	0f 85 cd 00 00 00    	jne    804c270 <free_pages+0x3f9>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804c1a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c1a6:	8b 50 10             	mov    0x10(%eax),%edx
 804c1a9:	8b 83 60 01 00 00    	mov    0x160(%ebx),%eax
                        wrterror("freelist is destroyed.\n");
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804c1af:	39 c2                	cmp    %eax,%edx
 804c1b1:	0f 86 b9 00 00 00    	jbe    804c270 <free_pages+0x3f9>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804c1b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c1ba:	8b 50 0c             	mov    0xc(%eax),%edx
 804c1bd:	8b 83 94 02 00 00    	mov    0x294(%ebx),%eax
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804c1c3:	39 c2                	cmp    %eax,%edx
 804c1c5:	0f 85 a5 00 00 00    	jne    804c270 <free_pages+0x3f9>
            pf->end == malloc_brk &&                  /* ..and none behind us, */
            malloc_brk == sbrk(0)) {                  /* ..and it's OK to do... */
 804c1cb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804c1d2:	e8 61 cf ff ff       	call   8049138 <sbrk>
 804c1d7:	8b 93 94 02 00 00    	mov    0x294(%ebx),%edx
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804c1dd:	39 d0                	cmp    %edx,%eax
 804c1df:	0f 85 8b 00 00 00    	jne    804c270 <free_pages+0x3f9>

                /*
                 * Keep the cache intact.  Notice that the '>' above guarantees that
                 * the pf will always have at least one page afterwards.
                 */
                pf->end = (char *)pf->page + malloc_cache;
 804c1e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c1e8:	8b 50 08             	mov    0x8(%eax),%edx
 804c1eb:	8b 83 60 01 00 00    	mov    0x160(%ebx),%eax
 804c1f1:	01 c2                	add    %eax,%edx
 804c1f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c1f6:	89 50 0c             	mov    %edx,0xc(%eax)
                pf->size = malloc_cache;
 804c1f9:	8b 93 60 01 00 00    	mov    0x160(%ebx),%edx
 804c1ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c202:	89 50 10             	mov    %edx,0x10(%eax)

                brk(pf->end);
 804c205:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c208:	8b 40 0c             	mov    0xc(%eax),%eax
 804c20b:	89 04 24             	mov    %eax,(%esp)
 804c20e:	e8 f5 cf ff ff       	call   8049208 <brk>
                malloc_brk = pf->end;
 804c213:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c216:	8b 40 0c             	mov    0xc(%eax),%eax
 804c219:	89 83 94 02 00 00    	mov    %eax,0x294(%ebx)

                index = ptr2index(pf->end);
 804c21f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c222:	8b 40 0c             	mov    0xc(%eax),%eax
 804c225:	89 c2                	mov    %eax,%edx
 804c227:	c1 ea 0c             	shr    $0xc,%edx
 804c22a:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804c230:	89 d1                	mov    %edx,%ecx
 804c232:	29 c1                	sub    %eax,%ecx
 804c234:	89 c8                	mov    %ecx,%eax
 804c236:	89 45 0c             	mov    %eax,0xc(%ebp)
                last_index = index - 1;
 804c239:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c23c:	83 e8 01             	sub    $0x1,%eax
 804c23f:	89 83 54 02 00 00    	mov    %eax,0x254(%ebx)

                for (i = index; i <= last_index;)
 804c245:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c248:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804c24b:	eb 18                	jmp    804c265 <free_pages+0x3ee>
                        page_dir[i++] = MALLOC_NOT_MINE;
 804c24d:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804c253:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804c256:	c1 e2 02             	shl    $0x2,%edx
 804c259:	01 d0                	add    %edx,%eax
 804c25b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
 804c261:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                malloc_brk = pf->end;

                index = ptr2index(pf->end);
                last_index = index - 1;

                for (i = index; i <= last_index;)
 804c265:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804c26b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
 804c26e:	76 dd                	jbe    804c24d <free_pages+0x3d6>
                        page_dir[i++] = MALLOC_NOT_MINE;

                /* XXX: We could realloc/shrink the pagedir here I guess. */
        }
        if (pt)
 804c270:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804c274:	74 0b                	je     804c281 <free_pages+0x40a>
                ifree(pt);
 804c276:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c279:	89 04 24             	mov    %eax,(%esp)
 804c27c:	e8 21 02 00 00       	call   804c4a2 <ifree>
}
 804c281:	83 c4 34             	add    $0x34,%esp
 804c284:	5b                   	pop    %ebx
 804c285:	5d                   	pop    %ebp
 804c286:	c3                   	ret    

0804c287 <free_bytes>:
 * Free a chunk, and possibly the page it's on, if the page becomes empty.
 */

static __inline__ void
free_bytes(void *ptr, int index, struct pginfo *info)
{
 804c287:	55                   	push   %ebp
 804c288:	89 e5                	mov    %esp,%ebp
 804c28a:	57                   	push   %edi
 804c28b:	56                   	push   %esi
 804c28c:	53                   	push   %ebx
 804c28d:	83 ec 3c             	sub    $0x3c,%esp
 804c290:	e8 8c c2 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804c295:	81 c3 eb 3e 00 00    	add    $0x3eeb,%ebx
        int i;
        struct pginfo **mp;
        void *vp;

        /* Find the chunk number on the page */
        i = ((u_long)ptr & malloc_pagemask) >> info->shift;
 804c29b:	8b 45 08             	mov    0x8(%ebp),%eax
 804c29e:	89 c2                	mov    %eax,%edx
 804c2a0:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
 804c2a6:	8b 45 10             	mov    0x10(%ebp),%eax
 804c2a9:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804c2ad:	0f b7 c0             	movzwl %ax,%eax
 804c2b0:	89 d6                	mov    %edx,%esi
 804c2b2:	89 c1                	mov    %eax,%ecx
 804c2b4:	d3 ee                	shr    %cl,%esi
 804c2b6:	89 f0                	mov    %esi,%eax
 804c2b8:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if (((u_long)ptr & (info->size - 1))) {
 804c2bb:	8b 45 10             	mov    0x10(%ebp),%eax
 804c2be:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804c2c2:	0f b7 c0             	movzwl %ax,%eax
 804c2c5:	83 e8 01             	sub    $0x1,%eax
 804c2c8:	89 c2                	mov    %eax,%edx
 804c2ca:	8b 45 08             	mov    0x8(%ebp),%eax
 804c2cd:	21 d0                	and    %edx,%eax
 804c2cf:	85 c0                	test   %eax,%eax
 804c2d1:	74 13                	je     804c2e6 <free_bytes+0x5f>
                wrtwarning("modified (chunk-) pointer.\n");
 804c2d3:	8d 83 6e e1 ff ff    	lea    -0x1e92(%ebx),%eax
 804c2d9:	89 04 24             	mov    %eax,(%esp)
 804c2dc:	e8 9a ea ff ff       	call   804ad7b <wrtwarning>
                return;
 804c2e1:	e9 b4 01 00 00       	jmp    804c49a <free_bytes+0x213>
        }

        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804c2e6:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c2e9:	89 c2                	mov    %eax,%edx
 804c2eb:	c1 ea 05             	shr    $0x5,%edx
 804c2ee:	8b 45 10             	mov    0x10(%ebp),%eax
 804c2f1:	83 c2 04             	add    $0x4,%edx
 804c2f4:	8b 14 90             	mov    (%eax,%edx,4),%edx
 804c2f7:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c2fa:	83 e0 1f             	and    $0x1f,%eax
 804c2fd:	be 01 00 00 00       	mov    $0x1,%esi
 804c302:	89 f7                	mov    %esi,%edi
 804c304:	89 c1                	mov    %eax,%ecx
 804c306:	d3 e7                	shl    %cl,%edi
 804c308:	89 f8                	mov    %edi,%eax
 804c30a:	21 d0                	and    %edx,%eax
 804c30c:	85 c0                	test   %eax,%eax
 804c30e:	74 13                	je     804c323 <free_bytes+0x9c>
                wrtwarning("chunk is already free.\n");
 804c310:	8d 83 8a e1 ff ff    	lea    -0x1e76(%ebx),%eax
 804c316:	89 04 24             	mov    %eax,(%esp)
 804c319:	e8 5d ea ff ff       	call   804ad7b <wrtwarning>
                return;
 804c31e:	e9 77 01 00 00       	jmp    804c49a <free_bytes+0x213>
        }

        if (malloc_junk)
 804c323:	8b 83 90 02 00 00    	mov    0x290(%ebx),%eax
 804c329:	85 c0                	test   %eax,%eax
 804c32b:	74 21                	je     804c34e <free_bytes+0xc7>
                memset(ptr, SOME_JUNK, info->size);
 804c32d:	8b 45 10             	mov    0x10(%ebp),%eax
 804c330:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804c334:	0f b7 c0             	movzwl %ax,%eax
 804c337:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c33b:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804c342:	00 
 804c343:	8b 45 08             	mov    0x8(%ebp),%eax
 804c346:	89 04 24             	mov    %eax,(%esp)
 804c349:	e8 76 c3 ff ff       	call   80486c4 <memset>

        info->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804c34e:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c351:	c1 e8 05             	shr    $0x5,%eax
 804c354:	8b 55 10             	mov    0x10(%ebp),%edx
 804c357:	8d 48 04             	lea    0x4(%eax),%ecx
 804c35a:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 804c35d:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804c360:	83 e2 1f             	and    $0x1f,%edx
 804c363:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
 804c36a:	8b 7d d4             	mov    -0x2c(%ebp),%edi
 804c36d:	89 d1                	mov    %edx,%ecx
 804c36f:	d3 e7                	shl    %cl,%edi
 804c371:	89 fa                	mov    %edi,%edx
 804c373:	89 f1                	mov    %esi,%ecx
 804c375:	09 d1                	or     %edx,%ecx
 804c377:	8b 55 10             	mov    0x10(%ebp),%edx
 804c37a:	83 c0 04             	add    $0x4,%eax
 804c37d:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
        info->free++;
 804c380:	8b 45 10             	mov    0x10(%ebp),%eax
 804c383:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804c387:	8d 50 01             	lea    0x1(%eax),%edx
 804c38a:	8b 45 10             	mov    0x10(%ebp),%eax
 804c38d:	66 89 50 0c          	mov    %dx,0xc(%eax)

        mp = page_dir + info->shift;
 804c391:	8b 93 58 02 00 00    	mov    0x258(%ebx),%edx
 804c397:	8b 45 10             	mov    0x10(%ebp),%eax
 804c39a:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804c39e:	0f b7 c0             	movzwl %ax,%eax
 804c3a1:	c1 e0 02             	shl    $0x2,%eax
 804c3a4:	01 d0                	add    %edx,%eax
 804c3a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if (info->free == 1) {
 804c3a9:	8b 45 10             	mov    0x10(%ebp),%eax
 804c3ac:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804c3b0:	66 83 f8 01          	cmp    $0x1,%ax
 804c3b4:	75 61                	jne    804c417 <free_bytes+0x190>

                /* Page became non-full */

                mp = page_dir + info->shift;
 804c3b6:	8b 93 58 02 00 00    	mov    0x258(%ebx),%edx
 804c3bc:	8b 45 10             	mov    0x10(%ebp),%eax
 804c3bf:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804c3c3:	0f b7 c0             	movzwl %ax,%eax
 804c3c6:	c1 e0 02             	shl    $0x2,%eax
 804c3c9:	01 d0                	add    %edx,%eax
 804c3cb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804c3ce:	eb 08                	jmp    804c3d8 <free_bytes+0x151>
                        mp = &(*mp)->next;
 804c3d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c3d3:	8b 00                	mov    (%eax),%eax
 804c3d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

                /* Page became non-full */

                mp = page_dir + info->shift;
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804c3d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c3db:	8b 00                	mov    (%eax),%eax
 804c3dd:	85 c0                	test   %eax,%eax
 804c3df:	74 1f                	je     804c400 <free_bytes+0x179>
 804c3e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c3e4:	8b 00                	mov    (%eax),%eax
 804c3e6:	8b 00                	mov    (%eax),%eax
 804c3e8:	85 c0                	test   %eax,%eax
 804c3ea:	74 14                	je     804c400 <free_bytes+0x179>
 804c3ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c3ef:	8b 00                	mov    (%eax),%eax
 804c3f1:	8b 00                	mov    (%eax),%eax
 804c3f3:	8b 50 04             	mov    0x4(%eax),%edx
 804c3f6:	8b 45 10             	mov    0x10(%ebp),%eax
 804c3f9:	8b 40 04             	mov    0x4(%eax),%eax
 804c3fc:	39 c2                	cmp    %eax,%edx
 804c3fe:	72 d0                	jb     804c3d0 <free_bytes+0x149>
                        mp = &(*mp)->next;
                info->next = *mp;
 804c400:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c403:	8b 10                	mov    (%eax),%edx
 804c405:	8b 45 10             	mov    0x10(%ebp),%eax
 804c408:	89 10                	mov    %edx,(%eax)
                *mp = info;
 804c40a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c40d:	8b 55 10             	mov    0x10(%ebp),%edx
 804c410:	89 10                	mov    %edx,(%eax)
                return;
 804c412:	e9 83 00 00 00       	jmp    804c49a <free_bytes+0x213>
        }

        if (info->free != info->total)
 804c417:	8b 45 10             	mov    0x10(%ebp),%eax
 804c41a:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804c41e:	8b 45 10             	mov    0x10(%ebp),%eax
 804c421:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804c425:	66 39 c2             	cmp    %ax,%dx
 804c428:	74 0c                	je     804c436 <free_bytes+0x1af>
                return;
 804c42a:	eb 6e                	jmp    804c49a <free_bytes+0x213>

        /* Find & remove this page in the queue */
        while (*mp != info) {
                mp = &((*mp)->next);
 804c42c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c42f:	8b 00                	mov    (%eax),%eax
 804c431:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804c434:	eb 01                	jmp    804c437 <free_bytes+0x1b0>

        if (info->free != info->total)
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
 804c436:	90                   	nop
 804c437:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c43a:	8b 00                	mov    (%eax),%eax
 804c43c:	3b 45 10             	cmp    0x10(%ebp),%eax
 804c43f:	75 eb                	jne    804c42c <free_bytes+0x1a5>
#ifdef EXTRA_SANITY
                if (!*mp)
                        wrterror("(ES): Not on queue\n");
#endif /* EXTRA_SANITY */
        }
        *mp = info->next;
 804c441:	8b 45 10             	mov    0x10(%ebp),%eax
 804c444:	8b 10                	mov    (%eax),%edx
 804c446:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c449:	89 10                	mov    %edx,(%eax)

        /* Free the page & the info structure if need be */
        page_dir[ptr2index(info->page)] = MALLOC_FIRST;
 804c44b:	8b 93 58 02 00 00    	mov    0x258(%ebx),%edx
 804c451:	8b 45 10             	mov    0x10(%ebp),%eax
 804c454:	8b 40 04             	mov    0x4(%eax),%eax
 804c457:	89 c1                	mov    %eax,%ecx
 804c459:	c1 e9 0c             	shr    $0xc,%ecx
 804c45c:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804c462:	89 ce                	mov    %ecx,%esi
 804c464:	29 c6                	sub    %eax,%esi
 804c466:	89 f0                	mov    %esi,%eax
 804c468:	c1 e0 02             	shl    $0x2,%eax
 804c46b:	01 d0                	add    %edx,%eax
 804c46d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        vp = info->page;            /* Order is important ! */
 804c473:	8b 45 10             	mov    0x10(%ebp),%eax
 804c476:	8b 40 04             	mov    0x4(%eax),%eax
 804c479:	89 45 dc             	mov    %eax,-0x24(%ebp)
        if (vp != (void *)info)
 804c47c:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804c47f:	3b 45 10             	cmp    0x10(%ebp),%eax
 804c482:	74 0b                	je     804c48f <free_bytes+0x208>
                ifree(info);
 804c484:	8b 45 10             	mov    0x10(%ebp),%eax
 804c487:	89 04 24             	mov    %eax,(%esp)
 804c48a:	e8 13 00 00 00       	call   804c4a2 <ifree>
        ifree(vp);
 804c48f:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804c492:	89 04 24             	mov    %eax,(%esp)
 804c495:	e8 08 00 00 00       	call   804c4a2 <ifree>
}
 804c49a:	83 c4 3c             	add    $0x3c,%esp
 804c49d:	5b                   	pop    %ebx
 804c49e:	5e                   	pop    %esi
 804c49f:	5f                   	pop    %edi
 804c4a0:	5d                   	pop    %ebp
 804c4a1:	c3                   	ret    

0804c4a2 <ifree>:

static void
ifree(void *ptr)
{
 804c4a2:	55                   	push   %ebp
 804c4a3:	89 e5                	mov    %esp,%ebp
 804c4a5:	57                   	push   %edi
 804c4a6:	56                   	push   %esi
 804c4a7:	53                   	push   %ebx
 804c4a8:	83 ec 6c             	sub    $0x6c,%esp
 804c4ab:	e8 71 c0 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804c4b0:	81 c3 d0 3c 00 00    	add    $0x3cd0,%ebx
        struct pginfo *info;
        unsigned int index;

        /* This is legal */
        if (!ptr)
 804c4b6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804c4ba:	0f 84 b9 06 00 00    	je     804cb79 <ifree+0x6d7>
                return;

        if (!malloc_started) {
 804c4c0:	8b 83 48 02 00 00    	mov    0x248(%ebx),%eax
 804c4c6:	85 c0                	test   %eax,%eax
 804c4c8:	75 13                	jne    804c4dd <ifree+0x3b>
                wrtwarning("malloc() has never been called.\n");
 804c4ca:	8d 83 ec e1 ff ff    	lea    -0x1e14(%ebx),%eax
 804c4d0:	89 04 24             	mov    %eax,(%esp)
 804c4d3:	e8 a3 e8 ff ff       	call   804ad7b <wrtwarning>
                return;
 804c4d8:	e9 a3 06 00 00       	jmp    804cb80 <ifree+0x6de>
        }

        /* If we're already sinking, don't make matters any worse. */
        if (suicide)
 804c4dd:	8b 83 78 02 00 00    	mov    0x278(%ebx),%eax
 804c4e3:	85 c0                	test   %eax,%eax
 804c4e5:	0f 85 91 06 00 00    	jne    804cb7c <ifree+0x6da>
                return;

        index = ptr2index(ptr);
 804c4eb:	8b 45 08             	mov    0x8(%ebp),%eax
 804c4ee:	89 c2                	mov    %eax,%edx
 804c4f0:	c1 ea 0c             	shr    $0xc,%edx
 804c4f3:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804c4f9:	89 d1                	mov    %edx,%ecx
 804c4fb:	29 c1                	sub    %eax,%ecx
 804c4fd:	89 c8                	mov    %ecx,%eax
 804c4ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if (index < malloc_pageshift) {
 804c502:	83 7d e4 0b          	cmpl   $0xb,-0x1c(%ebp)
 804c506:	77 13                	ja     804c51b <ifree+0x79>
                wrtwarning("junk pointer, too low to make sense.\n");
 804c508:	8d 83 04 e1 ff ff    	lea    -0x1efc(%ebx),%eax
 804c50e:	89 04 24             	mov    %eax,(%esp)
 804c511:	e8 65 e8 ff ff       	call   804ad7b <wrtwarning>
                return;
 804c516:	e9 65 06 00 00       	jmp    804cb80 <ifree+0x6de>
        }

        if (index > last_index) {
 804c51b:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804c521:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
 804c524:	76 13                	jbe    804c539 <ifree+0x97>
                wrtwarning("junk pointer, too high to make sense.\n");
 804c526:	8d 83 2c e1 ff ff    	lea    -0x1ed4(%ebx),%eax
 804c52c:	89 04 24             	mov    %eax,(%esp)
 804c52f:	e8 47 e8 ff ff       	call   804ad7b <wrtwarning>
                return;
 804c534:	e9 47 06 00 00       	jmp    804cb80 <ifree+0x6de>
        }

        info = page_dir[index];
 804c539:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804c53f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804c542:	c1 e2 02             	shl    $0x2,%edx
 804c545:	01 d0                	add    %edx,%eax
 804c547:	8b 00                	mov    (%eax),%eax
 804c549:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if (info < MALLOC_MAGIC)
 804c54c:	83 7d e0 03          	cmpl   $0x3,-0x20(%ebp)
 804c550:	0f 87 13 04 00 00    	ja     804c969 <ifree+0x4c7>
                free_pages(ptr, index, info);
 804c556:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c559:	8b 55 08             	mov    0x8(%ebp),%edx
 804c55c:	89 55 dc             	mov    %edx,-0x24(%ebp)
 804c55f:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804c562:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c565:	89 45 d4             	mov    %eax,-0x2c(%ebp)

static __inline__ void
free_pages(void *ptr, int index, struct pginfo *info)
{
        unsigned int i;
        struct pgfree *pf, *pt = 0;
 804c568:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
        u_long l;
        void *tail;

        if (info == MALLOC_FREE) {
 804c56f:	83 7d d4 01          	cmpl   $0x1,-0x2c(%ebp)
 804c573:	75 13                	jne    804c588 <ifree+0xe6>
                wrtwarning("page is already free.\n");
 804c575:	8d 83 ba e1 ff ff    	lea    -0x1e46(%ebx),%eax
 804c57b:	89 04 24             	mov    %eax,(%esp)
 804c57e:	e8 f8 e7 ff ff       	call   804ad7b <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804c583:	e9 f7 05 00 00       	jmp    804cb7f <ifree+0x6dd>
        if (info == MALLOC_FREE) {
                wrtwarning("page is already free.\n");
                return;
        }

        if (info != MALLOC_FIRST) {
 804c588:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
 804c58c:	74 13                	je     804c5a1 <ifree+0xff>
                wrtwarning("pointer to wrong page.\n");
 804c58e:	8d 83 a2 e1 ff ff    	lea    -0x1e5e(%ebx),%eax
 804c594:	89 04 24             	mov    %eax,(%esp)
 804c597:	e8 df e7 ff ff       	call   804ad7b <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804c59c:	e9 de 05 00 00       	jmp    804cb7f <ifree+0x6dd>
        if (info != MALLOC_FIRST) {
                wrtwarning("pointer to wrong page.\n");
                return;
        }

        if ((u_long)ptr & malloc_pagemask) {
 804c5a1:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804c5a4:	25 ff 0f 00 00       	and    $0xfff,%eax
 804c5a9:	85 c0                	test   %eax,%eax
 804c5ab:	74 13                	je     804c5c0 <ifree+0x11e>
                wrtwarning("modified (page-) pointer.\n");
 804c5ad:	8d 83 53 e1 ff ff    	lea    -0x1ead(%ebx),%eax
 804c5b3:	89 04 24             	mov    %eax,(%esp)
 804c5b6:	e8 c0 e7 ff ff       	call   804ad7b <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804c5bb:	e9 bf 05 00 00       	jmp    804cb7f <ifree+0x6dd>
                wrtwarning("modified (page-) pointer.\n");
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
 804c5c0:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804c5c6:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804c5c9:	c1 e2 02             	shl    $0x2,%edx
 804c5cc:	01 d0                	add    %edx,%eax
 804c5ce:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804c5d4:	c7 45 cc 01 00 00 00 	movl   $0x1,-0x34(%ebp)
 804c5db:	eb 1b                	jmp    804c5f8 <ifree+0x156>
                page_dir[index + i] = MALLOC_FREE;
 804c5dd:	8b 93 58 02 00 00    	mov    0x258(%ebx),%edx
 804c5e3:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c5e6:	03 45 cc             	add    -0x34(%ebp),%eax
 804c5e9:	c1 e0 02             	shl    $0x2,%eax
 804c5ec:	01 d0                	add    %edx,%eax
 804c5ee:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804c5f4:	83 45 cc 01          	addl   $0x1,-0x34(%ebp)
 804c5f8:	8b 93 58 02 00 00    	mov    0x258(%ebx),%edx
 804c5fe:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c601:	03 45 cc             	add    -0x34(%ebp),%eax
 804c604:	c1 e0 02             	shl    $0x2,%eax
 804c607:	01 d0                	add    %edx,%eax
 804c609:	8b 00                	mov    (%eax),%eax
 804c60b:	83 f8 03             	cmp    $0x3,%eax
 804c60e:	74 cd                	je     804c5dd <ifree+0x13b>
                page_dir[index + i] = MALLOC_FREE;

        l = i << malloc_pageshift;
 804c610:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804c613:	c1 e0 0c             	shl    $0xc,%eax
 804c616:	89 45 c8             	mov    %eax,-0x38(%ebp)

        if (malloc_junk)
 804c619:	8b 83 90 02 00 00    	mov    0x290(%ebx),%eax
 804c61f:	85 c0                	test   %eax,%eax
 804c621:	74 1a                	je     804c63d <ifree+0x19b>
                memset(ptr, SOME_JUNK, l);
 804c623:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804c626:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c62a:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804c631:	00 
 804c632:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804c635:	89 04 24             	mov    %eax,(%esp)
 804c638:	e8 87 c0 ff ff       	call   80486c4 <memset>
#ifdef HAS_MADVISE
        if (malloc_hint)
                madvise(ptr, l, MADV_FREE);
#endif

        tail = (char *)ptr + l;
 804c63d:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804c640:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804c643:	01 d0                	add    %edx,%eax
 804c645:	89 45 c4             	mov    %eax,-0x3c(%ebp)

        /* add to free-list */
        if (!px)
 804c648:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c64e:	85 c0                	test   %eax,%eax
 804c650:	75 12                	jne    804c664 <ifree+0x1c2>
                px = imalloc(sizeof * pt);      /* This cannot fail... */
 804c652:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 804c659:	e8 f0 f4 ff ff       	call   804bb4e <imalloc>
 804c65e:	89 83 98 02 00 00    	mov    %eax,0x298(%ebx)
        px->page = ptr;
 804c664:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c66a:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804c66d:	89 50 08             	mov    %edx,0x8(%eax)
        px->end =  tail;
 804c670:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c676:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 804c679:	89 50 0c             	mov    %edx,0xc(%eax)
        px->size = l;
 804c67c:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c682:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804c685:	89 50 10             	mov    %edx,0x10(%eax)
        if (!free_list.next) {
 804c688:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 804c68e:	85 c0                	test   %eax,%eax
 804c690:	75 41                	jne    804c6d3 <ifree+0x231>

                /* Nothing on free list, put this at head */
                px->next = free_list.next;
 804c692:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c698:	8b 93 60 02 00 00    	mov    0x260(%ebx),%edx
 804c69e:	89 10                	mov    %edx,(%eax)
                px->prev = &free_list;
 804c6a0:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c6a6:	8d 93 60 02 00 00    	lea    0x260(%ebx),%edx
 804c6ac:	89 50 04             	mov    %edx,0x4(%eax)
                free_list.next = px;
 804c6af:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c6b5:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
                pf = px;
 804c6bb:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c6c1:	89 45 c0             	mov    %eax,-0x40(%ebp)
                px = 0;
 804c6c4:	c7 83 98 02 00 00 00 	movl   $0x0,0x298(%ebx)
 804c6cb:	00 00 00 
 804c6ce:	e9 a2 01 00 00       	jmp    804c875 <ifree+0x3d3>

        } else {

                /* Find the right spot, leave pf pointing to the modified entry. */
                tail = (char *)ptr + l;
 804c6d3:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804c6d6:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804c6d9:	01 d0                	add    %edx,%eax
 804c6db:	89 45 c4             	mov    %eax,-0x3c(%ebp)

                for (pf = free_list.next; pf->end < ptr && pf->next; pf = pf->next)
 804c6de:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 804c6e4:	89 45 c0             	mov    %eax,-0x40(%ebp)
 804c6e7:	eb 08                	jmp    804c6f1 <ifree+0x24f>
 804c6e9:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c6ec:	8b 00                	mov    (%eax),%eax
 804c6ee:	89 45 c0             	mov    %eax,-0x40(%ebp)
 804c6f1:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c6f4:	8b 40 0c             	mov    0xc(%eax),%eax
 804c6f7:	39 45 dc             	cmp    %eax,-0x24(%ebp)
 804c6fa:	76 09                	jbe    804c705 <ifree+0x263>
 804c6fc:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c6ff:	8b 00                	mov    (%eax),%eax
 804c701:	85 c0                	test   %eax,%eax
 804c703:	75 e4                	jne    804c6e9 <ifree+0x247>
                        ; /* Race ahead here */

                if (pf->page > tail) {
 804c705:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c708:	8b 40 08             	mov    0x8(%eax),%eax
 804c70b:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
 804c70e:	73 4f                	jae    804c75f <ifree+0x2bd>
                        /* Insert before entry */
                        px->next = pf;
 804c710:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c716:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804c719:	89 10                	mov    %edx,(%eax)
                        px->prev = pf->prev;
 804c71b:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c721:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804c724:	8b 52 04             	mov    0x4(%edx),%edx
 804c727:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev = px;
 804c72a:	8b 93 98 02 00 00    	mov    0x298(%ebx),%edx
 804c730:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c733:	89 50 04             	mov    %edx,0x4(%eax)
                        px->prev->next = px;
 804c736:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c73c:	8b 40 04             	mov    0x4(%eax),%eax
 804c73f:	8b 93 98 02 00 00    	mov    0x298(%ebx),%edx
 804c745:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804c747:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c74d:	89 45 c0             	mov    %eax,-0x40(%ebp)
                        px = 0;
 804c750:	c7 83 98 02 00 00 00 	movl   $0x0,0x298(%ebx)
 804c757:	00 00 00 
 804c75a:	e9 16 01 00 00       	jmp    804c875 <ifree+0x3d3>
                } else if (pf->end == ptr) {
 804c75f:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c762:	8b 40 0c             	mov    0xc(%eax),%eax
 804c765:	39 45 dc             	cmp    %eax,-0x24(%ebp)
 804c768:	0f 85 91 00 00 00    	jne    804c7ff <ifree+0x35d>
                        /* Append to the previous entry */
                        pf->end = (char *)pf->end + l;
 804c76e:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c771:	8b 40 0c             	mov    0xc(%eax),%eax
 804c774:	89 c2                	mov    %eax,%edx
 804c776:	03 55 c8             	add    -0x38(%ebp),%edx
 804c779:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c77c:	89 50 0c             	mov    %edx,0xc(%eax)
                        pf->size += l;
 804c77f:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c782:	8b 40 10             	mov    0x10(%eax),%eax
 804c785:	89 c2                	mov    %eax,%edx
 804c787:	03 55 c8             	add    -0x38(%ebp),%edx
 804c78a:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c78d:	89 50 10             	mov    %edx,0x10(%eax)
                        if (pf->next && pf->end == pf->next->page) {
 804c790:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c793:	8b 00                	mov    (%eax),%eax
 804c795:	85 c0                	test   %eax,%eax
 804c797:	0f 84 d8 00 00 00    	je     804c875 <ifree+0x3d3>
 804c79d:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c7a0:	8b 50 0c             	mov    0xc(%eax),%edx
 804c7a3:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c7a6:	8b 00                	mov    (%eax),%eax
 804c7a8:	8b 40 08             	mov    0x8(%eax),%eax
 804c7ab:	39 c2                	cmp    %eax,%edx
 804c7ad:	0f 85 c2 00 00 00    	jne    804c875 <ifree+0x3d3>
                                /* And collapse the next too. */
                                pt = pf->next;
 804c7b3:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c7b6:	8b 00                	mov    (%eax),%eax
 804c7b8:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                pf->end = pt->end;
 804c7bb:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804c7be:	8b 50 0c             	mov    0xc(%eax),%edx
 804c7c1:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c7c4:	89 50 0c             	mov    %edx,0xc(%eax)
                                pf->size += pt->size;
 804c7c7:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c7ca:	8b 50 10             	mov    0x10(%eax),%edx
 804c7cd:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804c7d0:	8b 40 10             	mov    0x10(%eax),%eax
 804c7d3:	01 c2                	add    %eax,%edx
 804c7d5:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c7d8:	89 50 10             	mov    %edx,0x10(%eax)
                                pf->next = pt->next;
 804c7db:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804c7de:	8b 10                	mov    (%eax),%edx
 804c7e0:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c7e3:	89 10                	mov    %edx,(%eax)
                                if (pf->next)
 804c7e5:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c7e8:	8b 00                	mov    (%eax),%eax
 804c7ea:	85 c0                	test   %eax,%eax
 804c7ec:	0f 84 83 00 00 00    	je     804c875 <ifree+0x3d3>
                                        pf->next->prev = pf;
 804c7f2:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c7f5:	8b 00                	mov    (%eax),%eax
 804c7f7:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804c7fa:	89 50 04             	mov    %edx,0x4(%eax)
 804c7fd:	eb 76                	jmp    804c875 <ifree+0x3d3>
                        }
                } else if (pf->page == tail) {
 804c7ff:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c802:	8b 40 08             	mov    0x8(%eax),%eax
 804c805:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
 804c808:	75 1c                	jne    804c826 <ifree+0x384>
                        /* Prepend to entry */
                        pf->size += l;
 804c80a:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c80d:	8b 40 10             	mov    0x10(%eax),%eax
 804c810:	89 c2                	mov    %eax,%edx
 804c812:	03 55 c8             	add    -0x38(%ebp),%edx
 804c815:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c818:	89 50 10             	mov    %edx,0x10(%eax)
                        pf->page = ptr;
 804c81b:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c81e:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804c821:	89 50 08             	mov    %edx,0x8(%eax)
 804c824:	eb 4f                	jmp    804c875 <ifree+0x3d3>
                } else if (!pf->next) {
 804c826:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c829:	8b 00                	mov    (%eax),%eax
 804c82b:	85 c0                	test   %eax,%eax
 804c82d:	75 38                	jne    804c867 <ifree+0x3c5>
                        /* Append at tail of chain */
                        px->next = 0;
 804c82f:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c835:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                        px->prev = pf;
 804c83b:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c841:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804c844:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->next = px;
 804c847:	8b 93 98 02 00 00    	mov    0x298(%ebx),%edx
 804c84d:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c850:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804c852:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
 804c858:	89 45 c0             	mov    %eax,-0x40(%ebp)
                        px = 0;
 804c85b:	c7 83 98 02 00 00 00 	movl   $0x0,0x298(%ebx)
 804c862:	00 00 00 
 804c865:	eb 0e                	jmp    804c875 <ifree+0x3d3>
                } else {
                        wrterror("freelist is destroyed.\n");
 804c867:	8d 83 d1 e1 ff ff    	lea    -0x1e2f(%ebx),%eax
 804c86d:	89 04 24             	mov    %eax,(%esp)
 804c870:	e8 3b e4 ff ff       	call   804acb0 <wrterror>
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804c875:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c878:	8b 00                	mov    (%eax),%eax
 804c87a:	85 c0                	test   %eax,%eax
 804c87c:	0f 85 cd 00 00 00    	jne    804c94f <ifree+0x4ad>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804c882:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c885:	8b 50 10             	mov    0x10(%eax),%edx
 804c888:	8b 83 60 01 00 00    	mov    0x160(%ebx),%eax
                        wrterror("freelist is destroyed.\n");
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804c88e:	39 c2                	cmp    %eax,%edx
 804c890:	0f 86 b9 00 00 00    	jbe    804c94f <ifree+0x4ad>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804c896:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c899:	8b 50 0c             	mov    0xc(%eax),%edx
 804c89c:	8b 83 94 02 00 00    	mov    0x294(%ebx),%eax
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804c8a2:	39 c2                	cmp    %eax,%edx
 804c8a4:	0f 85 a5 00 00 00    	jne    804c94f <ifree+0x4ad>
            pf->end == malloc_brk &&                  /* ..and none behind us, */
            malloc_brk == sbrk(0)) {                  /* ..and it's OK to do... */
 804c8aa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804c8b1:	e8 82 c8 ff ff       	call   8049138 <sbrk>
 804c8b6:	8b 93 94 02 00 00    	mov    0x294(%ebx),%edx
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804c8bc:	39 d0                	cmp    %edx,%eax
 804c8be:	0f 85 8b 00 00 00    	jne    804c94f <ifree+0x4ad>

                /*
                 * Keep the cache intact.  Notice that the '>' above guarantees that
                 * the pf will always have at least one page afterwards.
                 */
                pf->end = (char *)pf->page + malloc_cache;
 804c8c4:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c8c7:	8b 50 08             	mov    0x8(%eax),%edx
 804c8ca:	8b 83 60 01 00 00    	mov    0x160(%ebx),%eax
 804c8d0:	01 c2                	add    %eax,%edx
 804c8d2:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c8d5:	89 50 0c             	mov    %edx,0xc(%eax)
                pf->size = malloc_cache;
 804c8d8:	8b 93 60 01 00 00    	mov    0x160(%ebx),%edx
 804c8de:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c8e1:	89 50 10             	mov    %edx,0x10(%eax)

                brk(pf->end);
 804c8e4:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c8e7:	8b 40 0c             	mov    0xc(%eax),%eax
 804c8ea:	89 04 24             	mov    %eax,(%esp)
 804c8ed:	e8 16 c9 ff ff       	call   8049208 <brk>
                malloc_brk = pf->end;
 804c8f2:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c8f5:	8b 40 0c             	mov    0xc(%eax),%eax
 804c8f8:	89 83 94 02 00 00    	mov    %eax,0x294(%ebx)

                index = ptr2index(pf->end);
 804c8fe:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c901:	8b 40 0c             	mov    0xc(%eax),%eax
 804c904:	89 c2                	mov    %eax,%edx
 804c906:	c1 ea 0c             	shr    $0xc,%edx
 804c909:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804c90f:	89 d6                	mov    %edx,%esi
 804c911:	29 c6                	sub    %eax,%esi
 804c913:	89 f0                	mov    %esi,%eax
 804c915:	89 45 d8             	mov    %eax,-0x28(%ebp)
                last_index = index - 1;
 804c918:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c91b:	83 e8 01             	sub    $0x1,%eax
 804c91e:	89 83 54 02 00 00    	mov    %eax,0x254(%ebx)

                for (i = index; i <= last_index;)
 804c924:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c927:	89 45 cc             	mov    %eax,-0x34(%ebp)
 804c92a:	eb 18                	jmp    804c944 <ifree+0x4a2>
                        page_dir[i++] = MALLOC_NOT_MINE;
 804c92c:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804c932:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804c935:	c1 e2 02             	shl    $0x2,%edx
 804c938:	01 d0                	add    %edx,%eax
 804c93a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
 804c940:	83 45 cc 01          	addl   $0x1,-0x34(%ebp)
                malloc_brk = pf->end;

                index = ptr2index(pf->end);
                last_index = index - 1;

                for (i = index; i <= last_index;)
 804c944:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804c94a:	39 45 cc             	cmp    %eax,-0x34(%ebp)
 804c94d:	76 dd                	jbe    804c92c <ifree+0x48a>
                        page_dir[i++] = MALLOC_NOT_MINE;

                /* XXX: We could realloc/shrink the pagedir here I guess. */
        }
        if (pt)
 804c94f:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804c953:	0f 84 26 02 00 00    	je     804cb7f <ifree+0x6dd>
                ifree(pt);
 804c959:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804c95c:	89 04 24             	mov    %eax,(%esp)
 804c95f:	e8 3e fb ff ff       	call   804c4a2 <ifree>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804c964:	e9 16 02 00 00       	jmp    804cb7f <ifree+0x6dd>
        info = page_dir[index];

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
 804c969:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c96c:	8b 55 08             	mov    0x8(%ebp),%edx
 804c96f:	89 55 bc             	mov    %edx,-0x44(%ebp)
 804c972:	89 45 a8             	mov    %eax,-0x58(%ebp)
 804c975:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c978:	89 45 b8             	mov    %eax,-0x48(%ebp)
        int i;
        struct pginfo **mp;
        void *vp;

        /* Find the chunk number on the page */
        i = ((u_long)ptr & malloc_pagemask) >> info->shift;
 804c97b:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c97e:	89 c2                	mov    %eax,%edx
 804c980:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
 804c986:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804c989:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804c98d:	0f b7 c0             	movzwl %ax,%eax
 804c990:	89 d6                	mov    %edx,%esi
 804c992:	89 c1                	mov    %eax,%ecx
 804c994:	d3 ee                	shr    %cl,%esi
 804c996:	89 f0                	mov    %esi,%eax
 804c998:	89 45 b4             	mov    %eax,-0x4c(%ebp)

        if (((u_long)ptr & (info->size - 1))) {
 804c99b:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804c99e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804c9a2:	0f b7 c0             	movzwl %ax,%eax
 804c9a5:	83 e8 01             	sub    $0x1,%eax
 804c9a8:	89 c2                	mov    %eax,%edx
 804c9aa:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c9ad:	21 d0                	and    %edx,%eax
 804c9af:	85 c0                	test   %eax,%eax
 804c9b1:	74 13                	je     804c9c6 <ifree+0x524>
                wrtwarning("modified (chunk-) pointer.\n");
 804c9b3:	8d 83 6e e1 ff ff    	lea    -0x1e92(%ebx),%eax
 804c9b9:	89 04 24             	mov    %eax,(%esp)
 804c9bc:	e8 ba e3 ff ff       	call   804ad7b <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804c9c1:	e9 b9 01 00 00       	jmp    804cb7f <ifree+0x6dd>
        if (((u_long)ptr & (info->size - 1))) {
                wrtwarning("modified (chunk-) pointer.\n");
                return;
        }

        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804c9c6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804c9c9:	89 c2                	mov    %eax,%edx
 804c9cb:	c1 ea 05             	shr    $0x5,%edx
 804c9ce:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804c9d1:	83 c2 04             	add    $0x4,%edx
 804c9d4:	8b 14 90             	mov    (%eax,%edx,4),%edx
 804c9d7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804c9da:	83 e0 1f             	and    $0x1f,%eax
 804c9dd:	be 01 00 00 00       	mov    $0x1,%esi
 804c9e2:	89 f7                	mov    %esi,%edi
 804c9e4:	89 c1                	mov    %eax,%ecx
 804c9e6:	d3 e7                	shl    %cl,%edi
 804c9e8:	89 f8                	mov    %edi,%eax
 804c9ea:	21 d0                	and    %edx,%eax
 804c9ec:	85 c0                	test   %eax,%eax
 804c9ee:	74 13                	je     804ca03 <ifree+0x561>
                wrtwarning("chunk is already free.\n");
 804c9f0:	8d 83 8a e1 ff ff    	lea    -0x1e76(%ebx),%eax
 804c9f6:	89 04 24             	mov    %eax,(%esp)
 804c9f9:	e8 7d e3 ff ff       	call   804ad7b <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804c9fe:	e9 7c 01 00 00       	jmp    804cb7f <ifree+0x6dd>
        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
                wrtwarning("chunk is already free.\n");
                return;
        }

        if (malloc_junk)
 804ca03:	8b 83 90 02 00 00    	mov    0x290(%ebx),%eax
 804ca09:	85 c0                	test   %eax,%eax
 804ca0b:	74 21                	je     804ca2e <ifree+0x58c>
                memset(ptr, SOME_JUNK, info->size);
 804ca0d:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ca10:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804ca14:	0f b7 c0             	movzwl %ax,%eax
 804ca17:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ca1b:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804ca22:	00 
 804ca23:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804ca26:	89 04 24             	mov    %eax,(%esp)
 804ca29:	e8 96 bc ff ff       	call   80486c4 <memset>

        info->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804ca2e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804ca31:	c1 e8 05             	shr    $0x5,%eax
 804ca34:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804ca37:	8d 48 04             	lea    0x4(%eax),%ecx
 804ca3a:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 804ca3d:	8b 55 b4             	mov    -0x4c(%ebp),%edx
 804ca40:	83 e2 1f             	and    $0x1f,%edx
 804ca43:	c7 45 a4 01 00 00 00 	movl   $0x1,-0x5c(%ebp)
 804ca4a:	8b 7d a4             	mov    -0x5c(%ebp),%edi
 804ca4d:	89 d1                	mov    %edx,%ecx
 804ca4f:	d3 e7                	shl    %cl,%edi
 804ca51:	89 fa                	mov    %edi,%edx
 804ca53:	89 f1                	mov    %esi,%ecx
 804ca55:	09 d1                	or     %edx,%ecx
 804ca57:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804ca5a:	83 c0 04             	add    $0x4,%eax
 804ca5d:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
        info->free++;
 804ca60:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ca63:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804ca67:	8d 50 01             	lea    0x1(%eax),%edx
 804ca6a:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ca6d:	66 89 50 0c          	mov    %dx,0xc(%eax)

        mp = page_dir + info->shift;
 804ca71:	8b 93 58 02 00 00    	mov    0x258(%ebx),%edx
 804ca77:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ca7a:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804ca7e:	0f b7 c0             	movzwl %ax,%eax
 804ca81:	c1 e0 02             	shl    $0x2,%eax
 804ca84:	01 d0                	add    %edx,%eax
 804ca86:	89 45 b0             	mov    %eax,-0x50(%ebp)

        if (info->free == 1) {
 804ca89:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ca8c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804ca90:	66 83 f8 01          	cmp    $0x1,%ax
 804ca94:	75 61                	jne    804caf7 <ifree+0x655>

                /* Page became non-full */

                mp = page_dir + info->shift;
 804ca96:	8b 93 58 02 00 00    	mov    0x258(%ebx),%edx
 804ca9c:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ca9f:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804caa3:	0f b7 c0             	movzwl %ax,%eax
 804caa6:	c1 e0 02             	shl    $0x2,%eax
 804caa9:	01 d0                	add    %edx,%eax
 804caab:	89 45 b0             	mov    %eax,-0x50(%ebp)
 804caae:	eb 08                	jmp    804cab8 <ifree+0x616>
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
                        mp = &(*mp)->next;
 804cab0:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804cab3:	8b 00                	mov    (%eax),%eax
 804cab5:	89 45 b0             	mov    %eax,-0x50(%ebp)

                /* Page became non-full */

                mp = page_dir + info->shift;
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804cab8:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804cabb:	8b 00                	mov    (%eax),%eax
 804cabd:	85 c0                	test   %eax,%eax
 804cabf:	74 1f                	je     804cae0 <ifree+0x63e>
 804cac1:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804cac4:	8b 00                	mov    (%eax),%eax
 804cac6:	8b 00                	mov    (%eax),%eax
 804cac8:	85 c0                	test   %eax,%eax
 804caca:	74 14                	je     804cae0 <ifree+0x63e>
 804cacc:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804cacf:	8b 00                	mov    (%eax),%eax
 804cad1:	8b 00                	mov    (%eax),%eax
 804cad3:	8b 50 04             	mov    0x4(%eax),%edx
 804cad6:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804cad9:	8b 40 04             	mov    0x4(%eax),%eax
 804cadc:	39 c2                	cmp    %eax,%edx
 804cade:	72 d0                	jb     804cab0 <ifree+0x60e>
                        mp = &(*mp)->next;
                info->next = *mp;
 804cae0:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804cae3:	8b 10                	mov    (%eax),%edx
 804cae5:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804cae8:	89 10                	mov    %edx,(%eax)
                *mp = info;
 804caea:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804caed:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804caf0:	89 10                	mov    %edx,(%eax)

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804caf2:	e9 88 00 00 00       	jmp    804cb7f <ifree+0x6dd>
                info->next = *mp;
                *mp = info;
                return;
        }

        if (info->free != info->total)
 804caf7:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804cafa:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804cafe:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804cb01:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804cb05:	66 39 c2             	cmp    %ax,%dx
 804cb08:	75 75                	jne    804cb7f <ifree+0x6dd>
 804cb0a:	eb 08                	jmp    804cb14 <ifree+0x672>
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
                mp = &((*mp)->next);
 804cb0c:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804cb0f:	8b 00                	mov    (%eax),%eax
 804cb11:	89 45 b0             	mov    %eax,-0x50(%ebp)

        if (info->free != info->total)
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
 804cb14:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804cb17:	8b 00                	mov    (%eax),%eax
 804cb19:	39 45 b8             	cmp    %eax,-0x48(%ebp)
 804cb1c:	75 ee                	jne    804cb0c <ifree+0x66a>
#ifdef EXTRA_SANITY
                if (!*mp)
                        wrterror("(ES): Not on queue\n");
#endif /* EXTRA_SANITY */
        }
        *mp = info->next;
 804cb1e:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804cb21:	8b 10                	mov    (%eax),%edx
 804cb23:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804cb26:	89 10                	mov    %edx,(%eax)

        /* Free the page & the info structure if need be */
        page_dir[ptr2index(info->page)] = MALLOC_FIRST;
 804cb28:	8b 93 58 02 00 00    	mov    0x258(%ebx),%edx
 804cb2e:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804cb31:	8b 40 04             	mov    0x4(%eax),%eax
 804cb34:	89 c1                	mov    %eax,%ecx
 804cb36:	c1 e9 0c             	shr    $0xc,%ecx
 804cb39:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804cb3f:	89 ce                	mov    %ecx,%esi
 804cb41:	29 c6                	sub    %eax,%esi
 804cb43:	89 f0                	mov    %esi,%eax
 804cb45:	c1 e0 02             	shl    $0x2,%eax
 804cb48:	01 d0                	add    %edx,%eax
 804cb4a:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        vp = info->page;            /* Order is important ! */
 804cb50:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804cb53:	8b 40 04             	mov    0x4(%eax),%eax
 804cb56:	89 45 ac             	mov    %eax,-0x54(%ebp)
        if (vp != (void *)info)
 804cb59:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804cb5c:	3b 45 ac             	cmp    -0x54(%ebp),%eax
 804cb5f:	74 0b                	je     804cb6c <ifree+0x6ca>
                ifree(info);
 804cb61:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804cb64:	89 04 24             	mov    %eax,(%esp)
 804cb67:	e8 36 f9 ff ff       	call   804c4a2 <ifree>
        ifree(vp);
 804cb6c:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804cb6f:	89 04 24             	mov    %eax,(%esp)
 804cb72:	e8 2b f9 ff ff       	call   804c4a2 <ifree>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804cb77:	eb 06                	jmp    804cb7f <ifree+0x6dd>
        struct pginfo *info;
        unsigned int index;

        /* This is legal */
        if (!ptr)
                return;
 804cb79:	90                   	nop
 804cb7a:	eb 04                	jmp    804cb80 <ifree+0x6de>
                return;
        }

        /* If we're already sinking, don't make matters any worse. */
        if (suicide)
                return;
 804cb7c:	90                   	nop
 804cb7d:	eb 01                	jmp    804cb80 <ifree+0x6de>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804cb7f:	90                   	nop
}
 804cb80:	83 c4 6c             	add    $0x6c,%esp
 804cb83:	5b                   	pop    %ebx
 804cb84:	5e                   	pop    %esi
 804cb85:	5f                   	pop    %edi
 804cb86:	5d                   	pop    %ebp
 804cb87:	c3                   	ret    

0804cb88 <malloc>:
 */


void *
malloc(size_t size)
{
 804cb88:	55                   	push   %ebp
 804cb89:	89 e5                	mov    %esp,%ebp
 804cb8b:	56                   	push   %esi
 804cb8c:	53                   	push   %ebx
 804cb8d:	83 ec 10             	sub    $0x10,%esp
 804cb90:	e8 8c b9 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804cb95:	81 c3 eb 35 00 00    	add    $0x35eb,%ebx
        register void *r;

        THREAD_LOCK();
        malloc_func = " in malloc():";
 804cb9b:	8d 83 0d e2 ff ff    	lea    -0x1df3(%ebx),%eax
 804cba1:	89 83 9c 02 00 00    	mov    %eax,0x29c(%ebx)
        if (malloc_active++) {
 804cba7:	8b 83 4c 02 00 00    	mov    0x24c(%ebx),%eax
 804cbad:	85 c0                	test   %eax,%eax
 804cbaf:	0f 95 c2             	setne  %dl
 804cbb2:	83 c0 01             	add    $0x1,%eax
 804cbb5:	89 83 4c 02 00 00    	mov    %eax,0x24c(%ebx)
 804cbbb:	84 d2                	test   %dl,%dl
 804cbbd:	74 24                	je     804cbe3 <malloc+0x5b>
                wrtwarning("recursive call.\n");
 804cbbf:	8d 83 1b e2 ff ff    	lea    -0x1de5(%ebx),%eax
 804cbc5:	89 04 24             	mov    %eax,(%esp)
 804cbc8:	e8 ae e1 ff ff       	call   804ad7b <wrtwarning>
                malloc_active--;
 804cbcd:	8b 83 4c 02 00 00    	mov    0x24c(%ebx),%eax
 804cbd3:	83 e8 01             	sub    $0x1,%eax
 804cbd6:	89 83 4c 02 00 00    	mov    %eax,0x24c(%ebx)
                return (0);
 804cbdc:	b8 00 00 00 00       	mov    $0x0,%eax
 804cbe1:	eb 60                	jmp    804cc43 <malloc+0xbb>
        }
        if (!malloc_started) {
 804cbe3:	8b 83 48 02 00 00    	mov    0x248(%ebx),%eax
 804cbe9:	85 c0                	test   %eax,%eax
 804cbeb:	75 05                	jne    804cbf2 <malloc+0x6a>
                malloc_init();
 804cbed:	e8 db e3 ff ff       	call   804afcd <malloc_init>
        }
        if (malloc_sysv && !size)
 804cbf2:	8b 83 88 02 00 00    	mov    0x288(%ebx),%eax
 804cbf8:	85 c0                	test   %eax,%eax
 804cbfa:	74 0d                	je     804cc09 <malloc+0x81>
 804cbfc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804cc00:	75 07                	jne    804cc09 <malloc+0x81>
                r = 0;
 804cc02:	be 00 00 00 00       	mov    $0x0,%esi
 804cc07:	eb 0d                	jmp    804cc16 <malloc+0x8e>
        else
                r = imalloc(size);
 804cc09:	8b 45 08             	mov    0x8(%ebp),%eax
 804cc0c:	89 04 24             	mov    %eax,(%esp)
 804cc0f:	e8 3a ef ff ff       	call   804bb4e <imalloc>
 804cc14:	89 c6                	mov    %eax,%esi
        UTRACE(0, size, r);
        malloc_active--;
 804cc16:	8b 83 4c 02 00 00    	mov    0x24c(%ebx),%eax
 804cc1c:	83 e8 01             	sub    $0x1,%eax
 804cc1f:	89 83 4c 02 00 00    	mov    %eax,0x24c(%ebx)
        THREAD_UNLOCK();
        if (malloc_xmalloc && !r)
 804cc25:	8b 83 84 02 00 00    	mov    0x284(%ebx),%eax
 804cc2b:	85 c0                	test   %eax,%eax
 804cc2d:	74 12                	je     804cc41 <malloc+0xb9>
 804cc2f:	85 f6                	test   %esi,%esi
 804cc31:	75 0e                	jne    804cc41 <malloc+0xb9>
                wrterror("out of memory.\n");
 804cc33:	8d 83 2c e2 ff ff    	lea    -0x1dd4(%ebx),%eax
 804cc39:	89 04 24             	mov    %eax,(%esp)
 804cc3c:	e8 6f e0 ff ff       	call   804acb0 <wrterror>
        return (r);
 804cc41:	89 f0                	mov    %esi,%eax
}
 804cc43:	83 c4 10             	add    $0x10,%esp
 804cc46:	5b                   	pop    %ebx
 804cc47:	5e                   	pop    %esi
 804cc48:	5d                   	pop    %ebp
 804cc49:	c3                   	ret    

0804cc4a <free>:

void
free(void *ptr)
{
 804cc4a:	55                   	push   %ebp
 804cc4b:	89 e5                	mov    %esp,%ebp
 804cc4d:	53                   	push   %ebx
 804cc4e:	83 ec 14             	sub    $0x14,%esp
 804cc51:	e8 cb b8 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804cc56:	81 c3 2a 35 00 00    	add    $0x352a,%ebx
        THREAD_LOCK();
        malloc_func = " in free():";
 804cc5c:	8d 83 3c e2 ff ff    	lea    -0x1dc4(%ebx),%eax
 804cc62:	89 83 9c 02 00 00    	mov    %eax,0x29c(%ebx)
        if (malloc_active++) {
 804cc68:	8b 83 4c 02 00 00    	mov    0x24c(%ebx),%eax
 804cc6e:	85 c0                	test   %eax,%eax
 804cc70:	0f 95 c2             	setne  %dl
 804cc73:	83 c0 01             	add    $0x1,%eax
 804cc76:	89 83 4c 02 00 00    	mov    %eax,0x24c(%ebx)
 804cc7c:	84 d2                	test   %dl,%dl
 804cc7e:	74 1f                	je     804cc9f <free+0x55>
                wrtwarning("recursive call.\n");
 804cc80:	8d 83 1b e2 ff ff    	lea    -0x1de5(%ebx),%eax
 804cc86:	89 04 24             	mov    %eax,(%esp)
 804cc89:	e8 ed e0 ff ff       	call   804ad7b <wrtwarning>
                malloc_active--;
 804cc8e:	8b 83 4c 02 00 00    	mov    0x24c(%ebx),%eax
 804cc94:	83 e8 01             	sub    $0x1,%eax
 804cc97:	89 83 4c 02 00 00    	mov    %eax,0x24c(%ebx)
                return;
 804cc9d:	eb 1b                	jmp    804ccba <free+0x70>
        } else {
                ifree(ptr);
 804cc9f:	8b 45 08             	mov    0x8(%ebp),%eax
 804cca2:	89 04 24             	mov    %eax,(%esp)
 804cca5:	e8 f8 f7 ff ff       	call   804c4a2 <ifree>
                UTRACE(ptr, 0, 0);
        }
        malloc_active--;
 804ccaa:	8b 83 4c 02 00 00    	mov    0x24c(%ebx),%eax
 804ccb0:	83 e8 01             	sub    $0x1,%eax
 804ccb3:	89 83 4c 02 00 00    	mov    %eax,0x24c(%ebx)
        THREAD_UNLOCK();
        return;
 804ccb9:	90                   	nop
}
 804ccba:	83 c4 14             	add    $0x14,%esp
 804ccbd:	5b                   	pop    %ebx
 804ccbe:	5d                   	pop    %ebp
 804ccbf:	c3                   	ret    

0804ccc0 <realloc>:

void *
realloc(void *ptr, size_t size)
{
 804ccc0:	55                   	push   %ebp
 804ccc1:	89 e5                	mov    %esp,%ebp
 804ccc3:	56                   	push   %esi
 804ccc4:	53                   	push   %ebx
 804ccc5:	83 ec 10             	sub    $0x10,%esp
 804ccc8:	e8 54 b8 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804cccd:	81 c3 b3 34 00 00    	add    $0x34b3,%ebx
        register void *r;

        THREAD_LOCK();
        malloc_func = " in realloc():";
 804ccd3:	8d 83 48 e2 ff ff    	lea    -0x1db8(%ebx),%eax
 804ccd9:	89 83 9c 02 00 00    	mov    %eax,0x29c(%ebx)
        if (malloc_active++) {
 804ccdf:	8b 83 4c 02 00 00    	mov    0x24c(%ebx),%eax
 804cce5:	85 c0                	test   %eax,%eax
 804cce7:	0f 95 c2             	setne  %dl
 804ccea:	83 c0 01             	add    $0x1,%eax
 804cced:	89 83 4c 02 00 00    	mov    %eax,0x24c(%ebx)
 804ccf3:	84 d2                	test   %dl,%dl
 804ccf5:	74 27                	je     804cd1e <realloc+0x5e>
                wrtwarning("recursive call.\n");
 804ccf7:	8d 83 1b e2 ff ff    	lea    -0x1de5(%ebx),%eax
 804ccfd:	89 04 24             	mov    %eax,(%esp)
 804cd00:	e8 76 e0 ff ff       	call   804ad7b <wrtwarning>
                malloc_active--;
 804cd05:	8b 83 4c 02 00 00    	mov    0x24c(%ebx),%eax
 804cd0b:	83 e8 01             	sub    $0x1,%eax
 804cd0e:	89 83 4c 02 00 00    	mov    %eax,0x24c(%ebx)
                return (0);
 804cd14:	b8 00 00 00 00       	mov    $0x0,%eax
 804cd19:	e9 ac 00 00 00       	jmp    804cdca <realloc+0x10a>
        }
        if (ptr && !malloc_started) {
 804cd1e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804cd22:	74 1f                	je     804cd43 <realloc+0x83>
 804cd24:	8b 83 48 02 00 00    	mov    0x248(%ebx),%eax
 804cd2a:	85 c0                	test   %eax,%eax
 804cd2c:	75 15                	jne    804cd43 <realloc+0x83>
                wrtwarning("malloc() has never been called.\n");
 804cd2e:	8d 83 ec e1 ff ff    	lea    -0x1e14(%ebx),%eax
 804cd34:	89 04 24             	mov    %eax,(%esp)
 804cd37:	e8 3f e0 ff ff       	call   804ad7b <wrtwarning>
                ptr = 0;
 804cd3c:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        }
        if (!malloc_started)
 804cd43:	8b 83 48 02 00 00    	mov    0x248(%ebx),%eax
 804cd49:	85 c0                	test   %eax,%eax
 804cd4b:	75 05                	jne    804cd52 <realloc+0x92>
                malloc_init();
 804cd4d:	e8 7b e2 ff ff       	call   804afcd <malloc_init>
        if (malloc_sysv && !size) {
 804cd52:	8b 83 88 02 00 00    	mov    0x288(%ebx),%eax
 804cd58:	85 c0                	test   %eax,%eax
 804cd5a:	74 18                	je     804cd74 <realloc+0xb4>
 804cd5c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804cd60:	75 12                	jne    804cd74 <realloc+0xb4>
                ifree(ptr);
 804cd62:	8b 45 08             	mov    0x8(%ebp),%eax
 804cd65:	89 04 24             	mov    %eax,(%esp)
 804cd68:	e8 35 f7 ff ff       	call   804c4a2 <ifree>
                r = 0;
 804cd6d:	be 00 00 00 00       	mov    $0x0,%esi
 804cd72:	eb 29                	jmp    804cd9d <realloc+0xdd>
        } else if (!ptr) {
 804cd74:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804cd78:	75 0f                	jne    804cd89 <realloc+0xc9>
                r = imalloc(size);
 804cd7a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cd7d:	89 04 24             	mov    %eax,(%esp)
 804cd80:	e8 c9 ed ff ff       	call   804bb4e <imalloc>
 804cd85:	89 c6                	mov    %eax,%esi
 804cd87:	eb 14                	jmp    804cd9d <realloc+0xdd>
        } else {
                r = irealloc(ptr, size);
 804cd89:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cd8c:	89 44 24 04          	mov    %eax,0x4(%esp)
 804cd90:	8b 45 08             	mov    0x8(%ebp),%eax
 804cd93:	89 04 24             	mov    %eax,(%esp)
 804cd96:	e8 69 ee ff ff       	call   804bc04 <irealloc>
 804cd9b:	89 c6                	mov    %eax,%esi
        }
        UTRACE(ptr, size, r);
        malloc_active--;
 804cd9d:	8b 83 4c 02 00 00    	mov    0x24c(%ebx),%eax
 804cda3:	83 e8 01             	sub    $0x1,%eax
 804cda6:	89 83 4c 02 00 00    	mov    %eax,0x24c(%ebx)
        THREAD_UNLOCK();
        if (malloc_xmalloc && !r)
 804cdac:	8b 83 84 02 00 00    	mov    0x284(%ebx),%eax
 804cdb2:	85 c0                	test   %eax,%eax
 804cdb4:	74 12                	je     804cdc8 <realloc+0x108>
 804cdb6:	85 f6                	test   %esi,%esi
 804cdb8:	75 0e                	jne    804cdc8 <realloc+0x108>
                wrterror("out of memory.\n");
 804cdba:	8d 83 2c e2 ff ff    	lea    -0x1dd4(%ebx),%eax
 804cdc0:	89 04 24             	mov    %eax,(%esp)
 804cdc3:	e8 e8 de ff ff       	call   804acb0 <wrterror>
        return (r);
 804cdc8:	89 f0                	mov    %esi,%eax
}
 804cdca:	83 c4 10             	add    $0x10,%esp
 804cdcd:	5b                   	pop    %ebx
 804cdce:	5e                   	pop    %esi
 804cdcf:	5d                   	pop    %ebp
 804cdd0:	c3                   	ret    

0804cdd1 <calloc>:

/* Added */
void *calloc(size_t nelem, size_t elsize)
{
 804cdd1:	55                   	push   %ebp
 804cdd2:	89 e5                	mov    %esp,%ebp
 804cdd4:	53                   	push   %ebx
 804cdd5:	83 ec 24             	sub    $0x24,%esp
 804cdd8:	e8 44 b7 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804cddd:	81 c3 a3 33 00 00    	add    $0x33a3,%ebx
        void *tmp;
        if (NULL == (tmp = malloc(nelem * elsize))) {
 804cde3:	8b 45 08             	mov    0x8(%ebp),%eax
 804cde6:	0f af 45 0c          	imul   0xc(%ebp),%eax
 804cdea:	89 04 24             	mov    %eax,(%esp)
 804cded:	e8 96 fd ff ff       	call   804cb88 <malloc>
 804cdf2:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804cdf5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804cdf9:	75 07                	jne    804ce02 <calloc+0x31>
                return NULL;
 804cdfb:	b8 00 00 00 00       	mov    $0x0,%eax
 804ce00:	eb 21                	jmp    804ce23 <calloc+0x52>
        } else {
                memset(tmp, 0, nelem * elsize);
 804ce02:	8b 45 08             	mov    0x8(%ebp),%eax
 804ce05:	0f af 45 0c          	imul   0xc(%ebp),%eax
 804ce09:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ce0d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804ce14:	00 
 804ce15:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ce18:	89 04 24             	mov    %eax,(%esp)
 804ce1b:	e8 a4 b8 ff ff       	call   80486c4 <memset>
                return tmp;
 804ce20:	8b 45 f4             	mov    -0xc(%ebp),%eax
        }
}
 804ce23:	83 c4 24             	add    $0x24,%esp
 804ce26:	5b                   	pop    %ebx
 804ce27:	5d                   	pop    %ebp
 804ce28:	c3                   	ret    
 804ce29:	90                   	nop
 804ce2a:	90                   	nop
 804ce2b:	90                   	nop

0804ce2c <shl>:
 * `fall out' the left (there never will be any such anyway).
 * We may assume len >= 0.  NOTE THAT THIS WRITES len+1 DIGITS.
 */
static void
shl(register digit *p, register int len, register int sh)
{
 804ce2c:	55                   	push   %ebp
 804ce2d:	89 e5                	mov    %esp,%ebp
 804ce2f:	57                   	push   %edi
 804ce30:	56                   	push   %esi
 804ce31:	83 ec 08             	sub    $0x8,%esp
        register int i;

        for (i = 0; i < len; i++)
 804ce34:	be 00 00 00 00       	mov    $0x0,%esi
 804ce39:	eb 4f                	jmp    804ce8a <shl+0x5e>
                p[i] = LHALF(p[i] << sh) | (p[i + 1] >> (HALF_BITS - sh));
 804ce3b:	89 f0                	mov    %esi,%eax
 804ce3d:	c1 e0 02             	shl    $0x2,%eax
 804ce40:	8b 55 08             	mov    0x8(%ebp),%edx
 804ce43:	01 c2                	add    %eax,%edx
 804ce45:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804ce48:	89 f0                	mov    %esi,%eax
 804ce4a:	c1 e0 02             	shl    $0x2,%eax
 804ce4d:	03 45 08             	add    0x8(%ebp),%eax
 804ce50:	8b 00                	mov    (%eax),%eax
 804ce52:	0f b6 4d 10          	movzbl 0x10(%ebp),%ecx
 804ce56:	d3 e0                	shl    %cl,%eax
 804ce58:	25 ff ff 00 00       	and    $0xffff,%eax
 804ce5d:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804ce60:	89 f0                	mov    %esi,%eax
 804ce62:	83 c0 01             	add    $0x1,%eax
 804ce65:	c1 e0 02             	shl    $0x2,%eax
 804ce68:	03 45 08             	add    0x8(%ebp),%eax
 804ce6b:	8b 38                	mov    (%eax),%edi
 804ce6d:	8b 55 10             	mov    0x10(%ebp),%edx
 804ce70:	b8 10 00 00 00       	mov    $0x10,%eax
 804ce75:	29 d0                	sub    %edx,%eax
 804ce77:	89 fa                	mov    %edi,%edx
 804ce79:	89 c1                	mov    %eax,%ecx
 804ce7b:	d3 ea                	shr    %cl,%edx
 804ce7d:	89 d0                	mov    %edx,%eax
 804ce7f:	0b 45 f0             	or     -0x10(%ebp),%eax
 804ce82:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804ce85:	89 02                	mov    %eax,(%edx)
static void
shl(register digit *p, register int len, register int sh)
{
        register int i;

        for (i = 0; i < len; i++)
 804ce87:	83 c6 01             	add    $0x1,%esi
 804ce8a:	3b 75 0c             	cmp    0xc(%ebp),%esi
 804ce8d:	7c ac                	jl     804ce3b <shl+0xf>
                p[i] = LHALF(p[i] << sh) | (p[i + 1] >> (HALF_BITS - sh));
        p[i] = LHALF(p[i] << sh);
 804ce8f:	89 f0                	mov    %esi,%eax
 804ce91:	c1 e0 02             	shl    $0x2,%eax
 804ce94:	03 45 08             	add    0x8(%ebp),%eax
 804ce97:	89 f2                	mov    %esi,%edx
 804ce99:	c1 e2 02             	shl    $0x2,%edx
 804ce9c:	03 55 08             	add    0x8(%ebp),%edx
 804ce9f:	8b 12                	mov    (%edx),%edx
 804cea1:	0f b6 4d 10          	movzbl 0x10(%ebp),%ecx
 804cea5:	d3 e2                	shl    %cl,%edx
 804cea7:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804cead:	89 10                	mov    %edx,(%eax)
}
 804ceaf:	83 c4 08             	add    $0x8,%esp
 804ceb2:	5e                   	pop    %esi
 804ceb3:	5f                   	pop    %edi
 804ceb4:	5d                   	pop    %ebp
 804ceb5:	c3                   	ret    

0804ceb6 <__qdivrem>:
 * divisor are 4 `digits' in this base (they are shorter if they have
 * leading zeros).
 */
unsigned long long
__qdivrem(unsigned long long uq, unsigned long long vq, unsigned long long *arq)
{
 804ceb6:	55                   	push   %ebp
 804ceb7:	89 e5                	mov    %esp,%ebp
 804ceb9:	57                   	push   %edi
 804ceba:	56                   	push   %esi
 804cebb:	53                   	push   %ebx
 804cebc:	81 ec c8 00 00 00    	sub    $0xc8,%esp
 804cec2:	e8 5a b6 ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804cec7:	81 c3 b9 32 00 00    	add    $0x32b9,%ebx
 804cecd:	8b 45 08             	mov    0x8(%ebp),%eax
 804ced0:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
 804ced6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ced9:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
 804cedf:	8b 45 10             	mov    0x10(%ebp),%eax
 804cee2:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
 804cee8:	8b 45 14             	mov    0x14(%ebp),%eax
 804ceeb:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
        digit uspace[5], vspace[5], qspace[5];

        /*
         * Take care of special cases: divide by zero, and u < v.
         */
        if (vq == 0) {
 804cef1:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
 804cef7:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
 804cefd:	09 d0                	or     %edx,%eax
 804ceff:	85 c0                	test   %eax,%eax
 804cf01:	75 4a                	jne    804cf4d <__qdivrem+0x97>
                /* divide by zero. */
                static volatile const unsigned int zero = 0;

                tmp.ul[H] = tmp.ul[L] = 1 / zero;
 804cf03:	8b 93 68 01 00 00    	mov    0x168(%ebx),%edx
 804cf09:	89 95 40 ff ff ff    	mov    %edx,-0xc0(%ebp)
 804cf0f:	b8 01 00 00 00       	mov    $0x1,%eax
 804cf14:	ba 00 00 00 00       	mov    $0x0,%edx
 804cf19:	f7 b5 40 ff ff ff    	divl   -0xc0(%ebp)
 804cf1f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804cf22:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804cf25:	89 45 a8             	mov    %eax,-0x58(%ebp)
                if (arq)
 804cf28:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804cf2c:	74 14                	je     804cf42 <__qdivrem+0x8c>
                        *arq = uq;
 804cf2e:	8b 4d 18             	mov    0x18(%ebp),%ecx
 804cf31:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 804cf37:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 804cf3d:	89 01                	mov    %eax,(%ecx)
 804cf3f:	89 51 04             	mov    %edx,0x4(%ecx)
                return (tmp.q);
 804cf42:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804cf45:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804cf48:	e9 c5 05 00 00       	jmp    804d512 <__qdivrem+0x65c>
        }
        if (uq < vq) {
 804cf4d:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 804cf53:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 804cf59:	3b 95 54 ff ff ff    	cmp    -0xac(%ebp),%edx
 804cf5f:	77 39                	ja     804cf9a <__qdivrem+0xe4>
 804cf61:	3b 95 54 ff ff ff    	cmp    -0xac(%ebp),%edx
 804cf67:	72 08                	jb     804cf71 <__qdivrem+0xbb>
 804cf69:	3b 85 50 ff ff ff    	cmp    -0xb0(%ebp),%eax
 804cf6f:	73 29                	jae    804cf9a <__qdivrem+0xe4>
                if (arq)
 804cf71:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804cf75:	74 14                	je     804cf8b <__qdivrem+0xd5>
                        *arq = uq;
 804cf77:	8b 4d 18             	mov    0x18(%ebp),%ecx
 804cf7a:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 804cf80:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 804cf86:	89 01                	mov    %eax,(%ecx)
 804cf88:	89 51 04             	mov    %edx,0x4(%ecx)
                return (0);
 804cf8b:	b8 00 00 00 00       	mov    $0x0,%eax
 804cf90:	ba 00 00 00 00       	mov    $0x0,%edx
 804cf95:	e9 78 05 00 00       	jmp    804d512 <__qdivrem+0x65c>
        }
        u = &uspace[0];
 804cf9a:	8d 45 90             	lea    -0x70(%ebp),%eax
 804cf9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
        v = &vspace[0];
 804cfa0:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
 804cfa6:	89 45 e8             	mov    %eax,-0x18(%ebp)
        q = &qspace[0];
 804cfa9:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
 804cfaf:	89 45 c4             	mov    %eax,-0x3c(%ebp)
         *      m >= 0 (otherwise u < v, which we already checked)
         *      m + n = 4
         * and thus
         *      m = 4 - n <= 2
         */
        tmp.uq = uq;
 804cfb2:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 804cfb8:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 804cfbe:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804cfc1:	89 55 a8             	mov    %edx,-0x58(%ebp)
        u[0] = 0;
 804cfc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cfc7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        u[1] = HHALF(tmp.ul[H]);
 804cfcd:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cfd0:	83 c0 04             	add    $0x4,%eax
 804cfd3:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804cfd6:	c1 ea 10             	shr    $0x10,%edx
 804cfd9:	89 10                	mov    %edx,(%eax)
        u[2] = LHALF(tmp.ul[H]);
 804cfdb:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cfde:	83 c0 08             	add    $0x8,%eax
 804cfe1:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804cfe4:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804cfea:	89 10                	mov    %edx,(%eax)
        u[3] = HHALF(tmp.ul[L]);
 804cfec:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cfef:	83 c0 0c             	add    $0xc,%eax
 804cff2:	8b 55 a4             	mov    -0x5c(%ebp),%edx
 804cff5:	c1 ea 10             	shr    $0x10,%edx
 804cff8:	89 10                	mov    %edx,(%eax)
        u[4] = LHALF(tmp.ul[L]);
 804cffa:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cffd:	83 c0 10             	add    $0x10,%eax
 804d000:	8b 55 a4             	mov    -0x5c(%ebp),%edx
 804d003:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804d009:	89 10                	mov    %edx,(%eax)
        tmp.uq = vq;
 804d00b:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
 804d011:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
 804d017:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804d01a:	89 55 a8             	mov    %edx,-0x58(%ebp)
        v[1] = HHALF(tmp.ul[H]);
 804d01d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d020:	83 c0 04             	add    $0x4,%eax
 804d023:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804d026:	c1 ea 10             	shr    $0x10,%edx
 804d029:	89 10                	mov    %edx,(%eax)
        v[2] = LHALF(tmp.ul[H]);
 804d02b:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d02e:	83 c0 08             	add    $0x8,%eax
 804d031:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804d034:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804d03a:	89 10                	mov    %edx,(%eax)
        v[3] = HHALF(tmp.ul[L]);
 804d03c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d03f:	83 c0 0c             	add    $0xc,%eax
 804d042:	8b 55 a4             	mov    -0x5c(%ebp),%edx
 804d045:	c1 ea 10             	shr    $0x10,%edx
 804d048:	89 10                	mov    %edx,(%eax)
        v[4] = LHALF(tmp.ul[L]);
 804d04a:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d04d:	83 c0 10             	add    $0x10,%eax
 804d050:	8b 55 a4             	mov    -0x5c(%ebp),%edx
 804d053:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804d059:	89 10                	mov    %edx,(%eax)
        for (n = 4; v[1] == 0; v++) {
 804d05b:	c7 45 d4 04 00 00 00 	movl   $0x4,-0x2c(%ebp)
 804d062:	e9 fd 00 00 00       	jmp    804d164 <__qdivrem+0x2ae>
                if (--n == 1) {
 804d067:	83 6d d4 01          	subl   $0x1,-0x2c(%ebp)
 804d06b:	83 7d d4 01          	cmpl   $0x1,-0x2c(%ebp)
 804d06f:	0f 85 eb 00 00 00    	jne    804d160 <__qdivrem+0x2aa>
                         *      for j = 1..4:
                         *              q[j] = floor((r*B + u[j]) / v),
                         *              r = (r*B + u[j]) % v;
                         * We unroll this completely here.
                         */
                        t = v[2];       /* nonzero, by definition */
 804d075:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d078:	8b 40 08             	mov    0x8(%eax),%eax
 804d07b:	89 45 dc             	mov    %eax,-0x24(%ebp)
                        q1 = u[1] / t;
 804d07e:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d081:	83 c0 04             	add    $0x4,%eax
 804d084:	8b 00                	mov    (%eax),%eax
 804d086:	ba 00 00 00 00       	mov    $0x0,%edx
 804d08b:	f7 75 dc             	divl   -0x24(%ebp)
 804d08e:	89 45 c0             	mov    %eax,-0x40(%ebp)
                        rbj = COMBINE(u[1] % t, u[2]);
 804d091:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d094:	83 c0 04             	add    $0x4,%eax
 804d097:	8b 00                	mov    (%eax),%eax
 804d099:	ba 00 00 00 00       	mov    $0x0,%edx
 804d09e:	f7 75 dc             	divl   -0x24(%ebp)
 804d0a1:	89 d0                	mov    %edx,%eax
 804d0a3:	89 c2                	mov    %eax,%edx
 804d0a5:	c1 e2 10             	shl    $0x10,%edx
 804d0a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d0ab:	83 c0 08             	add    $0x8,%eax
 804d0ae:	8b 00                	mov    (%eax),%eax
 804d0b0:	09 d0                	or     %edx,%eax
 804d0b2:	89 45 bc             	mov    %eax,-0x44(%ebp)
                        q2 = rbj / t;
 804d0b5:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804d0b8:	ba 00 00 00 00       	mov    $0x0,%edx
 804d0bd:	f7 75 dc             	divl   -0x24(%ebp)
 804d0c0:	89 45 b8             	mov    %eax,-0x48(%ebp)
                        rbj = COMBINE(rbj % t, u[3]);
 804d0c3:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804d0c6:	ba 00 00 00 00       	mov    $0x0,%edx
 804d0cb:	f7 75 dc             	divl   -0x24(%ebp)
 804d0ce:	89 d0                	mov    %edx,%eax
 804d0d0:	89 c2                	mov    %eax,%edx
 804d0d2:	c1 e2 10             	shl    $0x10,%edx
 804d0d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d0d8:	83 c0 0c             	add    $0xc,%eax
 804d0db:	8b 00                	mov    (%eax),%eax
 804d0dd:	09 d0                	or     %edx,%eax
 804d0df:	89 45 bc             	mov    %eax,-0x44(%ebp)
                        q3 = rbj / t;
 804d0e2:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804d0e5:	ba 00 00 00 00       	mov    $0x0,%edx
 804d0ea:	f7 75 dc             	divl   -0x24(%ebp)
 804d0ed:	89 45 b4             	mov    %eax,-0x4c(%ebp)
                        rbj = COMBINE(rbj % t, u[4]);
 804d0f0:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804d0f3:	ba 00 00 00 00       	mov    $0x0,%edx
 804d0f8:	f7 75 dc             	divl   -0x24(%ebp)
 804d0fb:	89 d0                	mov    %edx,%eax
 804d0fd:	89 c2                	mov    %eax,%edx
 804d0ff:	c1 e2 10             	shl    $0x10,%edx
 804d102:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d105:	83 c0 10             	add    $0x10,%eax
 804d108:	8b 00                	mov    (%eax),%eax
 804d10a:	09 d0                	or     %edx,%eax
 804d10c:	89 45 bc             	mov    %eax,-0x44(%ebp)
                        q4 = rbj / t;
 804d10f:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804d112:	ba 00 00 00 00       	mov    $0x0,%edx
 804d117:	f7 75 dc             	divl   -0x24(%ebp)
 804d11a:	89 45 b0             	mov    %eax,-0x50(%ebp)
                        if (arq)
 804d11d:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804d121:	74 1a                	je     804d13d <__qdivrem+0x287>
                                *arq = rbj % t;
 804d123:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804d126:	ba 00 00 00 00       	mov    $0x0,%edx
 804d12b:	f7 75 dc             	divl   -0x24(%ebp)
 804d12e:	89 d0                	mov    %edx,%eax
 804d130:	ba 00 00 00 00       	mov    $0x0,%edx
 804d135:	8b 4d 18             	mov    0x18(%ebp),%ecx
 804d138:	89 01                	mov    %eax,(%ecx)
 804d13a:	89 51 04             	mov    %edx,0x4(%ecx)
                        tmp.ul[H] = COMBINE(q1, q2);
 804d13d:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804d140:	c1 e0 10             	shl    $0x10,%eax
 804d143:	0b 45 b8             	or     -0x48(%ebp),%eax
 804d146:	89 45 a8             	mov    %eax,-0x58(%ebp)
                        tmp.ul[L] = COMBINE(q3, q4);
 804d149:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804d14c:	c1 e0 10             	shl    $0x10,%eax
 804d14f:	0b 45 b0             	or     -0x50(%ebp),%eax
 804d152:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                        return (tmp.q);
 804d155:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804d158:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804d15b:	e9 b2 03 00 00       	jmp    804d512 <__qdivrem+0x65c>
        tmp.uq = vq;
        v[1] = HHALF(tmp.ul[H]);
        v[2] = LHALF(tmp.ul[H]);
        v[3] = HHALF(tmp.ul[L]);
        v[4] = LHALF(tmp.ul[L]);
        for (n = 4; v[1] == 0; v++) {
 804d160:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
 804d164:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d167:	83 c0 04             	add    $0x4,%eax
 804d16a:	8b 00                	mov    (%eax),%eax
 804d16c:	85 c0                	test   %eax,%eax
 804d16e:	0f 84 f3 fe ff ff    	je     804d067 <__qdivrem+0x1b1>
        /*
         * By adjusting q once we determine m, we can guarantee that
         * there is a complete four-digit quotient at &qspace[1] when
         * we finally stop.
         */
        for (m = 4 - n; u[1] == 0; u++)
 804d174:	b8 04 00 00 00       	mov    $0x4,%eax
 804d179:	2b 45 d4             	sub    -0x2c(%ebp),%eax
 804d17c:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804d17f:	eb 08                	jmp    804d189 <__qdivrem+0x2d3>
                m--;
 804d181:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
        /*
         * By adjusting q once we determine m, we can guarantee that
         * there is a complete four-digit quotient at &qspace[1] when
         * we finally stop.
         */
        for (m = 4 - n; u[1] == 0; u++)
 804d185:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
 804d189:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d18c:	83 c0 04             	add    $0x4,%eax
 804d18f:	8b 00                	mov    (%eax),%eax
 804d191:	85 c0                	test   %eax,%eax
 804d193:	74 ec                	je     804d181 <__qdivrem+0x2cb>
                m--;
        for (i = 4 - m; --i >= 0;)
 804d195:	b8 04 00 00 00       	mov    $0x4,%eax
 804d19a:	2b 45 d8             	sub    -0x28(%ebp),%eax
 804d19d:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804d1a0:	eb 0f                	jmp    804d1b1 <__qdivrem+0x2fb>
                q[i] = 0;
 804d1a2:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804d1a5:	c1 e0 02             	shl    $0x2,%eax
 804d1a8:	03 45 c4             	add    -0x3c(%ebp),%eax
 804d1ab:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
         * there is a complete four-digit quotient at &qspace[1] when
         * we finally stop.
         */
        for (m = 4 - n; u[1] == 0; u++)
                m--;
        for (i = 4 - m; --i >= 0;)
 804d1b1:	83 6d c8 01          	subl   $0x1,-0x38(%ebp)
 804d1b5:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804d1b9:	79 e7                	jns    804d1a2 <__qdivrem+0x2ec>
                q[i] = 0;
        q += 4 - m;
 804d1bb:	b8 04 00 00 00       	mov    $0x4,%eax
 804d1c0:	2b 45 d8             	sub    -0x28(%ebp),%eax
 804d1c3:	c1 e0 02             	shl    $0x2,%eax
 804d1c6:	01 45 c4             	add    %eax,-0x3c(%ebp)
         * Here we run Program D, translated from MIX to C and acquiring
         * a few minor changes.
         *
         * D1: choose multiplier 1 << d to ensure v[1] >= B/2.
         */
        d = 0;
 804d1c9:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
        for (t = v[1]; t < B / 2; t <<= 1)
 804d1d0:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d1d3:	8b 40 04             	mov    0x4(%eax),%eax
 804d1d6:	89 45 dc             	mov    %eax,-0x24(%ebp)
 804d1d9:	eb 07                	jmp    804d1e2 <__qdivrem+0x32c>
                d++;
 804d1db:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
         * a few minor changes.
         *
         * D1: choose multiplier 1 << d to ensure v[1] >= B/2.
         */
        d = 0;
        for (t = v[1]; t < B / 2; t <<= 1)
 804d1df:	d1 65 dc             	shll   -0x24(%ebp)
 804d1e2:	81 7d dc ff 7f 00 00 	cmpl   $0x7fff,-0x24(%ebp)
 804d1e9:	76 f0                	jbe    804d1db <__qdivrem+0x325>
                d++;
        if (d > 0) {
 804d1eb:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804d1ef:	7e 3d                	jle    804d22e <__qdivrem+0x378>
                shl(&u[0], m + n, d);           /* u <<= d */
 804d1f1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804d1f4:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804d1f7:	01 c2                	add    %eax,%edx
 804d1f9:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804d1fc:	89 44 24 08          	mov    %eax,0x8(%esp)
 804d200:	89 54 24 04          	mov    %edx,0x4(%esp)
 804d204:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d207:	89 04 24             	mov    %eax,(%esp)
 804d20a:	e8 1d fc ff ff       	call   804ce2c <shl>
                shl(&v[1], n - 1, d);           /* v <<= d */
 804d20f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804d212:	8d 48 ff             	lea    -0x1(%eax),%ecx
 804d215:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d218:	8d 50 04             	lea    0x4(%eax),%edx
 804d21b:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804d21e:	89 44 24 08          	mov    %eax,0x8(%esp)
 804d222:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 804d226:	89 14 24             	mov    %edx,(%esp)
 804d229:	e8 fe fb ff ff       	call   804ce2c <shl>
        }
        /*
         * D2: j = 0.
         */
        j = 0;
 804d22e:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
        v1 = v[1];      /* for D3 -- note that v[1..n] are constant */
 804d235:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d238:	8b 70 04             	mov    0x4(%eax),%esi
        v2 = v[2];      /* for D3 */
 804d23b:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d23e:	8b 40 08             	mov    0x8(%eax),%eax
 804d241:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
                 * let rhat = (u[j]*B + u[j+1]) mod v[1].
                 * While rhat < B and v[2]*qhat > rhat*B+u[j+2],
                 * decrement qhat and increase rhat correspondingly.
                 * Note that if rhat >= B, v[2]*qhat < rhat*B.
                 */
                uj0 = u[j + 0]; /* for D3 only -- note that u[j+...] change */
 804d247:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804d24a:	c1 e0 02             	shl    $0x2,%eax
 804d24d:	03 45 ec             	add    -0x14(%ebp),%eax
 804d250:	8b 00                	mov    (%eax),%eax
 804d252:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
                uj1 = u[j + 1]; /* for D3 only */
 804d258:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804d25b:	83 c0 01             	add    $0x1,%eax
 804d25e:	c1 e0 02             	shl    $0x2,%eax
 804d261:	03 45 ec             	add    -0x14(%ebp),%eax
 804d264:	8b 38                	mov    (%eax),%edi
                uj2 = u[j + 2]; /* for D3 only */
 804d266:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804d269:	83 c0 02             	add    $0x2,%eax
 804d26c:	c1 e0 02             	shl    $0x2,%eax
 804d26f:	03 45 ec             	add    -0x14(%ebp),%eax
 804d272:	8b 00                	mov    (%eax),%eax
 804d274:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
                if (uj0 == v1) {
 804d27a:	39 b5 48 ff ff ff    	cmp    %esi,-0xb8(%ebp)
 804d280:	75 0c                	jne    804d28e <__qdivrem+0x3d8>
                        qhat = B;
 804d282:	c7 45 e4 00 00 01 00 	movl   $0x10000,-0x1c(%ebp)
                        rhat = uj1;
 804d289:	89 7d e0             	mov    %edi,-0x20(%ebp)
                        goto qhat_too_big;
 804d28c:	eb 2a                	jmp    804d2b8 <__qdivrem+0x402>
                } else {
                        unsigned long nn = COMBINE(uj0, uj1);
 804d28e:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
 804d294:	c1 e0 10             	shl    $0x10,%eax
 804d297:	09 f8                	or     %edi,%eax
 804d299:	89 45 ac             	mov    %eax,-0x54(%ebp)
                        qhat = nn / v1;
 804d29c:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804d29f:	ba 00 00 00 00       	mov    $0x0,%edx
 804d2a4:	f7 f6                	div    %esi
 804d2a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                        rhat = nn % v1;
 804d2a9:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804d2ac:	ba 00 00 00 00       	mov    $0x0,%edx
 804d2b1:	f7 f6                	div    %esi
 804d2b3:	89 55 e0             	mov    %edx,-0x20(%ebp)
                }
                while (v2 * qhat > COMBINE(rhat, uj2)) {
 804d2b6:	eb 10                	jmp    804d2c8 <__qdivrem+0x412>
qhat_too_big:
                        qhat--;
 804d2b8:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
                        if ((rhat += v1) >= B)
 804d2bc:	01 75 e0             	add    %esi,-0x20(%ebp)
 804d2bf:	81 7d e0 ff ff 00 00 	cmpl   $0xffff,-0x20(%ebp)
 804d2c6:	77 1c                	ja     804d2e4 <__qdivrem+0x42e>
                } else {
                        unsigned long nn = COMBINE(uj0, uj1);
                        qhat = nn / v1;
                        rhat = nn % v1;
                }
                while (v2 * qhat > COMBINE(rhat, uj2)) {
 804d2c8:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
 804d2ce:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
 804d2d2:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804d2d5:	c1 e2 10             	shl    $0x10,%edx
 804d2d8:	0b 95 44 ff ff ff    	or     -0xbc(%ebp),%edx
 804d2de:	39 d0                	cmp    %edx,%eax
 804d2e0:	77 d6                	ja     804d2b8 <__qdivrem+0x402>
 804d2e2:	eb 01                	jmp    804d2e5 <__qdivrem+0x42f>
qhat_too_big:
                        qhat--;
                        if ((rhat += v1) >= B)
                                break;
 804d2e4:	90                   	nop
                 * D4: Multiply and subtract.
                 * The variable `t' holds any borrows across the loop.
                 * We split this up so that we do not require v[0] = 0,
                 * and to eliminate a final special case.
                 */
                for (t = 0, i = n; i > 0; i--) {
 804d2e5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 804d2ec:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804d2ef:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804d2f2:	eb 58                	jmp    804d34c <__qdivrem+0x496>
                        t = u[i + j] - v[i] * qhat - t;
 804d2f4:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804d2f7:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804d2fa:	01 d0                	add    %edx,%eax
 804d2fc:	c1 e0 02             	shl    $0x2,%eax
 804d2ff:	03 45 ec             	add    -0x14(%ebp),%eax
 804d302:	8b 10                	mov    (%eax),%edx
 804d304:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804d307:	c1 e0 02             	shl    $0x2,%eax
 804d30a:	03 45 e8             	add    -0x18(%ebp),%eax
 804d30d:	8b 00                	mov    (%eax),%eax
 804d30f:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
 804d313:	89 d1                	mov    %edx,%ecx
 804d315:	29 c1                	sub    %eax,%ecx
 804d317:	89 c8                	mov    %ecx,%eax
 804d319:	2b 45 dc             	sub    -0x24(%ebp),%eax
 804d31c:	89 45 dc             	mov    %eax,-0x24(%ebp)
                        u[i + j] = LHALF(t);
 804d31f:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804d322:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804d325:	01 d0                	add    %edx,%eax
 804d327:	c1 e0 02             	shl    $0x2,%eax
 804d32a:	03 45 ec             	add    -0x14(%ebp),%eax
 804d32d:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804d330:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804d336:	89 10                	mov    %edx,(%eax)
                        t = (B - HHALF(t)) & (B - 1);
 804d338:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804d33b:	c1 e8 10             	shr    $0x10,%eax
 804d33e:	f7 d8                	neg    %eax
 804d340:	25 ff ff 00 00       	and    $0xffff,%eax
 804d345:	89 45 dc             	mov    %eax,-0x24(%ebp)
                 * D4: Multiply and subtract.
                 * The variable `t' holds any borrows across the loop.
                 * We split this up so that we do not require v[0] = 0,
                 * and to eliminate a final special case.
                 */
                for (t = 0, i = n; i > 0; i--) {
 804d348:	83 6d c8 01          	subl   $0x1,-0x38(%ebp)
 804d34c:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804d350:	7f a2                	jg     804d2f4 <__qdivrem+0x43e>
                        t = u[i + j] - v[i] * qhat - t;
                        u[i + j] = LHALF(t);
                        t = (B - HHALF(t)) & (B - 1);
                }
                t = u[j] - t;
 804d352:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804d355:	c1 e0 02             	shl    $0x2,%eax
 804d358:	03 45 ec             	add    -0x14(%ebp),%eax
 804d35b:	8b 00                	mov    (%eax),%eax
 804d35d:	2b 45 dc             	sub    -0x24(%ebp),%eax
 804d360:	89 45 dc             	mov    %eax,-0x24(%ebp)
                u[j] = LHALF(t);
 804d363:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804d366:	c1 e0 02             	shl    $0x2,%eax
 804d369:	03 45 ec             	add    -0x14(%ebp),%eax
 804d36c:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804d36f:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804d375:	89 10                	mov    %edx,(%eax)
                 * D5: test remainder.
                 * There is a borrow if and only if HHALF(t) is nonzero;
                 * in that (rare) case, qhat was too large (by exactly 1).
                 * Fix it by adding v[1..n] to u[j..j+n].
                 */
                if (HHALF(t)) {
 804d377:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804d37a:	c1 e8 10             	shr    $0x10,%eax
 804d37d:	85 c0                	test   %eax,%eax
 804d37f:	74 79                	je     804d3fa <__qdivrem+0x544>
                        qhat--;
 804d381:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
                        for (t = 0, i = n; i > 0; i--) { /* D6: add back. */
 804d385:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 804d38c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804d38f:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804d392:	eb 41                	jmp    804d3d5 <__qdivrem+0x51f>
                                t += u[i + j] + v[i];
 804d394:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804d397:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804d39a:	01 d0                	add    %edx,%eax
 804d39c:	c1 e0 02             	shl    $0x2,%eax
 804d39f:	03 45 ec             	add    -0x14(%ebp),%eax
 804d3a2:	8b 10                	mov    (%eax),%edx
 804d3a4:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804d3a7:	c1 e0 02             	shl    $0x2,%eax
 804d3aa:	03 45 e8             	add    -0x18(%ebp),%eax
 804d3ad:	8b 00                	mov    (%eax),%eax
 804d3af:	01 d0                	add    %edx,%eax
 804d3b1:	01 45 dc             	add    %eax,-0x24(%ebp)
                                u[i + j] = LHALF(t);
 804d3b4:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804d3b7:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804d3ba:	01 d0                	add    %edx,%eax
 804d3bc:	c1 e0 02             	shl    $0x2,%eax
 804d3bf:	03 45 ec             	add    -0x14(%ebp),%eax
 804d3c2:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804d3c5:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804d3cb:	89 10                	mov    %edx,(%eax)
                                t = HHALF(t);
 804d3cd:	c1 6d dc 10          	shrl   $0x10,-0x24(%ebp)
                 * in that (rare) case, qhat was too large (by exactly 1).
                 * Fix it by adding v[1..n] to u[j..j+n].
                 */
                if (HHALF(t)) {
                        qhat--;
                        for (t = 0, i = n; i > 0; i--) { /* D6: add back. */
 804d3d1:	83 6d c8 01          	subl   $0x1,-0x38(%ebp)
 804d3d5:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804d3d9:	7f b9                	jg     804d394 <__qdivrem+0x4de>
                                t += u[i + j] + v[i];
                                u[i + j] = LHALF(t);
                                t = HHALF(t);
                        }
                        u[j] = LHALF(u[j] + t);
 804d3db:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804d3de:	c1 e0 02             	shl    $0x2,%eax
 804d3e1:	03 45 ec             	add    -0x14(%ebp),%eax
 804d3e4:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804d3e7:	c1 e2 02             	shl    $0x2,%edx
 804d3ea:	03 55 ec             	add    -0x14(%ebp),%edx
 804d3ed:	8b 12                	mov    (%edx),%edx
 804d3ef:	03 55 dc             	add    -0x24(%ebp),%edx
 804d3f2:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804d3f8:	89 10                	mov    %edx,(%eax)
                }
                q[j] = qhat;
 804d3fa:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804d3fd:	c1 e0 02             	shl    $0x2,%eax
 804d400:	03 45 c4             	add    -0x3c(%ebp),%eax
 804d403:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804d406:	89 10                	mov    %edx,(%eax)
        } while (++j <= m);             /* D7: loop on j. */
 804d408:	83 45 cc 01          	addl   $0x1,-0x34(%ebp)
 804d40c:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804d40f:	3b 45 d8             	cmp    -0x28(%ebp),%eax
 804d412:	0f 8e 2f fe ff ff    	jle    804d247 <__qdivrem+0x391>
        /*
         * If caller wants the remainder, we have to calculate it as
         * u[m..m+n] >> d (this is at most n digits and thus fits in
         * u[m+1..m+n], but we may need more source digits).
         */
        if (arq) {
 804d418:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804d41c:	0f 84 be 00 00 00    	je     804d4e0 <__qdivrem+0x62a>
                if (d) {
 804d422:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804d426:	0f 84 86 00 00 00    	je     804d4b2 <__qdivrem+0x5fc>
                        for (i = m + n; i > m; --i)
 804d42c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804d42f:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804d432:	01 d0                	add    %edx,%eax
 804d434:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804d437:	eb 62                	jmp    804d49b <__qdivrem+0x5e5>
                                u[i] = (u[i] >> d) |
 804d439:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804d43c:	c1 e0 02             	shl    $0x2,%eax
 804d43f:	03 45 ec             	add    -0x14(%ebp),%eax
 804d442:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804d445:	c1 e2 02             	shl    $0x2,%edx
 804d448:	03 55 ec             	add    -0x14(%ebp),%edx
 804d44b:	8b 32                	mov    (%edx),%esi
 804d44d:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804d450:	89 f7                	mov    %esi,%edi
 804d452:	89 d1                	mov    %edx,%ecx
 804d454:	d3 ef                	shr    %cl,%edi
                                       LHALF(u[i - 1] << (HALF_BITS - d));
 804d456:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804d459:	83 ea 01             	sub    $0x1,%edx
 804d45c:	c1 e2 02             	shl    $0x2,%edx
 804d45f:	03 55 ec             	add    -0x14(%ebp),%edx
 804d462:	8b 12                	mov    (%edx),%edx
 804d464:	89 95 3c ff ff ff    	mov    %edx,-0xc4(%ebp)
 804d46a:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804d46d:	c7 85 38 ff ff ff 10 	movl   $0x10,-0xc8(%ebp)
 804d474:	00 00 00 
 804d477:	8b b5 38 ff ff ff    	mov    -0xc8(%ebp),%esi
 804d47d:	29 d6                	sub    %edx,%esi
 804d47f:	89 f2                	mov    %esi,%edx
 804d481:	8b b5 3c ff ff ff    	mov    -0xc4(%ebp),%esi
 804d487:	89 d1                	mov    %edx,%ecx
 804d489:	d3 e6                	shl    %cl,%esi
 804d48b:	89 f2                	mov    %esi,%edx
 804d48d:	81 e2 ff ff 00 00    	and    $0xffff,%edx
         * u[m+1..m+n], but we may need more source digits).
         */
        if (arq) {
                if (d) {
                        for (i = m + n; i > m; --i)
                                u[i] = (u[i] >> d) |
 804d493:	09 fa                	or     %edi,%edx
 804d495:	89 10                	mov    %edx,(%eax)
         * u[m..m+n] >> d (this is at most n digits and thus fits in
         * u[m+1..m+n], but we may need more source digits).
         */
        if (arq) {
                if (d) {
                        for (i = m + n; i > m; --i)
 804d497:	83 6d c8 01          	subl   $0x1,-0x38(%ebp)
 804d49b:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804d49e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
 804d4a1:	7f 96                	jg     804d439 <__qdivrem+0x583>
                                u[i] = (u[i] >> d) |
                                       LHALF(u[i - 1] << (HALF_BITS - d));
                        u[i] = 0;
 804d4a3:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804d4a6:	c1 e0 02             	shl    $0x2,%eax
 804d4a9:	03 45 ec             	add    -0x14(%ebp),%eax
 804d4ac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                }
                tmp.ul[H] = COMBINE(uspace[1], uspace[2]);
 804d4b2:	8b 45 94             	mov    -0x6c(%ebp),%eax
 804d4b5:	89 c2                	mov    %eax,%edx
 804d4b7:	c1 e2 10             	shl    $0x10,%edx
 804d4ba:	8b 45 98             	mov    -0x68(%ebp),%eax
 804d4bd:	09 d0                	or     %edx,%eax
 804d4bf:	89 45 a8             	mov    %eax,-0x58(%ebp)
                tmp.ul[L] = COMBINE(uspace[3], uspace[4]);
 804d4c2:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804d4c5:	89 c2                	mov    %eax,%edx
 804d4c7:	c1 e2 10             	shl    $0x10,%edx
 804d4ca:	8b 45 a0             	mov    -0x60(%ebp),%eax
 804d4cd:	09 d0                	or     %edx,%eax
 804d4cf:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                *arq = tmp.q;
 804d4d2:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804d4d5:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804d4d8:	8b 4d 18             	mov    0x18(%ebp),%ecx
 804d4db:	89 01                	mov    %eax,(%ecx)
 804d4dd:	89 51 04             	mov    %edx,0x4(%ecx)
        }

        tmp.ul[H] = COMBINE(qspace[1], qspace[2]);
 804d4e0:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
 804d4e6:	89 c2                	mov    %eax,%edx
 804d4e8:	c1 e2 10             	shl    $0x10,%edx
 804d4eb:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
 804d4f1:	09 d0                	or     %edx,%eax
 804d4f3:	89 45 a8             	mov    %eax,-0x58(%ebp)
        tmp.ul[L] = COMBINE(qspace[3], qspace[4]);
 804d4f6:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
 804d4fc:	89 c2                	mov    %eax,%edx
 804d4fe:	c1 e2 10             	shl    $0x10,%edx
 804d501:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
 804d507:	09 d0                	or     %edx,%eax
 804d509:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        return (tmp.q);
 804d50c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804d50f:	8b 55 a8             	mov    -0x58(%ebp),%edx
}
 804d512:	81 c4 c8 00 00 00    	add    $0xc8,%esp
 804d518:	5b                   	pop    %ebx
 804d519:	5e                   	pop    %esi
 804d51a:	5f                   	pop    %edi
 804d51b:	5d                   	pop    %ebp
 804d51c:	c3                   	ret    

0804d51d <__divdi3>:
/*
 * Divide two signed quads.
 * ??? if -1/2 should produce -1 on this machine, this code is wrong
 */
long long __divdi3(long long a, long long b)
{
 804d51d:	55                   	push   %ebp
 804d51e:	89 e5                	mov    %esp,%ebp
 804d520:	53                   	push   %ebx
 804d521:	83 ec 54             	sub    $0x54,%esp
 804d524:	e8 f8 af ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804d529:	81 c3 57 2c 00 00    	add    $0x2c57,%ebx
 804d52f:	8b 45 08             	mov    0x8(%ebp),%eax
 804d532:	89 45 d0             	mov    %eax,-0x30(%ebp)
 804d535:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d538:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804d53b:	8b 45 10             	mov    0x10(%ebp),%eax
 804d53e:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804d541:	8b 45 14             	mov    0x14(%ebp),%eax
 804d544:	89 45 cc             	mov    %eax,-0x34(%ebp)
        unsigned long long ua, ub, uq;
        int neg;

        if (a < 0)
 804d547:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804d54b:	79 1c                	jns    804d569 <__divdi3+0x4c>
                ua = -(unsigned long long)a, neg = 1;
 804d54d:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804d550:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804d553:	f7 d8                	neg    %eax
 804d555:	83 d2 00             	adc    $0x0,%edx
 804d558:	f7 da                	neg    %edx
 804d55a:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804d55d:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804d560:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
 804d567:	eb 13                	jmp    804d57c <__divdi3+0x5f>
        else
                ua = a, neg = 0;
 804d569:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804d56c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804d56f:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804d572:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804d575:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if (b < 0)
 804d57c:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
 804d580:	79 19                	jns    804d59b <__divdi3+0x7e>
                ub = -(unsigned long long)b, neg ^= 1;
 804d582:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804d585:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804d588:	f7 d8                	neg    %eax
 804d58a:	83 d2 00             	adc    $0x0,%edx
 804d58d:	f7 da                	neg    %edx
 804d58f:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804d592:	89 55 ec             	mov    %edx,-0x14(%ebp)
 804d595:	83 75 e4 01          	xorl   $0x1,-0x1c(%ebp)
 804d599:	eb 0c                	jmp    804d5a7 <__divdi3+0x8a>
        else
                ub = b;
 804d59b:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804d59e:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804d5a1:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804d5a4:	89 55 ec             	mov    %edx,-0x14(%ebp)
        uq = __qdivrem(ua, ub, (unsigned long long *)0);
 804d5a7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804d5ae:	00 
 804d5af:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d5b2:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804d5b5:	89 44 24 08          	mov    %eax,0x8(%esp)
 804d5b9:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804d5bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804d5c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804d5c3:	89 04 24             	mov    %eax,(%esp)
 804d5c6:	89 54 24 04          	mov    %edx,0x4(%esp)
 804d5ca:	e8 e7 f8 ff ff       	call   804ceb6 <__qdivrem>
 804d5cf:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804d5d2:	89 55 dc             	mov    %edx,-0x24(%ebp)
        return (neg ? -uq : uq);
 804d5d5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804d5d9:	74 0f                	je     804d5ea <__divdi3+0xcd>
 804d5db:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804d5de:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804d5e1:	f7 d8                	neg    %eax
 804d5e3:	83 d2 00             	adc    $0x0,%edx
 804d5e6:	f7 da                	neg    %edx
 804d5e8:	eb 06                	jmp    804d5f0 <__divdi3+0xd3>
 804d5ea:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804d5ed:	8b 55 dc             	mov    -0x24(%ebp),%edx
}
 804d5f0:	83 c4 54             	add    $0x54,%esp
 804d5f3:	5b                   	pop    %ebx
 804d5f4:	5d                   	pop    %ebp
 804d5f5:	c3                   	ret    

0804d5f6 <__udivdi3>:
/*
 * Divide two unsigned quads.
 */
unsigned long long
__udivdi3(unsigned long long a, unsigned long long b)
{
 804d5f6:	55                   	push   %ebp
 804d5f7:	89 e5                	mov    %esp,%ebp
 804d5f9:	53                   	push   %ebx
 804d5fa:	83 ec 34             	sub    $0x34,%esp
 804d5fd:	e8 1f af ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804d602:	81 c3 7e 2b 00 00    	add    $0x2b7e,%ebx
 804d608:	8b 45 08             	mov    0x8(%ebp),%eax
 804d60b:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804d60e:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d611:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804d614:	8b 45 10             	mov    0x10(%ebp),%eax
 804d617:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804d61a:	8b 45 14             	mov    0x14(%ebp),%eax
 804d61d:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return (__qdivrem(a, b, (unsigned long long *)0));
 804d620:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804d627:	00 
 804d628:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d62b:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804d62e:	89 44 24 08          	mov    %eax,0x8(%esp)
 804d632:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804d636:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804d639:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804d63c:	89 04 24             	mov    %eax,(%esp)
 804d63f:	89 54 24 04          	mov    %edx,0x4(%esp)
 804d643:	e8 6e f8 ff ff       	call   804ceb6 <__qdivrem>
}
 804d648:	83 c4 34             	add    $0x34,%esp
 804d64b:	5b                   	pop    %ebx
 804d64c:	5d                   	pop    %ebp
 804d64d:	c3                   	ret    

0804d64e <__umoddi3>:
/*
 * Return remainder after dividing two unsigned quads.
 */
unsigned long long
__umoddi3(unsigned long long a, unsigned long long b)
{
 804d64e:	55                   	push   %ebp
 804d64f:	89 e5                	mov    %esp,%ebp
 804d651:	53                   	push   %ebx
 804d652:	83 ec 44             	sub    $0x44,%esp
 804d655:	e8 c7 ae ff ff       	call   8048521 <__i686.get_pc_thunk.bx>
 804d65a:	81 c3 26 2b 00 00    	add    $0x2b26,%ebx
 804d660:	8b 45 08             	mov    0x8(%ebp),%eax
 804d663:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804d666:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d669:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804d66c:	8b 45 10             	mov    0x10(%ebp),%eax
 804d66f:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804d672:	8b 45 14             	mov    0x14(%ebp),%eax
 804d675:	89 45 dc             	mov    %eax,-0x24(%ebp)
        unsigned long long r;

        (void)__qdivrem(a, b, &r);
 804d678:	8d 45 f0             	lea    -0x10(%ebp),%eax
 804d67b:	89 44 24 10          	mov    %eax,0x10(%esp)
 804d67f:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804d682:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804d685:	89 44 24 08          	mov    %eax,0x8(%esp)
 804d689:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804d68d:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804d690:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804d693:	89 04 24             	mov    %eax,(%esp)
 804d696:	89 54 24 04          	mov    %edx,0x4(%esp)
 804d69a:	e8 17 f8 ff ff       	call   804ceb6 <__qdivrem>
        return (r);
 804d69f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804d6a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
}
 804d6a5:	83 c4 44             	add    $0x44,%esp
 804d6a8:	5b                   	pop    %ebx
 804d6a9:	5d                   	pop    %ebp
 804d6aa:	c3                   	ret    
