
user/usr/bin/hello.exec:     file format elf32-i386


Disassembly of section .text:

08048094 <main>:

#include <unistd.h>
#include <fcntl.h>

int main(int argc, char **argv)
{
 8048094:	55                   	push   %ebp
 8048095:	89 e5                	mov    %esp,%ebp
 8048097:	83 e4 f0             	and    $0xfffffff0,%esp
 804809a:	83 ec 10             	sub    $0x10,%esp
				
        open("/dev/tty0", O_RDONLY, 0);
 804809d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 80480a4:	00 
 80480a5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 80480ac:	00 
 80480ad:	c7 04 24 a0 bd 04 08 	movl   $0x804bda0,(%esp)
 80480b4:	e8 28 06 00 00       	call   80486e1 <open>
	open("/dev/tty0", O_WRONLY, 0);
 80480b9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 80480c0:	00 
 80480c1:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 80480c8:	00 
 80480c9:	c7 04 24 a0 bd 04 08 	movl   $0x804bda0,(%esp)
 80480d0:	e8 0c 06 00 00       	call   80486e1 <open>
	
        write(2, "aaswerftgh\n", 10);
 80480d5:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
 80480dc:	00 
 80480dd:	c7 44 24 04 aa bd 04 	movl   $0x804bdaa,0x4(%esp)
 80480e4:	08 
 80480e5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 80480ec:	e8 29 07 00 00       	call   804881a <write>
	
        return 0;
 80480f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
 80480f6:	c9                   	leave  
 80480f7:	c3                   	ret    

080480f8 <__libc_static_entry>:
#ifndef __DYNAMIC__

.globl __libc_static_entry

__libc_static_entry:
	addl $4, %esp; /* Make sure when we overwrite dummy return address
 80480f8:	83 c4 04             	add    $0x4,%esp
	                  with the correct one, so args will be in the right
	                  place when we call main */
	call main;
 80480fb:	e8 94 ff ff ff       	call   8048094 <main>
	push %eax; /* Argument to exit is return value from main */
 8048100:	50                   	push   %eax
	call exit;
 8048101:	e8 6e 02 00 00       	call   8048374 <exit>
 8048106:	90                   	nop
 8048107:	90                   	nop

08048108 <trap>:
#include "errno.h"

#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
 8048108:	55                   	push   %ebp
 8048109:	89 e5                	mov    %esp,%ebp
 804810b:	56                   	push   %esi
 804810c:	83 ec 14             	sub    $0x14,%esp
 804810f:	e8 3f 0f 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 8048114:	81 c1 04 64 00 00    	add    $0x6404,%ecx
        int ret;
        __asm__ volatile(
 804811a:	8b 45 08             	mov    0x8(%ebp),%eax
 804811d:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8048120:	8b 55 0c             	mov    0xc(%ebp),%edx
 8048123:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048126:	cd 2e                	int    $0x2e
 8048128:	89 c6                	mov    %eax,%esi
 804812a:	89 75 f8             	mov    %esi,-0x8(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804812d:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8048134:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048137:	cd 2e                	int    $0x2e
 8048139:	89 c2                	mov    %eax,%edx
 804813b:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048141:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048143:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
 8048146:	83 c4 14             	add    $0x14,%esp
 8048149:	5e                   	pop    %esi
 804814a:	5d                   	pop    %ebp
 804814b:	c3                   	ret    

0804814c <sbrk>:
static void     (*atexit_func[MAX_EXIT_HANDLERS])();
static int      atexit_handlers = 0;


void *sbrk(intptr_t incr)
{
 804814c:	55                   	push   %ebp
 804814d:	89 e5                	mov    %esp,%ebp
 804814f:	56                   	push   %esi
 8048150:	53                   	push   %ebx
 8048151:	83 ec 30             	sub    $0x30,%esp
 8048154:	e8 fe 0e 00 00       	call   8049057 <__i686.get_pc_thunk.bx>
 8048159:	81 c3 bf 63 00 00    	add    $0x63bf,%ebx
        uintptr_t oldbrk;

        /* If we don't have a saved break, find it from the kernel */
        if (!__curbrk) {
 804815f:	8b 83 28 00 00 00    	mov    0x28(%ebx),%eax
 8048165:	85 c0                	test   %eax,%eax
 8048167:	75 51                	jne    80481ba <sbrk+0x6e>
 8048169:	c7 45 f0 2c 00 00 00 	movl   $0x2c,-0x10(%ebp)
 8048170:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048177:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804817a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804817d:	8b 55 ec             	mov    -0x14(%ebp),%edx
 8048180:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048183:	cd 2e                	int    $0x2e
 8048185:	89 c6                	mov    %eax,%esi
 8048187:	89 75 e8             	mov    %esi,-0x18(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804818a:	c7 45 e4 27 00 00 00 	movl   $0x27,-0x1c(%ebp)
 8048191:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048194:	cd 2e                	int    $0x2e
 8048196:	89 c2                	mov    %eax,%edx
 8048198:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 804819e:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80481a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
                if (0 > (long)(__curbrk = (void *) trap(SYS_brk, (uint32_t) NULL))) {
 80481a3:	89 83 28 00 00 00    	mov    %eax,0x28(%ebx)
 80481a9:	8b 83 28 00 00 00    	mov    0x28(%ebx),%eax
 80481af:	85 c0                	test   %eax,%eax
 80481b1:	79 07                	jns    80481ba <sbrk+0x6e>
                        return (void *) -1;
 80481b3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80481b8:	eb 5b                	jmp    8048215 <sbrk+0xc9>
                }
        }

        oldbrk = (uintptr_t) __curbrk;
 80481ba:	8b 83 28 00 00 00    	mov    0x28(%ebx),%eax
 80481c0:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /* Increment or decrement the saved break */

        if (incr < 0) {
 80481c3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 80481c7:	79 2a                	jns    80481f3 <sbrk+0xa7>
                if ((uintptr_t) - incr > oldbrk) {
 80481c9:	8b 45 08             	mov    0x8(%ebp),%eax
 80481cc:	f7 d8                	neg    %eax
 80481ce:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 80481d1:	76 07                	jbe    80481da <sbrk+0x8e>
                        return (void *) -1;
 80481d3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80481d8:	eb 3b                	jmp    8048215 <sbrk+0xc9>
                } else if (brk((void *)(oldbrk - (uintptr_t) - incr)) < 0) {
 80481da:	8b 45 08             	mov    0x8(%ebp),%eax
 80481dd:	03 45 f4             	add    -0xc(%ebp),%eax
 80481e0:	89 04 24             	mov    %eax,(%esp)
 80481e3:	e8 34 00 00 00       	call   804821c <brk>
 80481e8:	85 c0                	test   %eax,%eax
 80481ea:	79 26                	jns    8048212 <sbrk+0xc6>
                        return (void *) -1;
 80481ec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80481f1:	eb 22                	jmp    8048215 <sbrk+0xc9>
                }
        } else if (incr > 0) {
 80481f3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 80481f7:	7e 19                	jle    8048212 <sbrk+0xc6>
                if (brk((void *)(oldbrk + (uintptr_t) incr)) < 0) {
 80481f9:	8b 45 08             	mov    0x8(%ebp),%eax
 80481fc:	03 45 f4             	add    -0xc(%ebp),%eax
 80481ff:	89 04 24             	mov    %eax,(%esp)
 8048202:	e8 15 00 00 00       	call   804821c <brk>
 8048207:	85 c0                	test   %eax,%eax
 8048209:	79 07                	jns    8048212 <sbrk+0xc6>
                        return (void *) -1;
 804820b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8048210:	eb 03                	jmp    8048215 <sbrk+0xc9>
                }
        }
        return (void *) oldbrk;
 8048212:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048215:	83 c4 30             	add    $0x30,%esp
 8048218:	5b                   	pop    %ebx
 8048219:	5e                   	pop    %esi
 804821a:	5d                   	pop    %ebp
 804821b:	c3                   	ret    

0804821c <brk>:

int brk(void *addr)
{
 804821c:	55                   	push   %ebp
 804821d:	89 e5                	mov    %esp,%ebp
 804821f:	56                   	push   %esi
 8048220:	83 ec 14             	sub    $0x14,%esp
 8048223:	e8 2b 0e 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 8048228:	81 c1 f0 62 00 00    	add    $0x62f0,%ecx
        if (NULL == addr)
 804822e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8048232:	75 07                	jne    804823b <brk+0x1f>
                return -1;
 8048234:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8048239:	eb 57                	jmp    8048292 <brk+0x76>
        void *newbrk = (void *) trap(SYS_brk, (uint32_t) addr);
 804823b:	8b 45 08             	mov    0x8(%ebp),%eax
 804823e:	c7 45 f4 2c 00 00 00 	movl   $0x2c,-0xc(%ebp)
 8048245:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048248:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804824b:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804824e:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048251:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048254:	cd 2e                	int    $0x2e
 8048256:	89 c6                	mov    %eax,%esi
 8048258:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804825b:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8048262:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048265:	cd 2e                	int    $0x2e
 8048267:	89 c2                	mov    %eax,%edx
 8048269:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 804826f:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048271:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8048274:	89 45 f8             	mov    %eax,-0x8(%ebp)
        if (newbrk == (void *) -1)
 8048277:	83 7d f8 ff          	cmpl   $0xffffffff,-0x8(%ebp)
 804827b:	75 07                	jne    8048284 <brk+0x68>
                return -1;
 804827d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8048282:	eb 0e                	jmp    8048292 <brk+0x76>
        __curbrk = newbrk;
 8048284:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048287:	89 81 28 00 00 00    	mov    %eax,0x28(%ecx)
        return 0;
 804828d:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8048292:	83 c4 14             	add    $0x14,%esp
 8048295:	5e                   	pop    %esi
 8048296:	5d                   	pop    %ebp
 8048297:	c3                   	ret    

08048298 <fork>:

int fork(void)
{
 8048298:	55                   	push   %ebp
 8048299:	89 e5                	mov    %esp,%ebp
 804829b:	56                   	push   %esi
 804829c:	83 ec 14             	sub    $0x14,%esp
 804829f:	e8 af 0d 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 80482a4:	81 c1 74 62 00 00    	add    $0x6274,%ecx
 80482aa:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
 80482b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80482b8:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80482bb:	89 45 e8             	mov    %eax,-0x18(%ebp)
 80482be:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80482c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80482c4:	cd 2e                	int    $0x2e
 80482c6:	89 c6                	mov    %eax,%esi
 80482c8:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80482cb:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 80482d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80482d5:	cd 2e                	int    $0x2e
 80482d7:	89 c2                	mov    %eax,%edx
 80482d9:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80482df:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80482e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
        return trap(SYS_fork, 0);
}
 80482e4:	83 c4 14             	add    $0x14,%esp
 80482e7:	5e                   	pop    %esi
 80482e8:	5d                   	pop    %ebp
 80482e9:	c3                   	ret    

080482ea <atexit>:

int atexit(void (*func)(void))
{
 80482ea:	55                   	push   %ebp
 80482eb:	89 e5                	mov    %esp,%ebp
 80482ed:	e8 61 0d 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 80482f2:	81 c1 26 62 00 00    	add    $0x6226,%ecx
        if (atexit_handlers < MAX_EXIT_HANDLERS) {
 80482f8:	8b 81 c8 00 00 00    	mov    0xc8(%ecx),%eax
 80482fe:	83 f8 1f             	cmp    $0x1f,%eax
 8048301:	7f 20                	jg     8048323 <atexit+0x39>
                atexit_func[atexit_handlers++] = func;
 8048303:	8b 81 c8 00 00 00    	mov    0xc8(%ecx),%eax
 8048309:	8b 55 08             	mov    0x8(%ebp),%edx
 804830c:	89 94 81 48 00 00 00 	mov    %edx,0x48(%ecx,%eax,4)
 8048313:	83 c0 01             	add    $0x1,%eax
 8048316:	89 81 c8 00 00 00    	mov    %eax,0xc8(%ecx)
                return 0;
 804831c:	b8 00 00 00 00       	mov    $0x0,%eax
 8048321:	eb 05                	jmp    8048328 <atexit+0x3e>
        }

        return 1;
 8048323:	b8 01 00 00 00       	mov    $0x1,%eax
}
 8048328:	5d                   	pop    %ebp
 8048329:	c3                   	ret    

0804832a <_exit>:

void _exit(int status)
{
 804832a:	55                   	push   %ebp
 804832b:	89 e5                	mov    %esp,%ebp
 804832d:	56                   	push   %esi
 804832e:	83 ec 14             	sub    $0x14,%esp
 8048331:	e8 1d 0d 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 8048336:	81 c1 e2 61 00 00    	add    $0x61e2,%ecx
        trap(SYS_exit, (uint32_t) status);
 804833c:	8b 45 08             	mov    0x8(%ebp),%eax
 804833f:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
 8048346:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048349:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804834c:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804834f:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048352:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048355:	cd 2e                	int    $0x2e
 8048357:	89 c6                	mov    %eax,%esi
 8048359:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804835c:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8048363:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048366:	cd 2e                	int    $0x2e
 8048368:	89 c2                	mov    %eax,%edx
 804836a:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048370:	89 10                	mov    %edx,(%eax)

        /* this keeps gcc from warning us about exit returning, because it
         * expects exit not to. We never actually get here. */
        for (;;);
 8048372:	eb fe                	jmp    8048372 <_exit+0x48>

08048374 <exit>:
}

void exit(int status)
{
 8048374:	55                   	push   %ebp
 8048375:	89 e5                	mov    %esp,%ebp
 8048377:	53                   	push   %ebx
 8048378:	83 ec 14             	sub    $0x14,%esp
 804837b:	e8 d7 0c 00 00       	call   8049057 <__i686.get_pc_thunk.bx>
 8048380:	81 c3 98 61 00 00    	add    $0x6198,%ebx
        while (atexit_handlers--) {
 8048386:	eb 0f                	jmp    8048397 <exit+0x23>
                atexit_func[atexit_handlers]();
 8048388:	8b 83 c8 00 00 00    	mov    0xc8(%ebx),%eax
 804838e:	8b 84 83 48 00 00 00 	mov    0x48(%ebx,%eax,4),%eax
 8048395:	ff d0                	call   *%eax
        for (;;);
}

void exit(int status)
{
        while (atexit_handlers--) {
 8048397:	8b 83 c8 00 00 00    	mov    0xc8(%ebx),%eax
 804839d:	85 c0                	test   %eax,%eax
 804839f:	0f 95 c2             	setne  %dl
 80483a2:	83 e8 01             	sub    $0x1,%eax
 80483a5:	89 83 c8 00 00 00    	mov    %eax,0xc8(%ebx)
 80483ab:	84 d2                	test   %dl,%dl
 80483ad:	75 d9                	jne    8048388 <exit+0x14>
                atexit_func[atexit_handlers]();
        }

        _exit(status);
 80483af:	8b 45 08             	mov    0x8(%ebp),%eax
 80483b2:	89 04 24             	mov    %eax,(%esp)
 80483b5:	e8 70 ff ff ff       	call   804832a <_exit>
        exit(status); /* gcc doesn't realize that _exit() exits */
 80483ba:	8b 45 08             	mov    0x8(%ebp),%eax
 80483bd:	89 04 24             	mov    %eax,(%esp)
 80483c0:	e8 af ff ff ff       	call   8048374 <exit>
}
 80483c5:	83 c4 14             	add    $0x14,%esp
 80483c8:	5b                   	pop    %ebx
 80483c9:	5d                   	pop    %ebp
 80483ca:	c3                   	ret    

080483cb <yield>:

void yield(void)
{
 80483cb:	55                   	push   %ebp
 80483cc:	89 e5                	mov    %esp,%ebp
 80483ce:	53                   	push   %ebx
 80483cf:	83 ec 14             	sub    $0x14,%esp
 80483d2:	e8 80 0c 00 00       	call   8049057 <__i686.get_pc_thunk.bx>
 80483d7:	81 c3 41 61 00 00    	add    $0x6141,%ebx
        /* Due to a Bochs bug, the yield syscall itself is highly unyielding
         * (for instance, it's impossible to type while a process is in a yield
         * loop. This is good enough. */
        (fork() ? wait(NULL) : exit(0));
 80483dd:	e8 b6 fe ff ff       	call   8048298 <fork>
 80483e2:	85 c0                	test   %eax,%eax
 80483e4:	74 0e                	je     80483f4 <yield+0x29>
 80483e6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80483ed:	e8 14 00 00 00       	call   8048406 <wait>
 80483f2:	eb 0c                	jmp    8048400 <yield+0x35>
 80483f4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80483fb:	e8 74 ff ff ff       	call   8048374 <exit>
}
 8048400:	83 c4 14             	add    $0x14,%esp
 8048403:	5b                   	pop    %ebx
 8048404:	5d                   	pop    %ebp
 8048405:	c3                   	ret    

08048406 <wait>:

pid_t wait(int *status)
{
 8048406:	55                   	push   %ebp
 8048407:	89 e5                	mov    %esp,%ebp
 8048409:	56                   	push   %esi
 804840a:	83 ec 24             	sub    $0x24,%esp
 804840d:	e8 41 0c 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 8048412:	81 c1 06 61 00 00    	add    $0x6106,%ecx
        waitpid_args_t args;

        args.wpa_pid = -1;
 8048418:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
        args.wpa_options = 0;
 804841f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
        args.wpa_status = status;
 8048426:	8b 45 08             	mov    0x8(%ebp),%eax
 8048429:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_waitpid, (uint32_t) &args);
 804842c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804842f:	c7 45 f8 07 00 00 00 	movl   $0x7,-0x8(%ebp)
 8048436:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048439:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804843c:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804843f:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048442:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048445:	cd 2e                	int    $0x2e
 8048447:	89 c6                	mov    %eax,%esi
 8048449:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804844c:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 8048453:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048456:	cd 2e                	int    $0x2e
 8048458:	89 c2                	mov    %eax,%edx
 804845a:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048460:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048462:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048465:	83 c4 24             	add    $0x24,%esp
 8048468:	5e                   	pop    %esi
 8048469:	5d                   	pop    %ebp
 804846a:	c3                   	ret    

0804846b <waitpid>:

pid_t waitpid(pid_t pid, int options, int *status)
{
 804846b:	55                   	push   %ebp
 804846c:	89 e5                	mov    %esp,%ebp
 804846e:	56                   	push   %esi
 804846f:	83 ec 24             	sub    $0x24,%esp
 8048472:	e8 dc 0b 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 8048477:	81 c1 a1 60 00 00    	add    $0x60a1,%ecx
        waitpid_args_t args;

        args.wpa_pid = pid;
 804847d:	8b 45 08             	mov    0x8(%ebp),%eax
 8048480:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.wpa_options = options;
 8048483:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048486:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.wpa_status = status;
 8048489:	8b 45 10             	mov    0x10(%ebp),%eax
 804848c:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_waitpid, (uint32_t) &args);
 804848f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048492:	c7 45 f8 07 00 00 00 	movl   $0x7,-0x8(%ebp)
 8048499:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804849c:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804849f:	89 45 d8             	mov    %eax,-0x28(%ebp)
 80484a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80484a5:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80484a8:	cd 2e                	int    $0x2e
 80484aa:	89 c6                	mov    %eax,%esi
 80484ac:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80484af:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 80484b6:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80484b9:	cd 2e                	int    $0x2e
 80484bb:	89 c2                	mov    %eax,%edx
 80484bd:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80484c3:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80484c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 80484c8:	83 c4 24             	add    $0x24,%esp
 80484cb:	5e                   	pop    %esi
 80484cc:	5d                   	pop    %ebp
 80484cd:	c3                   	ret    

080484ce <thr_exit>:

void thr_exit(int status)
{
 80484ce:	55                   	push   %ebp
 80484cf:	89 e5                	mov    %esp,%ebp
 80484d1:	56                   	push   %esi
 80484d2:	83 ec 14             	sub    $0x14,%esp
 80484d5:	e8 79 0b 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 80484da:	81 c1 3e 60 00 00    	add    $0x603e,%ecx
        trap(SYS_thr_exit, (uint32_t) status);
 80484e0:	8b 45 08             	mov    0x8(%ebp),%eax
 80484e3:	c7 45 f8 1f 00 00 00 	movl   $0x1f,-0x8(%ebp)
 80484ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80484ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80484f0:	89 45 e8             	mov    %eax,-0x18(%ebp)
 80484f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80484f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80484f9:	cd 2e                	int    $0x2e
 80484fb:	89 c6                	mov    %eax,%esi
 80484fd:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048500:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8048507:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804850a:	cd 2e                	int    $0x2e
 804850c:	89 c2                	mov    %eax,%edx
 804850e:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048514:	89 10                	mov    %edx,(%eax)
}
 8048516:	83 c4 14             	add    $0x14,%esp
 8048519:	5e                   	pop    %esi
 804851a:	5d                   	pop    %ebp
 804851b:	c3                   	ret    

0804851c <getpid>:

pid_t getpid(void)
{
 804851c:	55                   	push   %ebp
 804851d:	89 e5                	mov    %esp,%ebp
 804851f:	56                   	push   %esi
 8048520:	83 ec 14             	sub    $0x14,%esp
 8048523:	e8 2b 0b 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 8048528:	81 c1 f0 5f 00 00    	add    $0x5ff0,%ecx
 804852e:	c7 45 f8 23 00 00 00 	movl   $0x23,-0x8(%ebp)
 8048535:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804853c:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804853f:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8048542:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048545:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048548:	cd 2e                	int    $0x2e
 804854a:	89 c6                	mov    %eax,%esi
 804854c:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804854f:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8048556:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048559:	cd 2e                	int    $0x2e
 804855b:	89 c2                	mov    %eax,%edx
 804855d:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048563:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048565:	8b 45 f0             	mov    -0x10(%ebp),%eax
        return trap(SYS_getpid, 0);
}
 8048568:	83 c4 14             	add    $0x14,%esp
 804856b:	5e                   	pop    %esi
 804856c:	5d                   	pop    %ebp
 804856d:	c3                   	ret    

0804856e <halt>:

int halt(void)
{
 804856e:	55                   	push   %ebp
 804856f:	89 e5                	mov    %esp,%ebp
 8048571:	56                   	push   %esi
 8048572:	83 ec 14             	sub    $0x14,%esp
 8048575:	e8 d9 0a 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 804857a:	81 c1 9e 5f 00 00    	add    $0x5f9e,%ecx
 8048580:	c7 45 f8 28 00 00 00 	movl   $0x28,-0x8(%ebp)
 8048587:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804858e:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048591:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8048594:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048597:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804859a:	cd 2e                	int    $0x2e
 804859c:	89 c6                	mov    %eax,%esi
 804859e:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80485a1:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 80485a8:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80485ab:	cd 2e                	int    $0x2e
 80485ad:	89 c2                	mov    %eax,%edx
 80485af:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80485b5:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80485b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
        return trap(SYS_halt, 0);
}
 80485ba:	83 c4 14             	add    $0x14,%esp
 80485bd:	5e                   	pop    %esi
 80485be:	5d                   	pop    %ebp
 80485bf:	c3                   	ret    

080485c0 <mmap>:

void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t off)
{
 80485c0:	55                   	push   %ebp
 80485c1:	89 e5                	mov    %esp,%ebp
 80485c3:	56                   	push   %esi
 80485c4:	83 ec 34             	sub    $0x34,%esp
 80485c7:	e8 87 0a 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 80485cc:	81 c1 4c 5f 00 00    	add    $0x5f4c,%ecx
        mmap_args_t args;

        args.mma_addr = addr;
 80485d2:	8b 45 08             	mov    0x8(%ebp),%eax
 80485d5:	89 45 d8             	mov    %eax,-0x28(%ebp)
        args.mma_len = len;
 80485d8:	8b 45 0c             	mov    0xc(%ebp),%eax
 80485db:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.mma_prot = prot;
 80485de:	8b 45 10             	mov    0x10(%ebp),%eax
 80485e1:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.mma_flags = flags;
 80485e4:	8b 45 14             	mov    0x14(%ebp),%eax
 80485e7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.mma_fd = fd;
 80485ea:	8b 45 18             	mov    0x18(%ebp),%eax
 80485ed:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.mma_off = off;
 80485f0:	8b 45 1c             	mov    0x1c(%ebp),%eax
 80485f3:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return (void *) trap(SYS_mmap, (uint32_t) &args);
 80485f6:	8d 45 d8             	lea    -0x28(%ebp),%eax
 80485f9:	c7 45 f8 18 00 00 00 	movl   $0x18,-0x8(%ebp)
 8048600:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048603:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048606:	89 45 c8             	mov    %eax,-0x38(%ebp)
 8048609:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804860c:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804860f:	cd 2e                	int    $0x2e
 8048611:	89 c6                	mov    %eax,%esi
 8048613:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048616:	c7 45 c8 27 00 00 00 	movl   $0x27,-0x38(%ebp)
 804861d:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8048620:	cd 2e                	int    $0x2e
 8048622:	89 c2                	mov    %eax,%edx
 8048624:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 804862a:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804862c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 804862f:	83 c4 34             	add    $0x34,%esp
 8048632:	5e                   	pop    %esi
 8048633:	5d                   	pop    %ebp
 8048634:	c3                   	ret    

08048635 <munmap>:

int munmap(void *addr, size_t len)
{
 8048635:	55                   	push   %ebp
 8048636:	89 e5                	mov    %esp,%ebp
 8048638:	56                   	push   %esi
 8048639:	83 ec 24             	sub    $0x24,%esp
 804863c:	e8 12 0a 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 8048641:	81 c1 d7 5e 00 00    	add    $0x5ed7,%ecx
        munmap_args_t args;

        args.addr = addr;
 8048647:	8b 45 08             	mov    0x8(%ebp),%eax
 804864a:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.len = len;
 804864d:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048650:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_munmap, (uint32_t) &args);
 8048653:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8048656:	c7 45 f8 1a 00 00 00 	movl   $0x1a,-0x8(%ebp)
 804865d:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048660:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048663:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8048666:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048669:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804866c:	cd 2e                	int    $0x2e
 804866e:	89 c6                	mov    %eax,%esi
 8048670:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048673:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 804867a:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804867d:	cd 2e                	int    $0x2e
 804867f:	89 c2                	mov    %eax,%edx
 8048681:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048687:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048689:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 804868c:	83 c4 24             	add    $0x24,%esp
 804868f:	5e                   	pop    %esi
 8048690:	5d                   	pop    %ebp
 8048691:	c3                   	ret    

08048692 <sync>:

void sync(void)
{
 8048692:	55                   	push   %ebp
 8048693:	89 e5                	mov    %esp,%ebp
 8048695:	56                   	push   %esi
 8048696:	83 ec 14             	sub    $0x14,%esp
 8048699:	e8 b5 09 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 804869e:	81 c1 7a 5e 00 00    	add    $0x5e7a,%ecx
 80486a4:	c7 45 f8 0f 00 00 00 	movl   $0xf,-0x8(%ebp)
 80486ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80486b2:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80486b5:	89 45 e8             	mov    %eax,-0x18(%ebp)
 80486b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80486bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80486be:	cd 2e                	int    $0x2e
 80486c0:	89 c6                	mov    %eax,%esi
 80486c2:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80486c5:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 80486cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80486cf:	cd 2e                	int    $0x2e
 80486d1:	89 c2                	mov    %eax,%edx
 80486d3:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80486d9:	89 10                	mov    %edx,(%eax)
        trap(SYS_sync, 0);
}
 80486db:	83 c4 14             	add    $0x14,%esp
 80486de:	5e                   	pop    %esi
 80486df:	5d                   	pop    %ebp
 80486e0:	c3                   	ret    

080486e1 <open>:

int open(const char *filename, int flags, int mode)
{
 80486e1:	55                   	push   %ebp
 80486e2:	89 e5                	mov    %esp,%ebp
 80486e4:	56                   	push   %esi
 80486e5:	53                   	push   %ebx
 80486e6:	83 ec 40             	sub    $0x40,%esp
 80486e9:	e8 69 09 00 00       	call   8049057 <__i686.get_pc_thunk.bx>
 80486ee:	81 c3 2a 5e 00 00    	add    $0x5e2a,%ebx
        open_args_t args;

        args.filename.as_len = strlen(filename);
 80486f4:	8b 45 08             	mov    0x8(%ebp),%eax
 80486f7:	89 04 24             	mov    %eax,(%esp)
 80486fa:	e8 22 2d 00 00       	call   804b421 <strlen>
 80486ff:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.filename.as_str = filename;
 8048702:	8b 45 08             	mov    0x8(%ebp),%eax
 8048705:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.flags = flags;
 8048708:	8b 45 0c             	mov    0xc(%ebp),%eax
 804870b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.mode = mode;
 804870e:	8b 45 10             	mov    0x10(%ebp),%eax
 8048711:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_open, (uint32_t) &args);
 8048714:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8048717:	c7 45 f4 05 00 00 00 	movl   $0x5,-0xc(%ebp)
 804871e:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048721:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048724:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8048727:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804872a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804872d:	cd 2e                	int    $0x2e
 804872f:	89 c6                	mov    %eax,%esi
 8048731:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048734:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 804873b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804873e:	cd 2e                	int    $0x2e
 8048740:	89 c2                	mov    %eax,%edx
 8048742:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048748:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804874a:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 804874d:	83 c4 40             	add    $0x40,%esp
 8048750:	5b                   	pop    %ebx
 8048751:	5e                   	pop    %esi
 8048752:	5d                   	pop    %ebp
 8048753:	c3                   	ret    

08048754 <lseek>:

off_t lseek(int fd, off_t offset, int whence)
{
 8048754:	55                   	push   %ebp
 8048755:	89 e5                	mov    %esp,%ebp
 8048757:	56                   	push   %esi
 8048758:	83 ec 24             	sub    $0x24,%esp
 804875b:	e8 f3 08 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 8048760:	81 c1 b8 5d 00 00    	add    $0x5db8,%ecx
        lseek_args_t args;

        args.fd = fd;
 8048766:	8b 45 08             	mov    0x8(%ebp),%eax
 8048769:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.offset = offset;
 804876c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804876f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.whence = whence;
 8048772:	8b 45 10             	mov    0x10(%ebp),%eax
 8048775:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_lseek, (uint32_t) &args);
 8048778:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804877b:	c7 45 f8 0e 00 00 00 	movl   $0xe,-0x8(%ebp)
 8048782:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048785:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048788:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804878b:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804878e:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048791:	cd 2e                	int    $0x2e
 8048793:	89 c6                	mov    %eax,%esi
 8048795:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048798:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 804879f:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80487a2:	cd 2e                	int    $0x2e
 80487a4:	89 c2                	mov    %eax,%edx
 80487a6:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80487ac:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80487ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 80487b1:	83 c4 24             	add    $0x24,%esp
 80487b4:	5e                   	pop    %esi
 80487b5:	5d                   	pop    %ebp
 80487b6:	c3                   	ret    

080487b7 <read>:


int read(int fd, void *buf, size_t nbytes)
{
 80487b7:	55                   	push   %ebp
 80487b8:	89 e5                	mov    %esp,%ebp
 80487ba:	56                   	push   %esi
 80487bb:	83 ec 24             	sub    $0x24,%esp
 80487be:	e8 90 08 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 80487c3:	81 c1 55 5d 00 00    	add    $0x5d55,%ecx
        read_args_t args;

        args.fd = fd;
 80487c9:	8b 45 08             	mov    0x8(%ebp),%eax
 80487cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.buf = buf;
 80487cf:	8b 45 0c             	mov    0xc(%ebp),%eax
 80487d2:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.nbytes = nbytes;
 80487d5:	8b 45 10             	mov    0x10(%ebp),%eax
 80487d8:	89 45 ec             	mov    %eax,-0x14(%ebp)


        return trap(SYS_read, (uint32_t) &args);
 80487db:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 80487de:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)
 80487e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80487e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80487eb:	89 45 d8             	mov    %eax,-0x28(%ebp)
 80487ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80487f1:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80487f4:	cd 2e                	int    $0x2e
 80487f6:	89 c6                	mov    %eax,%esi
 80487f8:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80487fb:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 8048802:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048805:	cd 2e                	int    $0x2e
 8048807:	89 c2                	mov    %eax,%edx
 8048809:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 804880f:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048811:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048814:	83 c4 24             	add    $0x24,%esp
 8048817:	5e                   	pop    %esi
 8048818:	5d                   	pop    %ebp
 8048819:	c3                   	ret    

0804881a <write>:

int write(int fd, const void *buf, size_t nbytes)
{
 804881a:	55                   	push   %ebp
 804881b:	89 e5                	mov    %esp,%ebp
 804881d:	56                   	push   %esi
 804881e:	83 ec 24             	sub    $0x24,%esp
 8048821:	e8 2d 08 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 8048826:	81 c1 f2 5c 00 00    	add    $0x5cf2,%ecx
        write_args_t args;

        args.fd = fd;
 804882c:	8b 45 08             	mov    0x8(%ebp),%eax
 804882f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.buf = (void *) buf;
 8048832:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048835:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.nbytes = nbytes;
 8048838:	8b 45 10             	mov    0x10(%ebp),%eax
 804883b:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_write, (uint32_t) &args);
 804883e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048841:	c7 45 f8 04 00 00 00 	movl   $0x4,-0x8(%ebp)
 8048848:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804884b:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804884e:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8048851:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048854:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048857:	cd 2e                	int    $0x2e
 8048859:	89 c6                	mov    %eax,%esi
 804885b:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804885e:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 8048865:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048868:	cd 2e                	int    $0x2e
 804886a:	89 c2                	mov    %eax,%edx
 804886c:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048872:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048874:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048877:	83 c4 24             	add    $0x24,%esp
 804887a:	5e                   	pop    %esi
 804887b:	5d                   	pop    %ebp
 804887c:	c3                   	ret    

0804887d <close>:

int close(int fd)
{
 804887d:	55                   	push   %ebp
 804887e:	89 e5                	mov    %esp,%ebp
 8048880:	56                   	push   %esi
 8048881:	83 ec 14             	sub    $0x14,%esp
 8048884:	e8 ca 07 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 8048889:	81 c1 8f 5c 00 00    	add    $0x5c8f,%ecx
        return trap(SYS_close, (uint32_t) fd);
 804888f:	8b 45 08             	mov    0x8(%ebp),%eax
 8048892:	c7 45 f8 06 00 00 00 	movl   $0x6,-0x8(%ebp)
 8048899:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804889c:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804889f:	89 45 e8             	mov    %eax,-0x18(%ebp)
 80488a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80488a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80488a8:	cd 2e                	int    $0x2e
 80488aa:	89 c6                	mov    %eax,%esi
 80488ac:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80488af:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 80488b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80488b9:	cd 2e                	int    $0x2e
 80488bb:	89 c2                	mov    %eax,%edx
 80488bd:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80488c3:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80488c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 80488c8:	83 c4 14             	add    $0x14,%esp
 80488cb:	5e                   	pop    %esi
 80488cc:	5d                   	pop    %ebp
 80488cd:	c3                   	ret    

080488ce <dup>:

int dup(int fd)
{
 80488ce:	55                   	push   %ebp
 80488cf:	89 e5                	mov    %esp,%ebp
 80488d1:	56                   	push   %esi
 80488d2:	83 ec 14             	sub    $0x14,%esp
 80488d5:	e8 79 07 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 80488da:	81 c1 3e 5c 00 00    	add    $0x5c3e,%ecx
        return trap(SYS_dup, (uint32_t) fd);
 80488e0:	8b 45 08             	mov    0x8(%ebp),%eax
 80488e3:	c7 45 f8 11 00 00 00 	movl   $0x11,-0x8(%ebp)
 80488ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80488ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80488f0:	89 45 e8             	mov    %eax,-0x18(%ebp)
 80488f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80488f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80488f9:	cd 2e                	int    $0x2e
 80488fb:	89 c6                	mov    %eax,%esi
 80488fd:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048900:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8048907:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804890a:	cd 2e                	int    $0x2e
 804890c:	89 c2                	mov    %eax,%edx
 804890e:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048914:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048916:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048919:	83 c4 14             	add    $0x14,%esp
 804891c:	5e                   	pop    %esi
 804891d:	5d                   	pop    %ebp
 804891e:	c3                   	ret    

0804891f <dup2>:

int dup2(int ofd, int nfd)
{
 804891f:	55                   	push   %ebp
 8048920:	89 e5                	mov    %esp,%ebp
 8048922:	56                   	push   %esi
 8048923:	83 ec 24             	sub    $0x24,%esp
 8048926:	e8 28 07 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 804892b:	81 c1 ed 5b 00 00    	add    $0x5bed,%ecx
        dup2_args_t args;

        args.ofd = ofd;
 8048931:	8b 45 08             	mov    0x8(%ebp),%eax
 8048934:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.nfd = nfd;
 8048937:	8b 45 0c             	mov    0xc(%ebp),%eax
 804893a:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_dup2, (uint32_t) &args);
 804893d:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8048940:	c7 45 f8 2b 00 00 00 	movl   $0x2b,-0x8(%ebp)
 8048947:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804894a:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804894d:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8048950:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048953:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048956:	cd 2e                	int    $0x2e
 8048958:	89 c6                	mov    %eax,%esi
 804895a:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804895d:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 8048964:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048967:	cd 2e                	int    $0x2e
 8048969:	89 c2                	mov    %eax,%edx
 804896b:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048971:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048973:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048976:	83 c4 24             	add    $0x24,%esp
 8048979:	5e                   	pop    %esi
 804897a:	5d                   	pop    %ebp
 804897b:	c3                   	ret    

0804897c <mkdir>:

int mkdir(const char *path, int mode)
{
 804897c:	55                   	push   %ebp
 804897d:	89 e5                	mov    %esp,%ebp
 804897f:	56                   	push   %esi
 8048980:	53                   	push   %ebx
 8048981:	83 ec 40             	sub    $0x40,%esp
 8048984:	e8 ce 06 00 00       	call   8049057 <__i686.get_pc_thunk.bx>
 8048989:	81 c3 8f 5b 00 00    	add    $0x5b8f,%ebx
        mkdir_args_t args;

        args.path.as_len = strlen(path);
 804898f:	8b 45 08             	mov    0x8(%ebp),%eax
 8048992:	89 04 24             	mov    %eax,(%esp)
 8048995:	e8 87 2a 00 00       	call   804b421 <strlen>
 804899a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.path.as_str = path;
 804899d:	8b 45 08             	mov    0x8(%ebp),%eax
 80489a0:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.mode = mode;
 80489a3:	8b 45 0c             	mov    0xc(%ebp),%eax
 80489a6:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_mkdir, (uint32_t) &args);
 80489a9:	8d 45 e0             	lea    -0x20(%ebp),%eax
 80489ac:	c7 45 f4 16 00 00 00 	movl   $0x16,-0xc(%ebp)
 80489b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80489b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80489b9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 80489bc:	8b 55 f0             	mov    -0x10(%ebp),%edx
 80489bf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 80489c2:	cd 2e                	int    $0x2e
 80489c4:	89 c6                	mov    %eax,%esi
 80489c6:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80489c9:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 80489d0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 80489d3:	cd 2e                	int    $0x2e
 80489d5:	89 c2                	mov    %eax,%edx
 80489d7:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 80489dd:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80489df:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 80489e2:	83 c4 40             	add    $0x40,%esp
 80489e5:	5b                   	pop    %ebx
 80489e6:	5e                   	pop    %esi
 80489e7:	5d                   	pop    %ebp
 80489e8:	c3                   	ret    

080489e9 <rmdir>:

int rmdir(const char *path)
{
 80489e9:	55                   	push   %ebp
 80489ea:	89 e5                	mov    %esp,%ebp
 80489ec:	56                   	push   %esi
 80489ed:	53                   	push   %ebx
 80489ee:	83 ec 40             	sub    $0x40,%esp
 80489f1:	e8 61 06 00 00       	call   8049057 <__i686.get_pc_thunk.bx>
 80489f6:	81 c3 22 5b 00 00    	add    $0x5b22,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 80489fc:	8b 45 08             	mov    0x8(%ebp),%eax
 80489ff:	89 04 24             	mov    %eax,(%esp)
 8048a02:	e8 1a 2a 00 00       	call   804b421 <strlen>
 8048a07:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 8048a0a:	8b 45 08             	mov    0x8(%ebp),%eax
 8048a0d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_rmdir, (uint32_t) &args);
 8048a10:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048a13:	c7 45 f4 15 00 00 00 	movl   $0x15,-0xc(%ebp)
 8048a1a:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048a1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048a20:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8048a23:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048a26:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048a29:	cd 2e                	int    $0x2e
 8048a2b:	89 c6                	mov    %eax,%esi
 8048a2d:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048a30:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8048a37:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048a3a:	cd 2e                	int    $0x2e
 8048a3c:	89 c2                	mov    %eax,%edx
 8048a3e:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048a44:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048a46:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048a49:	83 c4 40             	add    $0x40,%esp
 8048a4c:	5b                   	pop    %ebx
 8048a4d:	5e                   	pop    %esi
 8048a4e:	5d                   	pop    %ebp
 8048a4f:	c3                   	ret    

08048a50 <unlink>:

int unlink(const char *path)
{
 8048a50:	55                   	push   %ebp
 8048a51:	89 e5                	mov    %esp,%ebp
 8048a53:	56                   	push   %esi
 8048a54:	53                   	push   %ebx
 8048a55:	83 ec 40             	sub    $0x40,%esp
 8048a58:	e8 fa 05 00 00       	call   8049057 <__i686.get_pc_thunk.bx>
 8048a5d:	81 c3 bb 5a 00 00    	add    $0x5abb,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 8048a63:	8b 45 08             	mov    0x8(%ebp),%eax
 8048a66:	89 04 24             	mov    %eax,(%esp)
 8048a69:	e8 b3 29 00 00       	call   804b421 <strlen>
 8048a6e:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 8048a71:	8b 45 08             	mov    0x8(%ebp),%eax
 8048a74:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_unlink, (uint32_t) &args);
 8048a77:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048a7a:	c7 45 f4 09 00 00 00 	movl   $0x9,-0xc(%ebp)
 8048a81:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048a84:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048a87:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8048a8a:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048a8d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048a90:	cd 2e                	int    $0x2e
 8048a92:	89 c6                	mov    %eax,%esi
 8048a94:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048a97:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8048a9e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048aa1:	cd 2e                	int    $0x2e
 8048aa3:	89 c2                	mov    %eax,%edx
 8048aa5:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048aab:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048aad:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048ab0:	83 c4 40             	add    $0x40,%esp
 8048ab3:	5b                   	pop    %ebx
 8048ab4:	5e                   	pop    %esi
 8048ab5:	5d                   	pop    %ebp
 8048ab6:	c3                   	ret    

08048ab7 <link>:

int link(const char *from, const char *to)
{
 8048ab7:	55                   	push   %ebp
 8048ab8:	89 e5                	mov    %esp,%ebp
 8048aba:	56                   	push   %esi
 8048abb:	53                   	push   %ebx
 8048abc:	83 ec 40             	sub    $0x40,%esp
 8048abf:	e8 93 05 00 00       	call   8049057 <__i686.get_pc_thunk.bx>
 8048ac4:	81 c3 54 5a 00 00    	add    $0x5a54,%ebx
        link_args_t args;

        args.from.as_len = strlen(from);
 8048aca:	8b 45 08             	mov    0x8(%ebp),%eax
 8048acd:	89 04 24             	mov    %eax,(%esp)
 8048ad0:	e8 4c 29 00 00       	call   804b421 <strlen>
 8048ad5:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.from.as_str = from;
 8048ad8:	8b 45 08             	mov    0x8(%ebp),%eax
 8048adb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.to.as_len = strlen(to);
 8048ade:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048ae1:	89 04 24             	mov    %eax,(%esp)
 8048ae4:	e8 38 29 00 00       	call   804b421 <strlen>
 8048ae9:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.to.as_str = to;
 8048aec:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048aef:	89 45 dc             	mov    %eax,-0x24(%ebp)

        return trap(SYS_link, (uint32_t) &args);
 8048af2:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8048af5:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
 8048afc:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048aff:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048b02:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8048b05:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048b08:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048b0b:	cd 2e                	int    $0x2e
 8048b0d:	89 c6                	mov    %eax,%esi
 8048b0f:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048b12:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8048b19:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048b1c:	cd 2e                	int    $0x2e
 8048b1e:	89 c2                	mov    %eax,%edx
 8048b20:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048b26:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048b28:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048b2b:	83 c4 40             	add    $0x40,%esp
 8048b2e:	5b                   	pop    %ebx
 8048b2f:	5e                   	pop    %esi
 8048b30:	5d                   	pop    %ebp
 8048b31:	c3                   	ret    

08048b32 <rename>:

int rename(const char *oldname, const char *newname)
{
 8048b32:	55                   	push   %ebp
 8048b33:	89 e5                	mov    %esp,%ebp
 8048b35:	56                   	push   %esi
 8048b36:	53                   	push   %ebx
 8048b37:	83 ec 40             	sub    $0x40,%esp
 8048b3a:	e8 18 05 00 00       	call   8049057 <__i686.get_pc_thunk.bx>
 8048b3f:	81 c3 d9 59 00 00    	add    $0x59d9,%ebx
        rename_args_t args;

        args.oldname.as_len = strlen(oldname);
 8048b45:	8b 45 08             	mov    0x8(%ebp),%eax
 8048b48:	89 04 24             	mov    %eax,(%esp)
 8048b4b:	e8 d1 28 00 00       	call   804b421 <strlen>
 8048b50:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.oldname.as_str = oldname;
 8048b53:	8b 45 08             	mov    0x8(%ebp),%eax
 8048b56:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.newname.as_len = strlen(newname);
 8048b59:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048b5c:	89 04 24             	mov    %eax,(%esp)
 8048b5f:	e8 bd 28 00 00       	call   804b421 <strlen>
 8048b64:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.newname.as_str = newname;
 8048b67:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048b6a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        return trap(SYS_rename, (uint32_t) &args);
 8048b6d:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8048b70:	c7 45 f4 1b 00 00 00 	movl   $0x1b,-0xc(%ebp)
 8048b77:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048b7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048b7d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8048b80:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048b83:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048b86:	cd 2e                	int    $0x2e
 8048b88:	89 c6                	mov    %eax,%esi
 8048b8a:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048b8d:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8048b94:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048b97:	cd 2e                	int    $0x2e
 8048b99:	89 c2                	mov    %eax,%edx
 8048b9b:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048ba1:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048ba3:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048ba6:	83 c4 40             	add    $0x40,%esp
 8048ba9:	5b                   	pop    %ebx
 8048baa:	5e                   	pop    %esi
 8048bab:	5d                   	pop    %ebp
 8048bac:	c3                   	ret    

08048bad <chdir>:

int chdir(const char *path)
{
 8048bad:	55                   	push   %ebp
 8048bae:	89 e5                	mov    %esp,%ebp
 8048bb0:	56                   	push   %esi
 8048bb1:	53                   	push   %ebx
 8048bb2:	83 ec 40             	sub    $0x40,%esp
 8048bb5:	e8 9d 04 00 00       	call   8049057 <__i686.get_pc_thunk.bx>
 8048bba:	81 c3 5e 59 00 00    	add    $0x595e,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 8048bc0:	8b 45 08             	mov    0x8(%ebp),%eax
 8048bc3:	89 04 24             	mov    %eax,(%esp)
 8048bc6:	e8 56 28 00 00       	call   804b421 <strlen>
 8048bcb:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 8048bce:	8b 45 08             	mov    0x8(%ebp),%eax
 8048bd1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_chdir, (uint32_t) &args);
 8048bd4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048bd7:	c7 45 f4 0b 00 00 00 	movl   $0xb,-0xc(%ebp)
 8048bde:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048be1:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048be4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8048be7:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048bea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048bed:	cd 2e                	int    $0x2e
 8048bef:	89 c6                	mov    %eax,%esi
 8048bf1:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048bf4:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8048bfb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048bfe:	cd 2e                	int    $0x2e
 8048c00:	89 c2                	mov    %eax,%edx
 8048c02:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048c08:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048c0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048c0d:	83 c4 40             	add    $0x40,%esp
 8048c10:	5b                   	pop    %ebx
 8048c11:	5e                   	pop    %esi
 8048c12:	5d                   	pop    %ebp
 8048c13:	c3                   	ret    

08048c14 <get_free_mem>:

size_t get_free_mem(void)
{
 8048c14:	55                   	push   %ebp
 8048c15:	89 e5                	mov    %esp,%ebp
 8048c17:	56                   	push   %esi
 8048c18:	83 ec 14             	sub    $0x14,%esp
 8048c1b:	e8 33 04 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 8048c20:	81 c1 f8 58 00 00    	add    $0x58f8,%ecx
 8048c26:	c7 45 f8 29 00 00 00 	movl   $0x29,-0x8(%ebp)
 8048c2d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048c34:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048c37:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8048c3a:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048c3d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048c40:	cd 2e                	int    $0x2e
 8048c42:	89 c6                	mov    %eax,%esi
 8048c44:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048c47:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8048c4e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048c51:	cd 2e                	int    $0x2e
 8048c53:	89 c2                	mov    %eax,%edx
 8048c55:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048c5b:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048c5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
        return (size_t) trap(SYS_get_free_mem, 0);
}
 8048c60:	83 c4 14             	add    $0x14,%esp
 8048c63:	5e                   	pop    %esi
 8048c64:	5d                   	pop    %ebp
 8048c65:	c3                   	ret    

08048c66 <execve>:

int execve(const char *filename, char *const argv[], char *const envp[])
{
 8048c66:	55                   	push   %ebp
 8048c67:	89 e5                	mov    %esp,%ebp
 8048c69:	56                   	push   %esi
 8048c6a:	53                   	push   %ebx
 8048c6b:	83 ec 50             	sub    $0x50,%esp
 8048c6e:	e8 e4 03 00 00       	call   8049057 <__i686.get_pc_thunk.bx>
 8048c73:	81 c3 a5 58 00 00    	add    $0x58a5,%ebx
        execve_args_t           args;

        int i;

        args.filename.as_len = strlen(filename);
 8048c79:	8b 45 08             	mov    0x8(%ebp),%eax
 8048c7c:	89 04 24             	mov    %eax,(%esp)
 8048c7f:	e8 9d 27 00 00       	call   804b421 <strlen>
 8048c84:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        args.filename.as_str = filename;
 8048c87:	8b 45 08             	mov    0x8(%ebp),%eax
 8048c8a:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /* Build argv vector */
        for (i = 0; argv[i] != NULL; i++)
 8048c8d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8048c94:	eb 04                	jmp    8048c9a <execve+0x34>
 8048c96:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 8048c9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048c9d:	c1 e0 02             	shl    $0x2,%eax
 8048ca0:	03 45 0c             	add    0xc(%ebp),%eax
 8048ca3:	8b 00                	mov    (%eax),%eax
 8048ca5:	85 c0                	test   %eax,%eax
 8048ca7:	75 ed                	jne    8048c96 <execve+0x30>
                ;
        args.argv.av_len = i;
 8048ca9:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048cac:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.argv.av_vec = malloc((args.argv.av_len + 1) * sizeof(argstr_t));
 8048caf:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048cb2:	83 c0 01             	add    $0x1,%eax
 8048cb5:	c1 e0 03             	shl    $0x3,%eax
 8048cb8:	89 04 24             	mov    %eax,(%esp)
 8048cbb:	e8 74 22 00 00       	call   804af34 <malloc>
 8048cc0:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for (i = 0; argv[i] != NULL; i++) {
 8048cc3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8048cca:	eb 3e                	jmp    8048d0a <execve+0xa4>
                args.argv.av_vec[i].as_len = strlen(argv[i]);
 8048ccc:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048ccf:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048cd2:	c1 e2 03             	shl    $0x3,%edx
 8048cd5:	8d 34 10             	lea    (%eax,%edx,1),%esi
 8048cd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048cdb:	c1 e0 02             	shl    $0x2,%eax
 8048cde:	03 45 0c             	add    0xc(%ebp),%eax
 8048ce1:	8b 00                	mov    (%eax),%eax
 8048ce3:	89 04 24             	mov    %eax,(%esp)
 8048ce6:	e8 36 27 00 00       	call   804b421 <strlen>
 8048ceb:	89 46 04             	mov    %eax,0x4(%esi)
                args.argv.av_vec[i].as_str = argv[i];
 8048cee:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048cf1:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048cf4:	c1 e2 03             	shl    $0x3,%edx
 8048cf7:	01 c2                	add    %eax,%edx
 8048cf9:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048cfc:	c1 e0 02             	shl    $0x2,%eax
 8048cff:	03 45 0c             	add    0xc(%ebp),%eax
 8048d02:	8b 00                	mov    (%eax),%eax
 8048d04:	89 02                	mov    %eax,(%edx)
        /* Build argv vector */
        for (i = 0; argv[i] != NULL; i++)
                ;
        args.argv.av_len = i;
        args.argv.av_vec = malloc((args.argv.av_len + 1) * sizeof(argstr_t));
        for (i = 0; argv[i] != NULL; i++) {
 8048d06:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 8048d0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048d0d:	c1 e0 02             	shl    $0x2,%eax
 8048d10:	03 45 0c             	add    0xc(%ebp),%eax
 8048d13:	8b 00                	mov    (%eax),%eax
 8048d15:	85 c0                	test   %eax,%eax
 8048d17:	75 b3                	jne    8048ccc <execve+0x66>
                args.argv.av_vec[i].as_len = strlen(argv[i]);
                args.argv.av_vec[i].as_str = argv[i];
        }
        args.argv.av_vec[i].as_len = 0;
 8048d19:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048d1c:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048d1f:	c1 e2 03             	shl    $0x3,%edx
 8048d22:	01 d0                	add    %edx,%eax
 8048d24:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        args.argv.av_vec[i].as_str = NULL;
 8048d2b:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048d2e:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048d31:	c1 e2 03             	shl    $0x3,%edx
 8048d34:	01 d0                	add    %edx,%eax
 8048d36:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

        /* Build envp vector */
        for (i = 0; envp[i] != NULL; i++)
 8048d3c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8048d43:	eb 04                	jmp    8048d49 <execve+0xe3>
 8048d45:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 8048d49:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048d4c:	c1 e0 02             	shl    $0x2,%eax
 8048d4f:	03 45 10             	add    0x10(%ebp),%eax
 8048d52:	8b 00                	mov    (%eax),%eax
 8048d54:	85 c0                	test   %eax,%eax
 8048d56:	75 ed                	jne    8048d45 <execve+0xdf>
                ;
        args.envp.av_len = i;
 8048d58:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048d5b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.envp.av_vec = malloc((args.envp.av_len + 1) * sizeof(argstr_t));
 8048d5e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048d61:	83 c0 01             	add    $0x1,%eax
 8048d64:	c1 e0 03             	shl    $0x3,%eax
 8048d67:	89 04 24             	mov    %eax,(%esp)
 8048d6a:	e8 c5 21 00 00       	call   804af34 <malloc>
 8048d6f:	89 45 e0             	mov    %eax,-0x20(%ebp)
        for (i = 0; envp[i] != NULL; i++) {
 8048d72:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8048d79:	eb 3e                	jmp    8048db9 <execve+0x153>
                args.envp.av_vec[i].as_len = strlen(envp[i]);
 8048d7b:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048d7e:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048d81:	c1 e2 03             	shl    $0x3,%edx
 8048d84:	8d 34 10             	lea    (%eax,%edx,1),%esi
 8048d87:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048d8a:	c1 e0 02             	shl    $0x2,%eax
 8048d8d:	03 45 10             	add    0x10(%ebp),%eax
 8048d90:	8b 00                	mov    (%eax),%eax
 8048d92:	89 04 24             	mov    %eax,(%esp)
 8048d95:	e8 87 26 00 00       	call   804b421 <strlen>
 8048d9a:	89 46 04             	mov    %eax,0x4(%esi)
                args.envp.av_vec[i].as_str = envp[i];
 8048d9d:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048da0:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048da3:	c1 e2 03             	shl    $0x3,%edx
 8048da6:	01 c2                	add    %eax,%edx
 8048da8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048dab:	c1 e0 02             	shl    $0x2,%eax
 8048dae:	03 45 10             	add    0x10(%ebp),%eax
 8048db1:	8b 00                	mov    (%eax),%eax
 8048db3:	89 02                	mov    %eax,(%edx)
        /* Build envp vector */
        for (i = 0; envp[i] != NULL; i++)
                ;
        args.envp.av_len = i;
        args.envp.av_vec = malloc((args.envp.av_len + 1) * sizeof(argstr_t));
        for (i = 0; envp[i] != NULL; i++) {
 8048db5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 8048db9:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048dbc:	c1 e0 02             	shl    $0x2,%eax
 8048dbf:	03 45 10             	add    0x10(%ebp),%eax
 8048dc2:	8b 00                	mov    (%eax),%eax
 8048dc4:	85 c0                	test   %eax,%eax
 8048dc6:	75 b3                	jne    8048d7b <execve+0x115>
                args.envp.av_vec[i].as_len = strlen(envp[i]);
                args.envp.av_vec[i].as_str = envp[i];
        }
        args.envp.av_vec[i].as_len = 0;
 8048dc8:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048dcb:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048dce:	c1 e2 03             	shl    $0x3,%edx
 8048dd1:	01 d0                	add    %edx,%eax
 8048dd3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        args.envp.av_vec[i].as_str = NULL;
 8048dda:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048ddd:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048de0:	c1 e2 03             	shl    $0x3,%edx
 8048de3:	01 d0                	add    %edx,%eax
 8048de5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

        /* Note that we don't need to worry about freeing since we are going to exec
         * (so all our memory will be cleaned up) */

        return trap(SYS_execve, (uint32_t) &args);
 8048deb:	8d 45 d0             	lea    -0x30(%ebp),%eax
 8048dee:	c7 45 f0 0a 00 00 00 	movl   $0xa,-0x10(%ebp)
 8048df5:	89 45 ec             	mov    %eax,-0x14(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048df8:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048dfb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 8048dfe:	8b 55 ec             	mov    -0x14(%ebp),%edx
 8048e01:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8048e04:	cd 2e                	int    $0x2e
 8048e06:	89 c6                	mov    %eax,%esi
 8048e08:	89 75 e8             	mov    %esi,-0x18(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048e0b:	c7 45 c4 27 00 00 00 	movl   $0x27,-0x3c(%ebp)
 8048e12:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8048e15:	cd 2e                	int    $0x2e
 8048e17:	89 c2                	mov    %eax,%edx
 8048e19:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048e1f:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048e21:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
 8048e24:	83 c4 50             	add    $0x50,%esp
 8048e27:	5b                   	pop    %ebx
 8048e28:	5e                   	pop    %esi
 8048e29:	5d                   	pop    %ebp
 8048e2a:	c3                   	ret    

08048e2b <thr_set_errno>:

void thr_set_errno(int n)
{
 8048e2b:	55                   	push   %ebp
 8048e2c:	89 e5                	mov    %esp,%ebp
 8048e2e:	56                   	push   %esi
 8048e2f:	83 ec 14             	sub    $0x14,%esp
 8048e32:	e8 1c 02 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 8048e37:	81 c1 e1 56 00 00    	add    $0x56e1,%ecx
        trap(SYS_set_errno, (uint32_t) n);
 8048e3d:	8b 45 08             	mov    0x8(%ebp),%eax
 8048e40:	c7 45 f8 2a 00 00 00 	movl   $0x2a,-0x8(%ebp)
 8048e47:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048e4a:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048e4d:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8048e50:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048e53:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048e56:	cd 2e                	int    $0x2e
 8048e58:	89 c6                	mov    %eax,%esi
 8048e5a:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048e5d:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8048e64:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048e67:	cd 2e                	int    $0x2e
 8048e69:	89 c2                	mov    %eax,%edx
 8048e6b:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048e71:	89 10                	mov    %edx,(%eax)
}
 8048e73:	83 c4 14             	add    $0x14,%esp
 8048e76:	5e                   	pop    %esi
 8048e77:	5d                   	pop    %ebp
 8048e78:	c3                   	ret    

08048e79 <thr_errno>:

int thr_errno(void)
{
 8048e79:	55                   	push   %ebp
 8048e7a:	89 e5                	mov    %esp,%ebp
 8048e7c:	56                   	push   %esi
 8048e7d:	83 ec 14             	sub    $0x14,%esp
 8048e80:	e8 ce 01 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 8048e85:	81 c1 93 56 00 00    	add    $0x5693,%ecx
 8048e8b:	c7 45 f8 27 00 00 00 	movl   $0x27,-0x8(%ebp)
 8048e92:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048e99:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048e9c:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8048e9f:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048ea2:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048ea5:	cd 2e                	int    $0x2e
 8048ea7:	89 c6                	mov    %eax,%esi
 8048ea9:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048eac:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8048eb3:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048eb6:	cd 2e                	int    $0x2e
 8048eb8:	89 c2                	mov    %eax,%edx
 8048eba:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048ec0:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048ec2:	8b 45 f0             	mov    -0x10(%ebp),%eax
        return trap(SYS_errno, 0);
}
 8048ec5:	83 c4 14             	add    $0x14,%esp
 8048ec8:	5e                   	pop    %esi
 8048ec9:	5d                   	pop    %ebp
 8048eca:	c3                   	ret    

08048ecb <getdents>:

int getdents(int fd, dirent_t *dir, size_t size)
{
 8048ecb:	55                   	push   %ebp
 8048ecc:	89 e5                	mov    %esp,%ebp
 8048ece:	56                   	push   %esi
 8048ecf:	83 ec 24             	sub    $0x24,%esp
 8048ed2:	e8 7c 01 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 8048ed7:	81 c1 41 56 00 00    	add    $0x5641,%ecx
        getdents_args_t args;

        args.fd = fd;
 8048edd:	8b 45 08             	mov    0x8(%ebp),%eax
 8048ee0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.dirp = dir;
 8048ee3:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048ee6:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.count = size;
 8048ee9:	8b 45 10             	mov    0x10(%ebp),%eax
 8048eec:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_getdents, (uint32_t) &args);
 8048eef:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048ef2:	c7 45 f8 17 00 00 00 	movl   $0x17,-0x8(%ebp)
 8048ef9:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048efc:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048eff:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8048f02:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048f05:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048f08:	cd 2e                	int    $0x2e
 8048f0a:	89 c6                	mov    %eax,%esi
 8048f0c:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048f0f:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 8048f16:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048f19:	cd 2e                	int    $0x2e
 8048f1b:	89 c2                	mov    %eax,%edx
 8048f1d:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048f23:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048f25:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048f28:	83 c4 24             	add    $0x24,%esp
 8048f2b:	5e                   	pop    %esi
 8048f2c:	5d                   	pop    %ebp
 8048f2d:	c3                   	ret    

08048f2e <stat>:
}
#endif /* MOUNTING */

int
stat(const char *path, struct stat *buf)
{
 8048f2e:	55                   	push   %ebp
 8048f2f:	89 e5                	mov    %esp,%ebp
 8048f31:	56                   	push   %esi
 8048f32:	53                   	push   %ebx
 8048f33:	83 ec 40             	sub    $0x40,%esp
 8048f36:	e8 1c 01 00 00       	call   8049057 <__i686.get_pc_thunk.bx>
 8048f3b:	81 c3 dd 55 00 00    	add    $0x55dd,%ebx
        stat_args_t args;

        args.path.as_len = strlen(path);
 8048f41:	8b 45 08             	mov    0x8(%ebp),%eax
 8048f44:	89 04 24             	mov    %eax,(%esp)
 8048f47:	e8 d5 24 00 00       	call   804b421 <strlen>
 8048f4c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.path.as_str = path;
 8048f4f:	8b 45 08             	mov    0x8(%ebp),%eax
 8048f52:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.buf = buf;
 8048f55:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048f58:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_stat, (uint32_t) &args);
 8048f5b:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8048f5e:	c7 45 f4 2f 00 00 00 	movl   $0x2f,-0xc(%ebp)
 8048f65:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048f68:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048f6b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8048f6e:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048f71:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048f74:	cd 2e                	int    $0x2e
 8048f76:	89 c6                	mov    %eax,%esi
 8048f78:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048f7b:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8048f82:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048f85:	cd 2e                	int    $0x2e
 8048f87:	89 c2                	mov    %eax,%edx
 8048f89:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048f8f:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048f91:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048f94:	83 c4 40             	add    $0x40,%esp
 8048f97:	5b                   	pop    %ebx
 8048f98:	5e                   	pop    %esi
 8048f99:	5d                   	pop    %ebp
 8048f9a:	c3                   	ret    

08048f9b <uname>:

int
uname(struct utsname *buf)
{
 8048f9b:	55                   	push   %ebp
 8048f9c:	89 e5                	mov    %esp,%ebp
 8048f9e:	56                   	push   %esi
 8048f9f:	83 ec 14             	sub    $0x14,%esp
 8048fa2:	e8 ac 00 00 00       	call   8049053 <__i686.get_pc_thunk.cx>
 8048fa7:	81 c1 71 55 00 00    	add    $0x5571,%ecx
        return trap(SYS_uname, (uint32_t) buf);
 8048fad:	8b 45 08             	mov    0x8(%ebp),%eax
 8048fb0:	c7 45 f8 1c 00 00 00 	movl   $0x1c,-0x8(%ebp)
 8048fb7:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048fba:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048fbd:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8048fc0:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048fc3:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048fc6:	cd 2e                	int    $0x2e
 8048fc8:	89 c6                	mov    %eax,%esi
 8048fca:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048fcd:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8048fd4:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048fd7:	cd 2e                	int    $0x2e
 8048fd9:	89 c2                	mov    %eax,%edx
 8048fdb:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048fe1:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048fe3:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048fe6:	83 c4 14             	add    $0x14,%esp
 8048fe9:	5e                   	pop    %esi
 8048fea:	5d                   	pop    %ebp
 8048feb:	c3                   	ret    

08048fec <debug>:

int
debug(const char *str)
{
 8048fec:	55                   	push   %ebp
 8048fed:	89 e5                	mov    %esp,%ebp
 8048fef:	56                   	push   %esi
 8048ff0:	53                   	push   %ebx
 8048ff1:	83 ec 40             	sub    $0x40,%esp
 8048ff4:	e8 5e 00 00 00       	call   8049057 <__i686.get_pc_thunk.bx>
 8048ff9:	81 c3 1f 55 00 00    	add    $0x551f,%ebx
        argstr_t argstr;
        argstr.as_len = strlen(str);
 8048fff:	8b 45 08             	mov    0x8(%ebp),%eax
 8049002:	89 04 24             	mov    %eax,(%esp)
 8049005:	e8 17 24 00 00       	call   804b421 <strlen>
 804900a:	89 45 e8             	mov    %eax,-0x18(%ebp)
        argstr.as_str = str;
 804900d:	8b 45 08             	mov    0x8(%ebp),%eax
 8049010:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_debug, (uint32_t) &argstr);
 8049013:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8049016:	c7 45 f4 29 23 00 00 	movl   $0x2329,-0xc(%ebp)
 804901d:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049020:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049023:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8049026:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8049029:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804902c:	cd 2e                	int    $0x2e
 804902e:	89 c6                	mov    %eax,%esi
 8049030:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049033:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 804903a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804903d:	cd 2e                	int    $0x2e
 804903f:	89 c2                	mov    %eax,%edx
 8049041:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8049047:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049049:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 804904c:	83 c4 40             	add    $0x40,%esp
 804904f:	5b                   	pop    %ebx
 8049050:	5e                   	pop    %esi
 8049051:	5d                   	pop    %ebp
 8049052:	c3                   	ret    

08049053 <__i686.get_pc_thunk.cx>:
 8049053:	8b 0c 24             	mov    (%esp),%ecx
 8049056:	c3                   	ret    

08049057 <__i686.get_pc_thunk.bx>:
 8049057:	8b 1c 24             	mov    (%esp),%ebx
 804905a:	c3                   	ret    
 804905b:	90                   	nop

0804905c <wrterror>:
#define abort() exit(1)
#endif

static void
wrterror(char *p)
{
 804905c:	55                   	push   %ebp
 804905d:	89 e5                	mov    %esp,%ebp
 804905f:	53                   	push   %ebx
 8049060:	83 ec 24             	sub    $0x24,%esp
 8049063:	e8 ef ff ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 8049068:	81 c3 b0 54 00 00    	add    $0x54b0,%ebx
        char *q = " error: ";
 804906e:	8d 83 a1 d8 ff ff    	lea    -0x275f(%ebx),%eax
 8049074:	89 45 f4             	mov    %eax,-0xc(%ebp)
        _write(STDERR_FILENO, __progname, strlen(__progname));
 8049077:	8b 83 10 00 00 00    	mov    0x10(%ebx),%eax
 804907d:	89 04 24             	mov    %eax,(%esp)
 8049080:	e8 9c 23 00 00       	call   804b421 <strlen>
 8049085:	8b 93 10 00 00 00    	mov    0x10(%ebx),%edx
 804908b:	89 44 24 08          	mov    %eax,0x8(%esp)
 804908f:	89 54 24 04          	mov    %edx,0x4(%esp)
 8049093:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804909a:	e8 7b f7 ff ff       	call   804881a <write>
        _write(STDERR_FILENO, malloc_func, strlen(malloc_func));
 804909f:	8b 83 24 01 00 00    	mov    0x124(%ebx),%eax
 80490a5:	89 04 24             	mov    %eax,(%esp)
 80490a8:	e8 74 23 00 00       	call   804b421 <strlen>
 80490ad:	8b 93 24 01 00 00    	mov    0x124(%ebx),%edx
 80490b3:	89 44 24 08          	mov    %eax,0x8(%esp)
 80490b7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80490bb:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 80490c2:	e8 53 f7 ff ff       	call   804881a <write>
        _write(STDERR_FILENO, q, strlen(q));
 80490c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80490ca:	89 04 24             	mov    %eax,(%esp)
 80490cd:	e8 4f 23 00 00       	call   804b421 <strlen>
 80490d2:	89 44 24 08          	mov    %eax,0x8(%esp)
 80490d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80490d9:	89 44 24 04          	mov    %eax,0x4(%esp)
 80490dd:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 80490e4:	e8 31 f7 ff ff       	call   804881a <write>
        _write(STDERR_FILENO, p, strlen(p));
 80490e9:	8b 45 08             	mov    0x8(%ebp),%eax
 80490ec:	89 04 24             	mov    %eax,(%esp)
 80490ef:	e8 2d 23 00 00       	call   804b421 <strlen>
 80490f4:	89 44 24 08          	mov    %eax,0x8(%esp)
 80490f8:	8b 45 08             	mov    0x8(%ebp),%eax
 80490fb:	89 44 24 04          	mov    %eax,0x4(%esp)
 80490ff:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049106:	e8 0f f7 ff ff       	call   804881a <write>
        suicide = 1;
 804910b:	c7 83 00 01 00 00 01 	movl   $0x1,0x100(%ebx)
 8049112:	00 00 00 
        abort();
 8049115:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804911c:	e8 53 f2 ff ff       	call   8048374 <exit>
}
 8049121:	83 c4 24             	add    $0x24,%esp
 8049124:	5b                   	pop    %ebx
 8049125:	5d                   	pop    %ebp
 8049126:	c3                   	ret    

08049127 <wrtwarning>:

static void
wrtwarning(char *p)
{
 8049127:	55                   	push   %ebp
 8049128:	89 e5                	mov    %esp,%ebp
 804912a:	53                   	push   %ebx
 804912b:	83 ec 24             	sub    $0x24,%esp
 804912e:	e8 24 ff ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 8049133:	81 c3 e5 53 00 00    	add    $0x53e5,%ebx
        char *q = " warning: ";
 8049139:	8d 83 aa d8 ff ff    	lea    -0x2756(%ebx),%eax
 804913f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (malloc_abort)
 8049142:	8b 83 fc 00 00 00    	mov    0xfc(%ebx),%eax
 8049148:	85 c0                	test   %eax,%eax
 804914a:	74 0b                	je     8049157 <wrtwarning+0x30>
                wrterror(p);
 804914c:	8b 45 08             	mov    0x8(%ebp),%eax
 804914f:	89 04 24             	mov    %eax,(%esp)
 8049152:	e8 05 ff ff ff       	call   804905c <wrterror>
        _write(STDERR_FILENO, __progname, strlen(__progname));
 8049157:	8b 83 10 00 00 00    	mov    0x10(%ebx),%eax
 804915d:	89 04 24             	mov    %eax,(%esp)
 8049160:	e8 bc 22 00 00       	call   804b421 <strlen>
 8049165:	8b 93 10 00 00 00    	mov    0x10(%ebx),%edx
 804916b:	89 44 24 08          	mov    %eax,0x8(%esp)
 804916f:	89 54 24 04          	mov    %edx,0x4(%esp)
 8049173:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804917a:	e8 9b f6 ff ff       	call   804881a <write>
        _write(STDERR_FILENO, malloc_func, strlen(malloc_func));
 804917f:	8b 83 24 01 00 00    	mov    0x124(%ebx),%eax
 8049185:	89 04 24             	mov    %eax,(%esp)
 8049188:	e8 94 22 00 00       	call   804b421 <strlen>
 804918d:	8b 93 24 01 00 00    	mov    0x124(%ebx),%edx
 8049193:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049197:	89 54 24 04          	mov    %edx,0x4(%esp)
 804919b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 80491a2:	e8 73 f6 ff ff       	call   804881a <write>
        _write(STDERR_FILENO, q, strlen(q));
 80491a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80491aa:	89 04 24             	mov    %eax,(%esp)
 80491ad:	e8 6f 22 00 00       	call   804b421 <strlen>
 80491b2:	89 44 24 08          	mov    %eax,0x8(%esp)
 80491b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80491b9:	89 44 24 04          	mov    %eax,0x4(%esp)
 80491bd:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 80491c4:	e8 51 f6 ff ff       	call   804881a <write>
        _write(STDERR_FILENO, p, strlen(p));
 80491c9:	8b 45 08             	mov    0x8(%ebp),%eax
 80491cc:	89 04 24             	mov    %eax,(%esp)
 80491cf:	e8 4d 22 00 00       	call   804b421 <strlen>
 80491d4:	89 44 24 08          	mov    %eax,0x8(%esp)
 80491d8:	8b 45 08             	mov    0x8(%ebp),%eax
 80491db:	89 44 24 04          	mov    %eax,0x4(%esp)
 80491df:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 80491e6:	e8 2f f6 ff ff       	call   804881a <write>
}
 80491eb:	83 c4 24             	add    $0x24,%esp
 80491ee:	5b                   	pop    %ebx
 80491ef:	5d                   	pop    %ebp
 80491f0:	c3                   	ret    

080491f1 <map_pages>:
/*
 * Allocate a number of pages from the OS
 */
static void *
map_pages(int pages)
{
 80491f1:	55                   	push   %ebp
 80491f2:	89 e5                	mov    %esp,%ebp
 80491f4:	53                   	push   %ebx
 80491f5:	83 ec 24             	sub    $0x24,%esp
 80491f8:	e8 5a fe ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 80491fd:	81 c3 1b 53 00 00    	add    $0x531b,%ebx
        caddr_t result, tail;

        result = (caddr_t)pageround((u_long)sbrk(0));
 8049203:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804920a:	e8 3d ef ff ff       	call   804814c <sbrk>
 804920f:	05 ff 0f 00 00       	add    $0xfff,%eax
 8049214:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 8049219:	89 45 f4             	mov    %eax,-0xc(%ebp)
        tail = result + (pages << malloc_pageshift);
 804921c:	8b 45 08             	mov    0x8(%ebp),%eax
 804921f:	c1 e0 0c             	shl    $0xc,%eax
 8049222:	03 45 f4             	add    -0xc(%ebp),%eax
 8049225:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (brk(tail)) {
 8049228:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804922b:	89 04 24             	mov    %eax,(%esp)
 804922e:	e8 e9 ef ff ff       	call   804821c <brk>
 8049233:	85 c0                	test   %eax,%eax
 8049235:	74 07                	je     804923e <map_pages+0x4d>
#ifdef EXTRA_SANITY
                wrterror("(ES): map_pages fails\n");
#endif /* EXTRA_SANITY */
                return 0;
 8049237:	b8 00 00 00 00       	mov    $0x0,%eax
 804923c:	eb 55                	jmp    8049293 <map_pages+0xa2>
        }

        last_index = ptr2index(tail) - 1;
 804923e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049241:	89 c2                	mov    %eax,%edx
 8049243:	c1 ea 0c             	shr    $0xc,%edx
 8049246:	8b 83 d8 00 00 00    	mov    0xd8(%ebx),%eax
 804924c:	89 d1                	mov    %edx,%ecx
 804924e:	29 c1                	sub    %eax,%ecx
 8049250:	89 c8                	mov    %ecx,%eax
 8049252:	83 e8 01             	sub    $0x1,%eax
 8049255:	89 83 dc 00 00 00    	mov    %eax,0xdc(%ebx)
        malloc_brk = tail;
 804925b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804925e:	89 83 1c 01 00 00    	mov    %eax,0x11c(%ebx)

        if ((last_index + 1) >= malloc_ninfo && !extend_pgdir(last_index))
 8049264:	8b 83 dc 00 00 00    	mov    0xdc(%ebx),%eax
 804926a:	8d 50 01             	lea    0x1(%eax),%edx
 804926d:	8b 83 e4 00 00 00    	mov    0xe4(%ebx),%eax
 8049273:	39 c2                	cmp    %eax,%edx
 8049275:	72 19                	jb     8049290 <map_pages+0x9f>
 8049277:	8b 83 dc 00 00 00    	mov    0xdc(%ebx),%eax
 804927d:	89 04 24             	mov    %eax,(%esp)
 8049280:	e8 14 00 00 00       	call   8049299 <extend_pgdir>
 8049285:	85 c0                	test   %eax,%eax
 8049287:	75 07                	jne    8049290 <map_pages+0x9f>
                return 0;;
 8049289:	b8 00 00 00 00       	mov    $0x0,%eax
 804928e:	eb 03                	jmp    8049293 <map_pages+0xa2>

        return result;
 8049290:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8049293:	83 c4 24             	add    $0x24,%esp
 8049296:	5b                   	pop    %ebx
 8049297:	5d                   	pop    %ebp
 8049298:	c3                   	ret    

08049299 <extend_pgdir>:
/*
 * Extend page directory
 */
static int
extend_pgdir(u_long index)
{
 8049299:	55                   	push   %ebp
 804929a:	89 e5                	mov    %esp,%ebp
 804929c:	53                   	push   %ebx
 804929d:	83 ec 34             	sub    $0x34,%esp
 80492a0:	e8 b2 fd ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 80492a5:	81 c3 73 52 00 00    	add    $0x5273,%ebx
        struct  pginfo **new, **old;
        int i, oldlen;

        /* Make it this many pages */
        i = index * sizeof * page_dir;
 80492ab:	8b 45 08             	mov    0x8(%ebp),%eax
 80492ae:	c1 e0 02             	shl    $0x2,%eax
 80492b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
        i /= malloc_pagesize;
 80492b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80492b7:	c1 e8 0c             	shr    $0xc,%eax
 80492ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
        i += 2;
 80492bd:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)

        /* remember the old mapping size */
        oldlen = malloc_ninfo * sizeof * page_dir;
 80492c1:	8b 83 e4 00 00 00    	mov    0xe4(%ebx),%eax
 80492c7:	c1 e0 02             	shl    $0x2,%eax
 80492ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
         * address, the old pages will be "magically" remapped..  But this means
         * keeping open a "secret" file descriptor.....
         */

        /* Get new pages */
        new = (struct pginfo **) MMAP(i * malloc_pagesize);
 80492cd:	8b 83 cc 00 00 00    	mov    0xcc(%ebx),%eax
 80492d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80492d6:	c1 e2 0c             	shl    $0xc,%edx
 80492d9:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 80492e0:	00 
 80492e1:	89 44 24 10          	mov    %eax,0x10(%esp)
 80492e5:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
 80492ec:	00 
 80492ed:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 80492f4:	00 
 80492f5:	89 54 24 04          	mov    %edx,0x4(%esp)
 80492f9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8049300:	e8 bb f2 ff ff       	call   80485c0 <mmap>
 8049305:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (new == (struct pginfo **) - 1)
 8049308:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
 804930c:	75 07                	jne    8049315 <extend_pgdir+0x7c>
                return 0;
 804930e:	b8 00 00 00 00       	mov    $0x0,%eax
 8049313:	eb 5e                	jmp    8049373 <extend_pgdir+0xda>

        /* Copy the old stuff */
        memcpy(new, page_dir,
 8049315:	8b 83 e4 00 00 00    	mov    0xe4(%ebx),%eax
 804931b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8049322:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 8049328:	89 54 24 08          	mov    %edx,0x8(%esp)
 804932c:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049330:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049333:	89 04 24             	mov    %eax,(%esp)
 8049336:	e8 eb 1e 00 00       	call   804b226 <memcpy>
               malloc_ninfo * sizeof * page_dir);

        /* register the new size */
        malloc_ninfo = i * malloc_pagesize / sizeof * page_dir;
 804933b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804933e:	c1 e0 0c             	shl    $0xc,%eax
 8049341:	c1 e8 02             	shr    $0x2,%eax
 8049344:	89 83 e4 00 00 00    	mov    %eax,0xe4(%ebx)

        /* swap the pointers */
        old = page_dir;
 804934a:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 8049350:	89 45 e8             	mov    %eax,-0x18(%ebp)
        page_dir = new;
 8049353:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049356:	89 83 e0 00 00 00    	mov    %eax,0xe0(%ebx)

        /* Now free the old stuff */
        munmap((char *)old, oldlen);
 804935c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804935f:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049363:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049366:	89 04 24             	mov    %eax,(%esp)
 8049369:	e8 c7 f2 ff ff       	call   8048635 <munmap>
        return 1;
 804936e:	b8 01 00 00 00       	mov    $0x1,%eax
}
 8049373:	83 c4 34             	add    $0x34,%esp
 8049376:	5b                   	pop    %ebx
 8049377:	5d                   	pop    %ebp
 8049378:	c3                   	ret    

08049379 <malloc_init>:
/*
 * Initialize the world
 */
static void
malloc_init()
{
 8049379:	55                   	push   %ebp
 804937a:	89 e5                	mov    %esp,%ebp
 804937c:	53                   	push   %ebx
 804937d:	83 ec 34             	sub    $0x34,%esp
 8049380:	e8 d2 fc ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 8049385:	81 c3 93 51 00 00    	add    $0x5193,%ebx
        char *p;
        int i, j;

        INIT_MMAP();
 804938b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 8049392:	00 
 8049393:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
 804939a:	00 
 804939b:	8d 83 b5 d8 ff ff    	lea    -0x274b(%ebx),%eax
 80493a1:	89 04 24             	mov    %eax,(%esp)
 80493a4:	e8 38 f3 ff ff       	call   80486e1 <open>
 80493a9:	89 83 cc 00 00 00    	mov    %eax,0xcc(%ebx)
 80493af:	8b 83 cc 00 00 00    	mov    0xcc(%ebx),%eax
 80493b5:	83 f8 ff             	cmp    $0xffffffff,%eax
 80493b8:	75 0e                	jne    80493c8 <malloc_init+0x4f>
 80493ba:	8d 83 bf d8 ff ff    	lea    -0x2741(%ebx),%eax
 80493c0:	89 04 24             	mov    %eax,(%esp)
 80493c3:	e8 94 fc ff ff       	call   804905c <wrterror>

#ifdef EXTRA_SANITY
        malloc_junk = 1;
#endif /* EXTRA_SANITY */

        for (i = 0; i < 3; i++) {
 80493c8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 80493cf:	e9 7f 02 00 00       	jmp    8049653 <malloc_init+0x2da>
                if (i == 0) {
 80493d4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 80493d8:	75 0c                	jne    80493e6 <malloc_init+0x6d>
                        if (j <= 0)
                                continue;
                        b[j] = '\0';
                        p = b;
#else
                        p = NULL;
 80493da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        p = NULL;
#endif
                } else {
                        p = malloc_options;
                }
                for (; p && *p; p++) {
 80493e1:	e9 55 02 00 00       	jmp    804963b <malloc_init+0x2c2>
                        b[j] = '\0';
                        p = b;
#else
                        p = NULL;
#endif
                } else if (i == 1) {
 80493e6:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
 80493ea:	75 0c                	jne    80493f8 <malloc_init+0x7f>
#ifdef HAS_GETENV
                        p = getenv("MALLOC_OPTIONS");
#else
                        p = NULL;
 80493ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#endif
                } else {
                        p = malloc_options;
                }
                for (; p && *p; p++) {
 80493f3:	e9 43 02 00 00       	jmp    804963b <malloc_init+0x2c2>
                        p = getenv("MALLOC_OPTIONS");
#else
                        p = NULL;
#endif
                } else {
                        p = malloc_options;
 80493f8:	8b 83 f8 ff ff ff    	mov    -0x8(%ebx),%eax
 80493fe:	8b 00                	mov    (%eax),%eax
 8049400:	89 45 f4             	mov    %eax,-0xc(%ebp)
                }
                for (; p && *p; p++) {
 8049403:	e9 33 02 00 00       	jmp    804963b <malloc_init+0x2c2>
                        switch (*p) {
 8049408:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804940b:	0f b6 00             	movzbl (%eax),%eax
 804940e:	0f be c0             	movsbl %al,%eax
 8049411:	83 e8 3c             	sub    $0x3c,%eax
 8049414:	83 f8 3e             	cmp    $0x3e,%eax
 8049417:	0f 87 ef 01 00 00    	ja     804960c <malloc_init+0x293>
 804941d:	c1 e0 02             	shl    $0x2,%eax
 8049420:	8b 84 18 18 af ff ff 	mov    -0x50e8(%eax,%ebx,1),%eax
 8049427:	89 da                	mov    %ebx,%edx
 8049429:	29 c2                	sub    %eax,%edx
 804942b:	89 d0                	mov    %edx,%eax
 804942d:	ff e0                	jmp    *%eax
 804942f:	90                   	nop
 8049430:	d9 4f 00             	(bad)  0x0(%edi)
 8049433:	00 0c 4f             	add    %cl,(%edi,%ecx,2)
 8049436:	00 00                	add    %al,(%eax)
 8049438:	ec                   	in     (%dx),%al
 8049439:	4f                   	dec    %edi
 804943a:	00 00                	add    %al,(%eax)
 804943c:	0c 4f                	or     $0x4f,%al
 804943e:	00 00                	add    %al,(%eax)
 8049440:	0c 4f                	or     $0x4f,%al
 8049442:	00 00                	add    %al,(%eax)
 8049444:	b7 4f                	mov    $0x4f,%bh
 8049446:	00 00                	add    %al,(%eax)
 8049448:	0c 4f                	or     $0x4f,%al
 804944a:	00 00                	add    %al,(%eax)
 804944c:	0c 4f                	or     $0x4f,%al
 804944e:	00 00                	add    %al,(%eax)
 8049450:	0c 4f                	or     $0x4f,%al
 8049452:	00 00                	add    %al,(%eax)
 8049454:	0c 4f                	or     $0x4f,%al
 8049456:	00 00                	add    %al,(%eax)
 8049458:	0c 4f                	or     $0x4f,%al
 804945a:	00 00                	add    %al,(%eax)
 804945c:	0c 4f                	or     $0x4f,%al
 804945e:	00 00                	add    %al,(%eax)
 8049460:	99                   	cltd   
 8049461:	4f                   	dec    %edi
 8049462:	00 00                	add    %al,(%eax)
 8049464:	0c 4f                	or     $0x4f,%al
 8049466:	00 00                	add    %al,(%eax)
 8049468:	60                   	pusha  
 8049469:	4f                   	dec    %edi
 804946a:	00 00                	add    %al,(%eax)
 804946c:	0c 4f                	or     $0x4f,%al
 804946e:	00 00                	add    %al,(%eax)
 8049470:	0c 4f                	or     $0x4f,%al
 8049472:	00 00                	add    %al,(%eax)
 8049474:	0c 4f                	or     $0x4f,%al
 8049476:	00 00                	add    %al,(%eax)
 8049478:	0c 4f                	or     $0x4f,%al
 804947a:	00 00                	add    %al,(%eax)
 804947c:	0c 4f                	or     $0x4f,%al
 804947e:	00 00                	add    %al,(%eax)
 8049480:	0c 4f                	or     $0x4f,%al
 8049482:	00 00                	add    %al,(%eax)
 8049484:	0c 4f                	or     $0x4f,%al
 8049486:	00 00                	add    %al,(%eax)
 8049488:	7b 4f                	jnp    80494d9 <malloc_init+0x160>
 804948a:	00 00                	add    %al,(%eax)
 804948c:	0c 4f                	or     $0x4f,%al
 804948e:	00 00                	add    %al,(%eax)
 8049490:	0c 4f                	or     $0x4f,%al
 8049492:	00 00                	add    %al,(%eax)
 8049494:	0c 4f                	or     $0x4f,%al
 8049496:	00 00                	add    %al,(%eax)
 8049498:	48                   	dec    %eax
 8049499:	4f                   	dec    %edi
 804949a:	00 00                	add    %al,(%eax)
 804949c:	0c 4f                	or     $0x4f,%al
 804949e:	00 00                	add    %al,(%eax)
 80494a0:	30 4f 00             	xor    %cl,0x0(%edi)
 80494a3:	00 0c 4f             	add    %cl,(%edi,%ecx,2)
 80494a6:	00 00                	add    %al,(%eax)
 80494a8:	18 4f 00             	sbb    %cl,0x0(%edi)
 80494ab:	00 0c 4f             	add    %cl,(%edi,%ecx,2)
 80494ae:	00 00                	add    %al,(%eax)
 80494b0:	0c 4f                	or     $0x4f,%al
 80494b2:	00 00                	add    %al,(%eax)
 80494b4:	0c 4f                	or     $0x4f,%al
 80494b6:	00 00                	add    %al,(%eax)
 80494b8:	0c 4f                	or     $0x4f,%al
 80494ba:	00 00                	add    %al,(%eax)
 80494bc:	0c 4f                	or     $0x4f,%al
 80494be:	00 00                	add    %al,(%eax)
 80494c0:	0c 4f                	or     $0x4f,%al
 80494c2:	00 00                	add    %al,(%eax)
 80494c4:	c6                   	(bad)  
 80494c5:	4f                   	dec    %edi
 80494c6:	00 00                	add    %al,(%eax)
 80494c8:	0c 4f                	or     $0x4f,%al
 80494ca:	00 00                	add    %al,(%eax)
 80494cc:	0c 4f                	or     $0x4f,%al
 80494ce:	00 00                	add    %al,(%eax)
 80494d0:	0c 4f                	or     $0x4f,%al
 80494d2:	00 00                	add    %al,(%eax)
 80494d4:	0c 4f                	or     $0x4f,%al
 80494d6:	00 00                	add    %al,(%eax)
 80494d8:	0c 4f                	or     $0x4f,%al
 80494da:	00 00                	add    %al,(%eax)
 80494dc:	0c 4f                	or     $0x4f,%al
 80494de:	00 00                	add    %al,(%eax)
 80494e0:	a8 4f                	test   $0x4f,%al
 80494e2:	00 00                	add    %al,(%eax)
 80494e4:	0c 4f                	or     $0x4f,%al
 80494e6:	00 00                	add    %al,(%eax)
 80494e8:	6c                   	insb   (%dx),%es:(%edi)
 80494e9:	4f                   	dec    %edi
 80494ea:	00 00                	add    %al,(%eax)
 80494ec:	0c 4f                	or     $0x4f,%al
 80494ee:	00 00                	add    %al,(%eax)
 80494f0:	0c 4f                	or     $0x4f,%al
 80494f2:	00 00                	add    %al,(%eax)
 80494f4:	0c 4f                	or     $0x4f,%al
 80494f6:	00 00                	add    %al,(%eax)
 80494f8:	0c 4f                	or     $0x4f,%al
 80494fa:	00 00                	add    %al,(%eax)
 80494fc:	0c 4f                	or     $0x4f,%al
 80494fe:	00 00                	add    %al,(%eax)
 8049500:	0c 4f                	or     $0x4f,%al
 8049502:	00 00                	add    %al,(%eax)
 8049504:	0c 4f                	or     $0x4f,%al
 8049506:	00 00                	add    %al,(%eax)
 8049508:	8a 4f 00             	mov    0x0(%edi),%cl
 804950b:	00 0c 4f             	add    %cl,(%edi,%ecx,2)
 804950e:	00 00                	add    %al,(%eax)
 8049510:	0c 4f                	or     $0x4f,%al
 8049512:	00 00                	add    %al,(%eax)
 8049514:	0c 4f                	or     $0x4f,%al
 8049516:	00 00                	add    %al,(%eax)
 8049518:	54                   	push   %esp
 8049519:	4f                   	dec    %edi
 804951a:	00 00                	add    %al,(%eax)
 804951c:	0c 4f                	or     $0x4f,%al
 804951e:	00 00                	add    %al,(%eax)
 8049520:	3c 4f                	cmp    $0x4f,%al
 8049522:	00 00                	add    %al,(%eax)
 8049524:	0c 4f                	or     $0x4f,%al
 8049526:	00 00                	add    %al,(%eax)
 8049528:	24 4f                	and    $0x4f,%al
 804952a:	00 00                	add    %al,(%eax)
                                case '>': malloc_cache   <<= 1; break;
 804952c:	8b 83 0c 00 00 00    	mov    0xc(%ebx),%eax
 8049532:	01 c0                	add    %eax,%eax
 8049534:	89 83 0c 00 00 00    	mov    %eax,0xc(%ebx)
 804953a:	e9 f8 00 00 00       	jmp    8049637 <malloc_init+0x2be>
                                case '<': malloc_cache   >>= 1; break;
 804953f:	8b 83 0c 00 00 00    	mov    0xc(%ebx),%eax
 8049545:	d1 e8                	shr    %eax
 8049547:	89 83 0c 00 00 00    	mov    %eax,0xc(%ebx)
 804954d:	e9 e5 00 00 00       	jmp    8049637 <malloc_init+0x2be>
                                case 'a': malloc_abort   = 0; break;
 8049552:	c7 83 fc 00 00 00 00 	movl   $0x0,0xfc(%ebx)
 8049559:	00 00 00 
 804955c:	e9 d6 00 00 00       	jmp    8049637 <malloc_init+0x2be>
                                case 'A': malloc_abort   = 1; break;
 8049561:	c7 83 fc 00 00 00 01 	movl   $0x1,0xfc(%ebx)
 8049568:	00 00 00 
 804956b:	e9 c7 00 00 00       	jmp    8049637 <malloc_init+0x2be>
                                case 'h': malloc_hint    = 0; break;
 8049570:	c7 83 08 01 00 00 00 	movl   $0x0,0x108(%ebx)
 8049577:	00 00 00 
 804957a:	e9 b8 00 00 00       	jmp    8049637 <malloc_init+0x2be>
                                case 'H': malloc_hint    = 1; break;
 804957f:	c7 83 08 01 00 00 01 	movl   $0x1,0x108(%ebx)
 8049586:	00 00 00 
 8049589:	e9 a9 00 00 00       	jmp    8049637 <malloc_init+0x2be>
                                case 'r': malloc_realloc = 0; break;
 804958e:	c7 83 04 01 00 00 00 	movl   $0x0,0x104(%ebx)
 8049595:	00 00 00 
 8049598:	e9 9a 00 00 00       	jmp    8049637 <malloc_init+0x2be>
                                case 'R': malloc_realloc = 1; break;
 804959d:	c7 83 04 01 00 00 01 	movl   $0x1,0x104(%ebx)
 80495a4:	00 00 00 
 80495a7:	e9 8b 00 00 00       	jmp    8049637 <malloc_init+0x2be>
                                case 'j': malloc_junk    = 0; break;
 80495ac:	c7 83 18 01 00 00 00 	movl   $0x0,0x118(%ebx)
 80495b3:	00 00 00 
 80495b6:	eb 7f                	jmp    8049637 <malloc_init+0x2be>
                                case 'J': malloc_junk    = 1; break;
 80495b8:	c7 83 18 01 00 00 01 	movl   $0x1,0x118(%ebx)
 80495bf:	00 00 00 
 80495c2:	eb 73                	jmp    8049637 <malloc_init+0x2be>
#ifdef HAS_UTRACE
                                case 'u': malloc_utrace  = 0; break;
                                case 'U': malloc_utrace  = 1; break;
#endif
                                case 'v': malloc_sysv    = 0; break;
 80495c4:	c7 83 10 01 00 00 00 	movl   $0x0,0x110(%ebx)
 80495cb:	00 00 00 
 80495ce:	eb 67                	jmp    8049637 <malloc_init+0x2be>
                                case 'V': malloc_sysv    = 1; break;
 80495d0:	c7 83 10 01 00 00 01 	movl   $0x1,0x110(%ebx)
 80495d7:	00 00 00 
 80495da:	eb 5b                	jmp    8049637 <malloc_init+0x2be>
                                case 'x': malloc_xmalloc = 0; break;
 80495dc:	c7 83 0c 01 00 00 00 	movl   $0x0,0x10c(%ebx)
 80495e3:	00 00 00 
 80495e6:	eb 4f                	jmp    8049637 <malloc_init+0x2be>
                                case 'X': malloc_xmalloc = 1; break;
 80495e8:	c7 83 0c 01 00 00 01 	movl   $0x1,0x10c(%ebx)
 80495ef:	00 00 00 
 80495f2:	eb 43                	jmp    8049637 <malloc_init+0x2be>
                                case 'z': malloc_zero    = 0; break;
 80495f4:	c7 83 14 01 00 00 00 	movl   $0x0,0x114(%ebx)
 80495fb:	00 00 00 
 80495fe:	eb 37                	jmp    8049637 <malloc_init+0x2be>
                                case 'Z': malloc_zero    = 1; break;
 8049600:	c7 83 14 01 00 00 01 	movl   $0x1,0x114(%ebx)
 8049607:	00 00 00 
 804960a:	eb 2b                	jmp    8049637 <malloc_init+0x2be>
                                default:
                                        j = malloc_abort;
 804960c:	8b 83 fc 00 00 00    	mov    0xfc(%ebx),%eax
 8049612:	89 45 ec             	mov    %eax,-0x14(%ebp)
                                        malloc_abort = 0;
 8049615:	c7 83 fc 00 00 00 00 	movl   $0x0,0xfc(%ebx)
 804961c:	00 00 00 
                                        wrtwarning("unknown char in MALLOC_OPTIONS\n");
 804961f:	8d 83 d4 d8 ff ff    	lea    -0x272c(%ebx),%eax
 8049625:	89 04 24             	mov    %eax,(%esp)
 8049628:	e8 fa fa ff ff       	call   8049127 <wrtwarning>
                                        malloc_abort = j;
 804962d:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049630:	89 83 fc 00 00 00    	mov    %eax,0xfc(%ebx)
                                        break;
 8049636:	90                   	nop
                        p = NULL;
#endif
                } else {
                        p = malloc_options;
                }
                for (; p && *p; p++) {
 8049637:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 804963b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804963f:	74 0e                	je     804964f <malloc_init+0x2d6>
 8049641:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049644:	0f b6 00             	movzbl (%eax),%eax
 8049647:	84 c0                	test   %al,%al
 8049649:	0f 85 b9 fd ff ff    	jne    8049408 <malloc_init+0x8f>

#ifdef EXTRA_SANITY
        malloc_junk = 1;
#endif /* EXTRA_SANITY */

        for (i = 0; i < 3; i++) {
 804964f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
 8049653:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
 8049657:	0f 8e 77 fd ff ff    	jle    80493d4 <malloc_init+0x5b>

        /*
         * We want junk in the entire allocation, and zero only in the part
         * the user asked for.
         */
        if (malloc_zero)
 804965d:	8b 83 14 01 00 00    	mov    0x114(%ebx),%eax
 8049663:	85 c0                	test   %eax,%eax
 8049665:	74 0a                	je     8049671 <malloc_init+0x2f8>
                malloc_junk = 1;
 8049667:	c7 83 18 01 00 00 01 	movl   $0x1,0x118(%ebx)
 804966e:	00 00 00 

        /*
         * If we run with junk (or implicitly from above: zero), we want to
         * force realloc() to get new storage, so we can DTRT with it.
         */
        if (malloc_junk)
 8049671:	8b 83 18 01 00 00    	mov    0x118(%ebx),%eax
 8049677:	85 c0                	test   %eax,%eax
 8049679:	74 0a                	je     8049685 <malloc_init+0x30c>
                malloc_realloc = 1;
 804967b:	c7 83 04 01 00 00 01 	movl   $0x1,0x104(%ebx)
 8049682:	00 00 00 

        /* Allocate one page for the page directory */
        page_dir = (struct pginfo **) MMAP(malloc_pagesize);
 8049685:	8b 83 cc 00 00 00    	mov    0xcc(%ebx),%eax
 804968b:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 8049692:	00 
 8049693:	89 44 24 10          	mov    %eax,0x10(%esp)
 8049697:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
 804969e:	00 
 804969f:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 80496a6:	00 
 80496a7:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 80496ae:	00 
 80496af:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80496b6:	e8 05 ef ff ff       	call   80485c0 <mmap>
 80496bb:	89 83 e0 00 00 00    	mov    %eax,0xe0(%ebx)

        if (page_dir == (struct pginfo **) - 1)
 80496c1:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 80496c7:	83 f8 ff             	cmp    $0xffffffff,%eax
 80496ca:	75 0e                	jne    80496da <malloc_init+0x361>
                wrterror("mmap(2) failed, check limits\n");
 80496cc:	8d 83 f4 d8 ff ff    	lea    -0x270c(%ebx),%eax
 80496d2:	89 04 24             	mov    %eax,(%esp)
 80496d5:	e8 82 f9 ff ff       	call   804905c <wrterror>

        /*
         * We need a maximum of malloc_pageshift buckets, steal these from the
         * front of the page_directory;
         */
        malloc_origo = ((u_long)pageround((u_long)sbrk(0))) >> malloc_pageshift;
 80496da:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80496e1:	e8 66 ea ff ff       	call   804814c <sbrk>
 80496e6:	05 ff 0f 00 00       	add    $0xfff,%eax
 80496eb:	c1 e8 0c             	shr    $0xc,%eax
 80496ee:	89 83 d8 00 00 00    	mov    %eax,0xd8(%ebx)
        malloc_origo -= malloc_pageshift;
 80496f4:	8b 83 d8 00 00 00    	mov    0xd8(%ebx),%eax
 80496fa:	83 e8 0c             	sub    $0xc,%eax
 80496fd:	89 83 d8 00 00 00    	mov    %eax,0xd8(%ebx)

        malloc_ninfo = malloc_pagesize / sizeof * page_dir;
 8049703:	c7 83 e4 00 00 00 00 	movl   $0x400,0xe4(%ebx)
 804970a:	04 00 00 

        /* Recalculate the cache size in bytes, and make sure it's nonzero */

        if (!malloc_cache)
 804970d:	8b 83 0c 00 00 00    	mov    0xc(%ebx),%eax
 8049713:	85 c0                	test   %eax,%eax
 8049715:	75 0f                	jne    8049726 <malloc_init+0x3ad>
                malloc_cache++;
 8049717:	8b 83 0c 00 00 00    	mov    0xc(%ebx),%eax
 804971d:	83 c0 01             	add    $0x1,%eax
 8049720:	89 83 0c 00 00 00    	mov    %eax,0xc(%ebx)

        malloc_cache <<= malloc_pageshift;
 8049726:	8b 83 0c 00 00 00    	mov    0xc(%ebx),%eax
 804972c:	c1 e0 0c             	shl    $0xc,%eax
 804972f:	89 83 0c 00 00 00    	mov    %eax,0xc(%ebx)

        /*
         * This is a nice hack from Kaleb Keithly (kaleb@x.org).
         * We can sbrk(2) further back when we keep this on a low address.
         */
        px = (struct pgfree *) imalloc(sizeof * px);
 8049735:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 804973c:	e8 b9 07 00 00       	call   8049efa <imalloc>
 8049741:	89 83 20 01 00 00    	mov    %eax,0x120(%ebx)

        /* Been here, done that */
        malloc_started++;
 8049747:	8b 83 d0 00 00 00    	mov    0xd0(%ebx),%eax
 804974d:	83 c0 01             	add    $0x1,%eax
 8049750:	89 83 d0 00 00 00    	mov    %eax,0xd0(%ebx)
}
 8049756:	83 c4 34             	add    $0x34,%esp
 8049759:	5b                   	pop    %ebx
 804975a:	5d                   	pop    %ebp
 804975b:	c3                   	ret    

0804975c <malloc_pages>:
/*
 * Allocate a number of complete pages
 */
static void *
malloc_pages(size_t size)
{
 804975c:	55                   	push   %ebp
 804975d:	89 e5                	mov    %esp,%ebp
 804975f:	53                   	push   %ebx
 8049760:	83 ec 34             	sub    $0x34,%esp
 8049763:	e8 ef f8 ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 8049768:	81 c3 b0 4d 00 00    	add    $0x4db0,%ebx
        void *p, *delay_free = 0;
 804976e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
        unsigned int i;
        struct pgfree *pf;
        u_long index;

        size = pageround(size);
 8049775:	8b 45 08             	mov    0x8(%ebp),%eax
 8049778:	05 ff 0f 00 00       	add    $0xfff,%eax
 804977d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 8049782:	89 45 08             	mov    %eax,0x8(%ebp)

        p = 0;
 8049785:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804978c:	8b 83 e8 00 00 00    	mov    0xe8(%ebx),%eax
 8049792:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8049795:	e9 82 00 00 00       	jmp    804981c <malloc_pages+0xc0>
                        wrterror("(ES): non-free first page on free-list\n");
                if (page_dir[ptr2index(pf->end) - 1] != MALLOC_FREE)
                        wrterror("(ES): non-free last page on free-list\n");
#endif /* EXTRA_SANITY */

                if (pf->size < size)
 804979a:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804979d:	8b 40 10             	mov    0x10(%eax),%eax
 80497a0:	3b 45 08             	cmp    0x8(%ebp),%eax
 80497a3:	73 0a                	jae    80497af <malloc_pages+0x53>
        size = pageround(size);

        p = 0;

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 80497a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80497a8:	8b 00                	mov    (%eax),%eax
 80497aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
 80497ad:	eb 6d                	jmp    804981c <malloc_pages+0xc0>
#endif /* EXTRA_SANITY */

                if (pf->size < size)
                        continue;

                if (pf->size == size) {
 80497af:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80497b2:	8b 40 10             	mov    0x10(%eax),%eax
 80497b5:	3b 45 08             	cmp    0x8(%ebp),%eax
 80497b8:	75 35                	jne    80497ef <malloc_pages+0x93>
                        p = pf->page;
 80497ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80497bd:	8b 40 08             	mov    0x8(%eax),%eax
 80497c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        if (pf->next)
 80497c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80497c6:	8b 00                	mov    (%eax),%eax
 80497c8:	85 c0                	test   %eax,%eax
 80497ca:	74 0e                	je     80497da <malloc_pages+0x7e>
                                pf->next->prev = pf->prev;
 80497cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80497cf:	8b 00                	mov    (%eax),%eax
 80497d1:	8b 55 e8             	mov    -0x18(%ebp),%edx
 80497d4:	8b 52 04             	mov    0x4(%edx),%edx
 80497d7:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev->next = pf->next;
 80497da:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80497dd:	8b 40 04             	mov    0x4(%eax),%eax
 80497e0:	8b 55 e8             	mov    -0x18(%ebp),%edx
 80497e3:	8b 12                	mov    (%edx),%edx
 80497e5:	89 10                	mov    %edx,(%eax)
                        delay_free = pf;
 80497e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80497ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        break;
 80497ed:	eb 37                	jmp    8049826 <malloc_pages+0xca>
                }

                p = pf->page;
 80497ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80497f2:	8b 40 08             	mov    0x8(%eax),%eax
 80497f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                pf->page = (char *)pf->page + size;
 80497f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80497fb:	8b 40 08             	mov    0x8(%eax),%eax
 80497fe:	89 c2                	mov    %eax,%edx
 8049800:	03 55 08             	add    0x8(%ebp),%edx
 8049803:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049806:	89 50 08             	mov    %edx,0x8(%eax)
                pf->size -= size;
 8049809:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804980c:	8b 40 10             	mov    0x10(%eax),%eax
 804980f:	89 c2                	mov    %eax,%edx
 8049811:	2b 55 08             	sub    0x8(%ebp),%edx
 8049814:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049817:	89 50 10             	mov    %edx,0x10(%eax)
                break;
 804981a:	eb 0a                	jmp    8049826 <malloc_pages+0xca>
        size = pageround(size);

        p = 0;

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804981c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 8049820:	0f 85 74 ff ff ff    	jne    804979a <malloc_pages+0x3e>
#ifdef EXTRA_SANITY
        if (p && page_dir[ptr2index(p)] != MALLOC_FREE)
                wrterror("(ES): allocated non-free page on free-list\n");
#endif /* EXTRA_SANITY */

        size >>= malloc_pageshift;
 8049826:	c1 6d 08 0c          	shrl   $0xc,0x8(%ebp)

        /* Map new pages */
        if (!p)
 804982a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804982e:	75 0e                	jne    804983e <malloc_pages+0xe2>
                p = map_pages(size);
 8049830:	8b 45 08             	mov    0x8(%ebp),%eax
 8049833:	89 04 24             	mov    %eax,(%esp)
 8049836:	e8 b6 f9 ff ff       	call   80491f1 <map_pages>
 804983b:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (p) {
 804983e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8049842:	0f 84 80 00 00 00    	je     80498c8 <malloc_pages+0x16c>

                index = ptr2index(p);
 8049848:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804984b:	89 c2                	mov    %eax,%edx
 804984d:	c1 ea 0c             	shr    $0xc,%edx
 8049850:	8b 83 d8 00 00 00    	mov    0xd8(%ebx),%eax
 8049856:	89 d1                	mov    %edx,%ecx
 8049858:	29 c1                	sub    %eax,%ecx
 804985a:	89 c8                	mov    %ecx,%eax
 804985c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                page_dir[index] = MALLOC_FIRST;
 804985f:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 8049865:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8049868:	c1 e2 02             	shl    $0x2,%edx
 804986b:	01 d0                	add    %edx,%eax
 804986d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
                for (i = 1; i < size; i++)
 8049873:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
 804987a:	eb 1d                	jmp    8049899 <malloc_pages+0x13d>
                        page_dir[index + i] = MALLOC_FOLLOW;
 804987c:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 8049882:	8b 55 ec             	mov    -0x14(%ebp),%edx
 8049885:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 8049888:	01 ca                	add    %ecx,%edx
 804988a:	c1 e2 02             	shl    $0x2,%edx
 804988d:	01 d0                	add    %edx,%eax
 804988f:	c7 00 03 00 00 00    	movl   $0x3,(%eax)

        if (p) {

                index = ptr2index(p);
                page_dir[index] = MALLOC_FIRST;
                for (i = 1; i < size; i++)
 8049895:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
 8049899:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804989c:	3b 45 08             	cmp    0x8(%ebp),%eax
 804989f:	72 db                	jb     804987c <malloc_pages+0x120>
                        page_dir[index + i] = MALLOC_FOLLOW;

                if (malloc_junk)
 80498a1:	8b 83 18 01 00 00    	mov    0x118(%ebx),%eax
 80498a7:	85 c0                	test   %eax,%eax
 80498a9:	74 1d                	je     80498c8 <malloc_pages+0x16c>
                        memset(p, SOME_JUNK, size << malloc_pageshift);
 80498ab:	8b 45 08             	mov    0x8(%ebp),%eax
 80498ae:	c1 e0 0c             	shl    $0xc,%eax
 80498b1:	89 44 24 08          	mov    %eax,0x8(%esp)
 80498b5:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 80498bc:	00 
 80498bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80498c0:	89 04 24             	mov    %eax,(%esp)
 80498c3:	e8 ac 1a 00 00       	call   804b374 <memset>
        }

        if (delay_free) {
 80498c8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 80498cc:	74 20                	je     80498ee <malloc_pages+0x192>
                if (!px)
 80498ce:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 80498d4:	85 c0                	test   %eax,%eax
 80498d6:	75 0b                	jne    80498e3 <malloc_pages+0x187>
                        px = delay_free;
 80498d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80498db:	89 83 20 01 00 00    	mov    %eax,0x120(%ebx)
 80498e1:	eb 0b                	jmp    80498ee <malloc_pages+0x192>
                else
                        ifree(delay_free);
 80498e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80498e6:	89 04 24             	mov    %eax,(%esp)
 80498e9:	e8 60 0f 00 00       	call   804a84e <ifree>
        }

        return p;
 80498ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 80498f1:	83 c4 34             	add    $0x34,%esp
 80498f4:	5b                   	pop    %ebx
 80498f5:	5d                   	pop    %ebp
 80498f6:	c3                   	ret    

080498f7 <malloc_make_chunks>:
 * Allocate a page of fragments
 */

static __inline__ int
malloc_make_chunks(int bits)
{
 80498f7:	55                   	push   %ebp
 80498f8:	89 e5                	mov    %esp,%ebp
 80498fa:	57                   	push   %edi
 80498fb:	56                   	push   %esi
 80498fc:	53                   	push   %ebx
 80498fd:	83 ec 4c             	sub    $0x4c,%esp
 8049900:	e8 52 f7 ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 8049905:	81 c3 13 4c 00 00    	add    $0x4c13,%ebx
        struct  pginfo *bp;
        void *pp;
        unsigned int i, k, l;

        /* Allocate a new bucket */
        pp = malloc_pages(malloc_pagesize);
 804990b:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
 8049912:	e8 45 fe ff ff       	call   804975c <malloc_pages>
 8049917:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if (!pp)
 804991a:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
 804991e:	75 0a                	jne    804992a <malloc_make_chunks+0x33>
                return 0;
 8049920:	b8 00 00 00 00       	mov    $0x0,%eax
 8049925:	e9 16 02 00 00       	jmp    8049b40 <malloc_make_chunks+0x249>

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
 804992a:	c7 45 dc 10 00 00 00 	movl   $0x10,-0x24(%ebp)
        l += sizeof bp->bits[0] *
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);
 8049931:	8b 45 08             	mov    0x8(%ebp),%eax
 8049934:	ba 00 10 00 00       	mov    $0x1000,%edx
 8049939:	89 d6                	mov    %edx,%esi
 804993b:	89 c1                	mov    %eax,%ecx
 804993d:	d3 ee                	shr    %cl,%esi
 804993f:	89 f0                	mov    %esi,%eax
 8049941:	83 c0 1f             	add    $0x1f,%eax
 8049944:	c1 e8 05             	shr    $0x5,%eax
        if (!pp)
                return 0;

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
        l += sizeof bp->bits[0] *
 8049947:	c1 e0 02             	shl    $0x2,%eax
 804994a:	01 45 dc             	add    %eax,-0x24(%ebp)
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);

        /* Don't waste more than two chunks on this */
        if ((1U << (bits)) <= l + l) {
 804994d:	8b 45 08             	mov    0x8(%ebp),%eax
 8049950:	ba 01 00 00 00       	mov    $0x1,%edx
 8049955:	89 c1                	mov    %eax,%ecx
 8049957:	d3 e2                	shl    %cl,%edx
 8049959:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804995c:	01 c0                	add    %eax,%eax
 804995e:	39 c2                	cmp    %eax,%edx
 8049960:	77 08                	ja     804996a <malloc_make_chunks+0x73>
                bp = (struct  pginfo *)pp;
 8049962:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049965:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8049968:	eb 29                	jmp    8049993 <malloc_make_chunks+0x9c>
        } else {
                bp = (struct  pginfo *)imalloc(l);
 804996a:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804996d:	89 04 24             	mov    %eax,(%esp)
 8049970:	e8 85 05 00 00       	call   8049efa <imalloc>
 8049975:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (!bp) {
 8049978:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804997c:	75 15                	jne    8049993 <malloc_make_chunks+0x9c>
                        ifree(pp);
 804997e:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049981:	89 04 24             	mov    %eax,(%esp)
 8049984:	e8 c5 0e 00 00       	call   804a84e <ifree>
                        return 0;
 8049989:	b8 00 00 00 00       	mov    $0x0,%eax
 804998e:	e9 ad 01 00 00       	jmp    8049b40 <malloc_make_chunks+0x249>
                }
        }

        bp->size = (1 << bits);
 8049993:	8b 45 08             	mov    0x8(%ebp),%eax
 8049996:	ba 01 00 00 00       	mov    $0x1,%edx
 804999b:	89 d6                	mov    %edx,%esi
 804999d:	89 c1                	mov    %eax,%ecx
 804999f:	d3 e6                	shl    %cl,%esi
 80499a1:	89 f0                	mov    %esi,%eax
 80499a3:	89 c2                	mov    %eax,%edx
 80499a5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80499a8:	66 89 50 08          	mov    %dx,0x8(%eax)
        bp->shift = bits;
 80499ac:	8b 45 08             	mov    0x8(%ebp),%eax
 80499af:	89 c2                	mov    %eax,%edx
 80499b1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80499b4:	66 89 50 0a          	mov    %dx,0xa(%eax)
        bp->total = bp->free = malloc_pagesize >> bits;
 80499b8:	8b 45 08             	mov    0x8(%ebp),%eax
 80499bb:	ba 00 10 00 00       	mov    $0x1000,%edx
 80499c0:	89 d6                	mov    %edx,%esi
 80499c2:	89 c1                	mov    %eax,%ecx
 80499c4:	d3 ee                	shr    %cl,%esi
 80499c6:	89 f0                	mov    %esi,%eax
 80499c8:	89 c2                	mov    %eax,%edx
 80499ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80499cd:	66 89 50 0c          	mov    %dx,0xc(%eax)
 80499d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80499d4:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 80499d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80499db:	66 89 50 0e          	mov    %dx,0xe(%eax)
        bp->page = pp;
 80499df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80499e2:	8b 55 d8             	mov    -0x28(%ebp),%edx
 80499e5:	89 50 04             	mov    %edx,0x4(%eax)

        /* set all valid bits in the bitmap */
        k = bp->total;
 80499e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80499eb:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 80499ef:	0f b7 c0             	movzwl %ax,%eax
 80499f2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        i = 0;
 80499f5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 80499fc:	eb 19                	jmp    8049a17 <malloc_make_chunks+0x120>
                bp->bits[i / MALLOC_BITS] = ~0;
 80499fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049a01:	89 c2                	mov    %eax,%edx
 8049a03:	c1 ea 05             	shr    $0x5,%edx
 8049a06:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049a09:	83 c2 04             	add    $0x4,%edx
 8049a0c:	c7 04 90 ff ff ff ff 	movl   $0xffffffff,(%eax,%edx,4)
        /* set all valid bits in the bitmap */
        k = bp->total;
        i = 0;

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 8049a13:	83 45 e0 20          	addl   $0x20,-0x20(%ebp)
 8049a17:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049a1a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 8049a1d:	89 d7                	mov    %edx,%edi
 8049a1f:	29 c7                	sub    %eax,%edi
 8049a21:	89 f8                	mov    %edi,%eax
 8049a23:	83 f8 1f             	cmp    $0x1f,%eax
 8049a26:	77 d6                	ja     80499fe <malloc_make_chunks+0x107>
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 8049a28:	eb 36                	jmp    8049a60 <malloc_make_chunks+0x169>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 8049a2a:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049a2d:	c1 e8 05             	shr    $0x5,%eax
 8049a30:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8049a33:	8d 48 04             	lea    0x4(%eax),%ecx
 8049a36:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 8049a39:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8049a3c:	83 e2 1f             	and    $0x1f,%edx
 8049a3f:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
 8049a46:	8b 7d c4             	mov    -0x3c(%ebp),%edi
 8049a49:	89 d1                	mov    %edx,%ecx
 8049a4b:	d3 e7                	shl    %cl,%edi
 8049a4d:	89 fa                	mov    %edi,%edx
 8049a4f:	89 f1                	mov    %esi,%ecx
 8049a51:	09 d1                	or     %edx,%ecx
 8049a53:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8049a56:	83 c0 04             	add    $0x4,%eax
 8049a59:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 8049a5c:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
 8049a60:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049a63:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
 8049a66:	72 c2                	jb     8049a2a <malloc_make_chunks+0x133>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
 8049a68:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049a6b:	8b 40 04             	mov    0x4(%eax),%eax
 8049a6e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 8049a71:	75 7c                	jne    8049aef <malloc_make_chunks+0x1f8>
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 8049a73:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
 8049a7a:	eb 6d                	jmp    8049ae9 <malloc_make_chunks+0x1f2>
                        bp->bits[i / MALLOC_BITS] &= ~(1 << (i % MALLOC_BITS));
 8049a7c:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049a7f:	c1 e8 05             	shr    $0x5,%eax
 8049a82:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8049a85:	8d 48 04             	lea    0x4(%eax),%ecx
 8049a88:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 8049a8b:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8049a8e:	83 e2 1f             	and    $0x1f,%edx
 8049a91:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
 8049a98:	8b 7d c4             	mov    -0x3c(%ebp),%edi
 8049a9b:	89 d1                	mov    %edx,%ecx
 8049a9d:	d3 e7                	shl    %cl,%edi
 8049a9f:	89 fa                	mov    %edi,%edx
 8049aa1:	f7 d2                	not    %edx
 8049aa3:	89 f1                	mov    %esi,%ecx
 8049aa5:	21 d1                	and    %edx,%ecx
 8049aa7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8049aaa:	83 c0 04             	add    $0x4,%eax
 8049aad:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
                        bp->free--;
 8049ab0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049ab3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 8049ab7:	8d 50 ff             	lea    -0x1(%eax),%edx
 8049aba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049abd:	66 89 50 0c          	mov    %dx,0xc(%eax)
                        bp->total--;
 8049ac1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049ac4:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 8049ac8:	8d 50 ff             	lea    -0x1(%eax),%edx
 8049acb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049ace:	66 89 50 0e          	mov    %dx,0xe(%eax)
                        l -= (1 << bits);
 8049ad2:	8b 45 08             	mov    0x8(%ebp),%eax
 8049ad5:	ba 01 00 00 00       	mov    $0x1,%edx
 8049ada:	89 d6                	mov    %edx,%esi
 8049adc:	89 c1                	mov    %eax,%ecx
 8049ade:	d3 e6                	shl    %cl,%esi
 8049ae0:	89 f0                	mov    %esi,%eax
 8049ae2:	29 45 dc             	sub    %eax,-0x24(%ebp)
        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 8049ae5:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
 8049ae9:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 8049aed:	75 8d                	jne    8049a7c <malloc_make_chunks+0x185>
                }
        }

        /* MALLOC_LOCK */

        page_dir[ptr2index(pp)] = bp;
 8049aef:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 8049af5:	8b 55 d8             	mov    -0x28(%ebp),%edx
 8049af8:	89 d1                	mov    %edx,%ecx
 8049afa:	c1 e9 0c             	shr    $0xc,%ecx
 8049afd:	8b 93 d8 00 00 00    	mov    0xd8(%ebx),%edx
 8049b03:	89 cf                	mov    %ecx,%edi
 8049b05:	29 d7                	sub    %edx,%edi
 8049b07:	89 fa                	mov    %edi,%edx
 8049b09:	c1 e2 02             	shl    $0x2,%edx
 8049b0c:	01 c2                	add    %eax,%edx
 8049b0e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049b11:	89 02                	mov    %eax,(%edx)

        bp->next = page_dir[bits];
 8049b13:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 8049b19:	8b 55 08             	mov    0x8(%ebp),%edx
 8049b1c:	c1 e2 02             	shl    $0x2,%edx
 8049b1f:	01 d0                	add    %edx,%eax
 8049b21:	8b 10                	mov    (%eax),%edx
 8049b23:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049b26:	89 10                	mov    %edx,(%eax)
        page_dir[bits] = bp;
 8049b28:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 8049b2e:	8b 55 08             	mov    0x8(%ebp),%edx
 8049b31:	c1 e2 02             	shl    $0x2,%edx
 8049b34:	01 c2                	add    %eax,%edx
 8049b36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049b39:	89 02                	mov    %eax,(%edx)

        /* MALLOC_UNLOCK */

        return 1;
 8049b3b:	b8 01 00 00 00       	mov    $0x1,%eax
}
 8049b40:	83 c4 4c             	add    $0x4c,%esp
 8049b43:	5b                   	pop    %ebx
 8049b44:	5e                   	pop    %esi
 8049b45:	5f                   	pop    %edi
 8049b46:	5d                   	pop    %ebp
 8049b47:	c3                   	ret    

08049b48 <malloc_bytes>:
/*
 * Allocate a fragment
 */
static void *
malloc_bytes(size_t size)
{
 8049b48:	55                   	push   %ebp
 8049b49:	89 e5                	mov    %esp,%ebp
 8049b4b:	57                   	push   %edi
 8049b4c:	56                   	push   %esi
 8049b4d:	53                   	push   %ebx
 8049b4e:	83 ec 5c             	sub    $0x5c,%esp
 8049b51:	e8 01 f5 ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 8049b56:	81 c3 c2 49 00 00    	add    $0x49c2,%ebx
        struct  pginfo *bp;
        int k;
        u_int *lp;

        /* Don't bother with anything less than this */
        if (size < malloc_minsize)
 8049b5c:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
 8049b60:	77 07                	ja     8049b69 <malloc_bytes+0x21>
                size = malloc_minsize;
 8049b62:	c7 45 08 10 00 00 00 	movl   $0x10,0x8(%ebp)

        /* Find the right bucket */
        j = 1;
 8049b69:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        i = size - 1;
 8049b70:	8b 45 08             	mov    0x8(%ebp),%eax
 8049b73:	83 e8 01             	sub    $0x1,%eax
 8049b76:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        while (i >>= 1)
 8049b79:	eb 04                	jmp    8049b7f <malloc_bytes+0x37>
                j++;
 8049b7b:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
                size = malloc_minsize;

        /* Find the right bucket */
        j = 1;
        i = size - 1;
        while (i >>= 1)
 8049b7f:	d1 7d e4             	sarl   -0x1c(%ebp)
 8049b82:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 8049b86:	75 f3                	jne    8049b7b <malloc_bytes+0x33>
                j++;

        /* If it's empty, make a page more of that size chunks */
        if (!page_dir[j] && !malloc_make_chunks(j))
 8049b88:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 8049b8e:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8049b91:	c1 e2 02             	shl    $0x2,%edx
 8049b94:	01 d0                	add    %edx,%eax
 8049b96:	8b 00                	mov    (%eax),%eax
 8049b98:	85 c0                	test   %eax,%eax
 8049b9a:	0f 85 49 02 00 00    	jne    8049de9 <malloc_bytes+0x2a1>
 8049ba0:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049ba3:	89 45 cc             	mov    %eax,-0x34(%ebp)
        struct  pginfo *bp;
        void *pp;
        unsigned int i, k, l;

        /* Allocate a new bucket */
        pp = malloc_pages(malloc_pagesize);
 8049ba6:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
 8049bad:	e8 aa fb ff ff       	call   804975c <malloc_pages>
 8049bb2:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if (!pp)
 8049bb5:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 8049bb9:	75 0a                	jne    8049bc5 <malloc_bytes+0x7d>
                return 0;
 8049bbb:	b8 00 00 00 00       	mov    $0x0,%eax
 8049bc0:	e9 16 02 00 00       	jmp    8049ddb <malloc_bytes+0x293>

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
 8049bc5:	c7 45 c4 10 00 00 00 	movl   $0x10,-0x3c(%ebp)
        l += sizeof bp->bits[0] *
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);
 8049bcc:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8049bcf:	ba 00 10 00 00       	mov    $0x1000,%edx
 8049bd4:	89 d6                	mov    %edx,%esi
 8049bd6:	89 c1                	mov    %eax,%ecx
 8049bd8:	d3 ee                	shr    %cl,%esi
 8049bda:	89 f0                	mov    %esi,%eax
 8049bdc:	83 c0 1f             	add    $0x1f,%eax
 8049bdf:	c1 e8 05             	shr    $0x5,%eax
        if (!pp)
                return 0;

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
        l += sizeof bp->bits[0] *
 8049be2:	c1 e0 02             	shl    $0x2,%eax
 8049be5:	01 45 c4             	add    %eax,-0x3c(%ebp)
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);

        /* Don't waste more than two chunks on this */
        if ((1U << (bits)) <= l + l) {
 8049be8:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8049beb:	ba 01 00 00 00       	mov    $0x1,%edx
 8049bf0:	89 c1                	mov    %eax,%ecx
 8049bf2:	d3 e2                	shl    %cl,%edx
 8049bf4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8049bf7:	01 c0                	add    %eax,%eax
 8049bf9:	39 c2                	cmp    %eax,%edx
 8049bfb:	77 08                	ja     8049c05 <malloc_bytes+0xbd>
                bp = (struct  pginfo *)pp;
 8049bfd:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8049c00:	89 45 c0             	mov    %eax,-0x40(%ebp)
 8049c03:	eb 29                	jmp    8049c2e <malloc_bytes+0xe6>
        } else {
                bp = (struct  pginfo *)imalloc(l);
 8049c05:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8049c08:	89 04 24             	mov    %eax,(%esp)
 8049c0b:	e8 ea 02 00 00       	call   8049efa <imalloc>
 8049c10:	89 45 c0             	mov    %eax,-0x40(%ebp)
                if (!bp) {
 8049c13:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
 8049c17:	75 15                	jne    8049c2e <malloc_bytes+0xe6>
                        ifree(pp);
 8049c19:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8049c1c:	89 04 24             	mov    %eax,(%esp)
 8049c1f:	e8 2a 0c 00 00       	call   804a84e <ifree>
                        return 0;
 8049c24:	b8 00 00 00 00       	mov    $0x0,%eax
 8049c29:	e9 ad 01 00 00       	jmp    8049ddb <malloc_bytes+0x293>
                }
        }

        bp->size = (1 << bits);
 8049c2e:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8049c31:	ba 01 00 00 00       	mov    $0x1,%edx
 8049c36:	89 d6                	mov    %edx,%esi
 8049c38:	89 c1                	mov    %eax,%ecx
 8049c3a:	d3 e6                	shl    %cl,%esi
 8049c3c:	89 f0                	mov    %esi,%eax
 8049c3e:	89 c2                	mov    %eax,%edx
 8049c40:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049c43:	66 89 50 08          	mov    %dx,0x8(%eax)
        bp->shift = bits;
 8049c47:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8049c4a:	89 c2                	mov    %eax,%edx
 8049c4c:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049c4f:	66 89 50 0a          	mov    %dx,0xa(%eax)
        bp->total = bp->free = malloc_pagesize >> bits;
 8049c53:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8049c56:	ba 00 10 00 00       	mov    $0x1000,%edx
 8049c5b:	89 d6                	mov    %edx,%esi
 8049c5d:	89 c1                	mov    %eax,%ecx
 8049c5f:	d3 ee                	shr    %cl,%esi
 8049c61:	89 f0                	mov    %esi,%eax
 8049c63:	89 c2                	mov    %eax,%edx
 8049c65:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049c68:	66 89 50 0c          	mov    %dx,0xc(%eax)
 8049c6c:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049c6f:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 8049c73:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049c76:	66 89 50 0e          	mov    %dx,0xe(%eax)
        bp->page = pp;
 8049c7a:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049c7d:	8b 55 c8             	mov    -0x38(%ebp),%edx
 8049c80:	89 50 04             	mov    %edx,0x4(%eax)

        /* set all valid bits in the bitmap */
        k = bp->total;
 8049c83:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049c86:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 8049c8a:	0f b7 c0             	movzwl %ax,%eax
 8049c8d:	89 45 bc             	mov    %eax,-0x44(%ebp)
        i = 0;
 8049c90:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 8049c97:	eb 19                	jmp    8049cb2 <malloc_bytes+0x16a>

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;
 8049c99:	8b 45 b8             	mov    -0x48(%ebp),%eax
 8049c9c:	89 c2                	mov    %eax,%edx
 8049c9e:	c1 ea 05             	shr    $0x5,%edx
 8049ca1:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049ca4:	83 c2 04             	add    $0x4,%edx
 8049ca7:	c7 04 90 ff ff ff ff 	movl   $0xffffffff,(%eax,%edx,4)
        /* set all valid bits in the bitmap */
        k = bp->total;
        i = 0;

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 8049cae:	83 45 b8 20          	addl   $0x20,-0x48(%ebp)
 8049cb2:	8b 45 b8             	mov    -0x48(%ebp),%eax
 8049cb5:	8b 55 bc             	mov    -0x44(%ebp),%edx
 8049cb8:	89 d7                	mov    %edx,%edi
 8049cba:	29 c7                	sub    %eax,%edi
 8049cbc:	89 f8                	mov    %edi,%eax
 8049cbe:	83 f8 1f             	cmp    $0x1f,%eax
 8049cc1:	77 d6                	ja     8049c99 <malloc_bytes+0x151>
 8049cc3:	eb 36                	jmp    8049cfb <malloc_bytes+0x1b3>
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 8049cc5:	8b 45 b8             	mov    -0x48(%ebp),%eax
 8049cc8:	c1 e8 05             	shr    $0x5,%eax
 8049ccb:	8b 55 c0             	mov    -0x40(%ebp),%edx
 8049cce:	8d 48 04             	lea    0x4(%eax),%ecx
 8049cd1:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 8049cd4:	8b 55 b8             	mov    -0x48(%ebp),%edx
 8049cd7:	83 e2 1f             	and    $0x1f,%edx
 8049cda:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
 8049ce1:	8b 7d b4             	mov    -0x4c(%ebp),%edi
 8049ce4:	89 d1                	mov    %edx,%ecx
 8049ce6:	d3 e7                	shl    %cl,%edi
 8049ce8:	89 fa                	mov    %edi,%edx
 8049cea:	89 f1                	mov    %esi,%ecx
 8049cec:	09 d1                	or     %edx,%ecx
 8049cee:	8b 55 c0             	mov    -0x40(%ebp),%edx
 8049cf1:	83 c0 04             	add    $0x4,%eax
 8049cf4:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 8049cf7:	83 45 b8 01          	addl   $0x1,-0x48(%ebp)
 8049cfb:	8b 45 bc             	mov    -0x44(%ebp),%eax
 8049cfe:	3b 45 b8             	cmp    -0x48(%ebp),%eax
 8049d01:	77 c2                	ja     8049cc5 <malloc_bytes+0x17d>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
 8049d03:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049d06:	8b 40 04             	mov    0x4(%eax),%eax
 8049d09:	39 45 c0             	cmp    %eax,-0x40(%ebp)
 8049d0c:	75 7c                	jne    8049d8a <malloc_bytes+0x242>
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 8049d0e:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 8049d15:	eb 6d                	jmp    8049d84 <malloc_bytes+0x23c>
                        bp->bits[i / MALLOC_BITS] &= ~(1 << (i % MALLOC_BITS));
 8049d17:	8b 45 b8             	mov    -0x48(%ebp),%eax
 8049d1a:	c1 e8 05             	shr    $0x5,%eax
 8049d1d:	8b 55 c0             	mov    -0x40(%ebp),%edx
 8049d20:	8d 48 04             	lea    0x4(%eax),%ecx
 8049d23:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 8049d26:	8b 55 b8             	mov    -0x48(%ebp),%edx
 8049d29:	83 e2 1f             	and    $0x1f,%edx
 8049d2c:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
 8049d33:	8b 7d b4             	mov    -0x4c(%ebp),%edi
 8049d36:	89 d1                	mov    %edx,%ecx
 8049d38:	d3 e7                	shl    %cl,%edi
 8049d3a:	89 fa                	mov    %edi,%edx
 8049d3c:	f7 d2                	not    %edx
 8049d3e:	89 f1                	mov    %esi,%ecx
 8049d40:	21 d1                	and    %edx,%ecx
 8049d42:	8b 55 c0             	mov    -0x40(%ebp),%edx
 8049d45:	83 c0 04             	add    $0x4,%eax
 8049d48:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
                        bp->free--;
 8049d4b:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049d4e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 8049d52:	8d 50 ff             	lea    -0x1(%eax),%edx
 8049d55:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049d58:	66 89 50 0c          	mov    %dx,0xc(%eax)
                        bp->total--;
 8049d5c:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049d5f:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 8049d63:	8d 50 ff             	lea    -0x1(%eax),%edx
 8049d66:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049d69:	66 89 50 0e          	mov    %dx,0xe(%eax)
                        l -= (1 << bits);
 8049d6d:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8049d70:	ba 01 00 00 00       	mov    $0x1,%edx
 8049d75:	89 d6                	mov    %edx,%esi
 8049d77:	89 c1                	mov    %eax,%ecx
 8049d79:	d3 e6                	shl    %cl,%esi
 8049d7b:	89 f0                	mov    %esi,%eax
 8049d7d:	29 45 c4             	sub    %eax,-0x3c(%ebp)
        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 8049d80:	83 45 b8 01          	addl   $0x1,-0x48(%ebp)
 8049d84:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
 8049d88:	75 8d                	jne    8049d17 <malloc_bytes+0x1cf>
                }
        }

        /* MALLOC_LOCK */

        page_dir[ptr2index(pp)] = bp;
 8049d8a:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 8049d90:	8b 55 c8             	mov    -0x38(%ebp),%edx
 8049d93:	89 d1                	mov    %edx,%ecx
 8049d95:	c1 e9 0c             	shr    $0xc,%ecx
 8049d98:	8b 93 d8 00 00 00    	mov    0xd8(%ebx),%edx
 8049d9e:	89 cf                	mov    %ecx,%edi
 8049da0:	29 d7                	sub    %edx,%edi
 8049da2:	89 fa                	mov    %edi,%edx
 8049da4:	c1 e2 02             	shl    $0x2,%edx
 8049da7:	01 c2                	add    %eax,%edx
 8049da9:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049dac:	89 02                	mov    %eax,(%edx)

        bp->next = page_dir[bits];
 8049dae:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 8049db4:	8b 55 cc             	mov    -0x34(%ebp),%edx
 8049db7:	c1 e2 02             	shl    $0x2,%edx
 8049dba:	01 d0                	add    %edx,%eax
 8049dbc:	8b 10                	mov    (%eax),%edx
 8049dbe:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049dc1:	89 10                	mov    %edx,(%eax)
        page_dir[bits] = bp;
 8049dc3:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 8049dc9:	8b 55 cc             	mov    -0x34(%ebp),%edx
 8049dcc:	c1 e2 02             	shl    $0x2,%edx
 8049dcf:	01 c2                	add    %eax,%edx
 8049dd1:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049dd4:	89 02                	mov    %eax,(%edx)

        /* MALLOC_UNLOCK */

        return 1;
 8049dd6:	b8 01 00 00 00       	mov    $0x1,%eax
        i = size - 1;
        while (i >>= 1)
                j++;

        /* If it's empty, make a page more of that size chunks */
        if (!page_dir[j] && !malloc_make_chunks(j))
 8049ddb:	85 c0                	test   %eax,%eax
 8049ddd:	75 0a                	jne    8049de9 <malloc_bytes+0x2a1>
                return 0;
 8049ddf:	b8 00 00 00 00       	mov    $0x0,%eax
 8049de4:	e9 09 01 00 00       	jmp    8049ef2 <malloc_bytes+0x3aa>

        bp = page_dir[j];
 8049de9:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 8049def:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8049df2:	c1 e2 02             	shl    $0x2,%edx
 8049df5:	01 d0                	add    %edx,%eax
 8049df7:	8b 00                	mov    (%eax),%eax
 8049df9:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /* Find first word of bitmap which isn't empty */
        for (lp = bp->bits; !*lp; lp++)
 8049dfc:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8049dff:	83 c0 10             	add    $0x10,%eax
 8049e02:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8049e05:	eb 04                	jmp    8049e0b <malloc_bytes+0x2c3>
 8049e07:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
 8049e0b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049e0e:	8b 00                	mov    (%eax),%eax
 8049e10:	85 c0                	test   %eax,%eax
 8049e12:	74 f3                	je     8049e07 <malloc_bytes+0x2bf>
                ;

        /* Find that bit, and tweak it */
        u = 1;
 8049e14:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        k = 0;
 8049e1b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
        while (!(*lp & u)) {
 8049e22:	eb 0c                	jmp    8049e30 <malloc_bytes+0x2e8>
                u += u;
 8049e24:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8049e27:	01 c0                	add    %eax,%eax
 8049e29:	89 45 dc             	mov    %eax,-0x24(%ebp)
                k++;
 8049e2c:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
                ;

        /* Find that bit, and tweak it */
        u = 1;
        k = 0;
        while (!(*lp & u)) {
 8049e30:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049e33:	8b 00                	mov    (%eax),%eax
 8049e35:	23 45 dc             	and    -0x24(%ebp),%eax
 8049e38:	85 c0                	test   %eax,%eax
 8049e3a:	74 e8                	je     8049e24 <malloc_bytes+0x2dc>
                u += u;
                k++;
        }
        *lp ^= u;
 8049e3c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049e3f:	8b 00                	mov    (%eax),%eax
 8049e41:	89 c2                	mov    %eax,%edx
 8049e43:	33 55 dc             	xor    -0x24(%ebp),%edx
 8049e46:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049e49:	89 10                	mov    %edx,(%eax)

        /* If there are no more free, remove from free-list */
        if (!--bp->free) {
 8049e4b:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8049e4e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 8049e52:	8d 50 ff             	lea    -0x1(%eax),%edx
 8049e55:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8049e58:	66 89 50 0c          	mov    %dx,0xc(%eax)
 8049e5c:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8049e5f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 8049e63:	66 85 c0             	test   %ax,%ax
 8049e66:	75 1e                	jne    8049e86 <malloc_bytes+0x33e>
                page_dir[j] = bp->next;
 8049e68:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 8049e6e:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8049e71:	c1 e2 02             	shl    $0x2,%edx
 8049e74:	01 c2                	add    %eax,%edx
 8049e76:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8049e79:	8b 00                	mov    (%eax),%eax
 8049e7b:	89 02                	mov    %eax,(%edx)
                bp->next = 0;
 8049e7d:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8049e80:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        }

        /* Adjust to the real offset of that chunk */
        k += (lp - bp->bits) * MALLOC_BITS;
 8049e86:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 8049e89:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8049e8c:	83 c0 10             	add    $0x10,%eax
 8049e8f:	89 d1                	mov    %edx,%ecx
 8049e91:	29 c1                	sub    %eax,%ecx
 8049e93:	89 c8                	mov    %ecx,%eax
 8049e95:	c1 f8 02             	sar    $0x2,%eax
 8049e98:	89 c2                	mov    %eax,%edx
 8049e9a:	c1 e2 05             	shl    $0x5,%edx
 8049e9d:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049ea0:	01 d0                	add    %edx,%eax
 8049ea2:	89 45 d8             	mov    %eax,-0x28(%ebp)
        k <<= bp->shift;
 8049ea5:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8049ea8:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 8049eac:	0f b7 c0             	movzwl %ax,%eax
 8049eaf:	89 c1                	mov    %eax,%ecx
 8049eb1:	d3 65 d8             	shll   %cl,-0x28(%ebp)

        if (malloc_junk)
 8049eb4:	8b 83 18 01 00 00    	mov    0x118(%ebx),%eax
 8049eba:	85 c0                	test   %eax,%eax
 8049ebc:	74 29                	je     8049ee7 <malloc_bytes+0x39f>
                memset((u_char *)bp->page + k, SOME_JUNK, bp->size);
 8049ebe:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8049ec1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 8049ec5:	0f b7 c0             	movzwl %ax,%eax
 8049ec8:	8b 55 d0             	mov    -0x30(%ebp),%edx
 8049ecb:	8b 4a 04             	mov    0x4(%edx),%ecx
 8049ece:	8b 55 d8             	mov    -0x28(%ebp),%edx
 8049ed1:	01 ca                	add    %ecx,%edx
 8049ed3:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049ed7:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 8049ede:	00 
 8049edf:	89 14 24             	mov    %edx,(%esp)
 8049ee2:	e8 8d 14 00 00       	call   804b374 <memset>

        return (u_char *)bp->page + k;
 8049ee7:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8049eea:	8b 50 04             	mov    0x4(%eax),%edx
 8049eed:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049ef0:	01 d0                	add    %edx,%eax
}
 8049ef2:	83 c4 5c             	add    $0x5c,%esp
 8049ef5:	5b                   	pop    %ebx
 8049ef6:	5e                   	pop    %esi
 8049ef7:	5f                   	pop    %edi
 8049ef8:	5d                   	pop    %ebp
 8049ef9:	c3                   	ret    

08049efa <imalloc>:
/*
 * Allocate a piece of memory
 */
static void *
imalloc(size_t size)
{
 8049efa:	55                   	push   %ebp
 8049efb:	89 e5                	mov    %esp,%ebp
 8049efd:	53                   	push   %ebx
 8049efe:	83 ec 24             	sub    $0x24,%esp
 8049f01:	e8 51 f1 ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 8049f06:	81 c3 12 46 00 00    	add    $0x4612,%ebx
        void *result;

        if (suicide)
 8049f0c:	8b 83 00 01 00 00    	mov    0x100(%ebx),%eax
 8049f12:	85 c0                	test   %eax,%eax
 8049f14:	74 0c                	je     8049f22 <imalloc+0x28>
                abort();
 8049f16:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8049f1d:	e8 52 e4 ff ff       	call   8048374 <exit>

        if ((size + malloc_pagesize) < size)        /* Check for overflow */
 8049f22:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f25:	05 00 10 00 00       	add    $0x1000,%eax
 8049f2a:	3b 45 08             	cmp    0x8(%ebp),%eax
 8049f2d:	73 09                	jae    8049f38 <imalloc+0x3e>
                result = 0;
 8049f2f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8049f36:	eb 27                	jmp    8049f5f <imalloc+0x65>
        else if (size <= malloc_maxsize)
 8049f38:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
 8049f3f:	77 10                	ja     8049f51 <imalloc+0x57>
                result =  malloc_bytes(size);
 8049f41:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f44:	89 04 24             	mov    %eax,(%esp)
 8049f47:	e8 fc fb ff ff       	call   8049b48 <malloc_bytes>
 8049f4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
 8049f4f:	eb 0e                	jmp    8049f5f <imalloc+0x65>
        else
                result =  malloc_pages(size);
 8049f51:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f54:	89 04 24             	mov    %eax,(%esp)
 8049f57:	e8 00 f8 ff ff       	call   804975c <malloc_pages>
 8049f5c:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (malloc_abort && !result)
 8049f5f:	8b 83 fc 00 00 00    	mov    0xfc(%ebx),%eax
 8049f65:	85 c0                	test   %eax,%eax
 8049f67:	74 14                	je     8049f7d <imalloc+0x83>
 8049f69:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8049f6d:	75 0e                	jne    8049f7d <imalloc+0x83>
                wrterror("allocation failed.\n");
 8049f6f:	8d 83 12 d9 ff ff    	lea    -0x26ee(%ebx),%eax
 8049f75:	89 04 24             	mov    %eax,(%esp)
 8049f78:	e8 df f0 ff ff       	call   804905c <wrterror>

        if (malloc_zero && result)
 8049f7d:	8b 83 14 01 00 00    	mov    0x114(%ebx),%eax
 8049f83:	85 c0                	test   %eax,%eax
 8049f85:	74 20                	je     8049fa7 <imalloc+0xad>
 8049f87:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8049f8b:	74 1a                	je     8049fa7 <imalloc+0xad>
                memset(result, 0, size);
 8049f8d:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f90:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049f94:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8049f9b:	00 
 8049f9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049f9f:	89 04 24             	mov    %eax,(%esp)
 8049fa2:	e8 cd 13 00 00       	call   804b374 <memset>

        return result;
 8049fa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8049faa:	83 c4 24             	add    $0x24,%esp
 8049fad:	5b                   	pop    %ebx
 8049fae:	5d                   	pop    %ebp
 8049faf:	c3                   	ret    

08049fb0 <irealloc>:
/*
 * Change the size of an allocation.
 */
static void *
irealloc(void *ptr, size_t size)
{
 8049fb0:	55                   	push   %ebp
 8049fb1:	89 e5                	mov    %esp,%ebp
 8049fb3:	57                   	push   %edi
 8049fb4:	56                   	push   %esi
 8049fb5:	53                   	push   %ebx
 8049fb6:	83 ec 3c             	sub    $0x3c,%esp
 8049fb9:	e8 99 f0 ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 8049fbe:	81 c3 5a 45 00 00    	add    $0x455a,%ebx
        void *p;
        u_long osize, index;
        struct pginfo **mp;
        int i;

        if (suicide)
 8049fc4:	8b 83 00 01 00 00    	mov    0x100(%ebx),%eax
 8049fca:	85 c0                	test   %eax,%eax
 8049fcc:	74 0c                	je     8049fda <irealloc+0x2a>
                abort();
 8049fce:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8049fd5:	e8 9a e3 ff ff       	call   8048374 <exit>

        index = ptr2index(ptr);
 8049fda:	8b 45 08             	mov    0x8(%ebp),%eax
 8049fdd:	89 c2                	mov    %eax,%edx
 8049fdf:	c1 ea 0c             	shr    $0xc,%edx
 8049fe2:	8b 83 d8 00 00 00    	mov    0xd8(%ebx),%eax
 8049fe8:	89 d1                	mov    %edx,%ecx
 8049fea:	29 c1                	sub    %eax,%ecx
 8049fec:	89 c8                	mov    %ecx,%eax
 8049fee:	89 45 dc             	mov    %eax,-0x24(%ebp)

        if (index < malloc_pageshift) {
 8049ff1:	83 7d dc 0b          	cmpl   $0xb,-0x24(%ebp)
 8049ff5:	77 18                	ja     804a00f <irealloc+0x5f>
                wrtwarning("junk pointer, too low to make sense.\n");
 8049ff7:	8d 83 28 d9 ff ff    	lea    -0x26d8(%ebx),%eax
 8049ffd:	89 04 24             	mov    %eax,(%esp)
 804a000:	e8 22 f1 ff ff       	call   8049127 <wrtwarning>
                return 0;
 804a005:	b8 00 00 00 00       	mov    $0x0,%eax
 804a00a:	e9 0c 02 00 00       	jmp    804a21b <irealloc+0x26b>
        }

        if (index > last_index) {
 804a00f:	8b 83 dc 00 00 00    	mov    0xdc(%ebx),%eax
 804a015:	39 45 dc             	cmp    %eax,-0x24(%ebp)
 804a018:	76 18                	jbe    804a032 <irealloc+0x82>
                wrtwarning("junk pointer, too high to make sense.\n");
 804a01a:	8d 83 50 d9 ff ff    	lea    -0x26b0(%ebx),%eax
 804a020:	89 04 24             	mov    %eax,(%esp)
 804a023:	e8 ff f0 ff ff       	call   8049127 <wrtwarning>
                return 0;
 804a028:	b8 00 00 00 00       	mov    $0x0,%eax
 804a02d:	e9 e9 01 00 00       	jmp    804a21b <irealloc+0x26b>
        }

        mp = &page_dir[index];
 804a032:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 804a038:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804a03b:	c1 e2 02             	shl    $0x2,%edx
 804a03e:	01 d0                	add    %edx,%eax
 804a040:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if (*mp == MALLOC_FIRST) {                  /* Page allocation */
 804a043:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a046:	8b 00                	mov    (%eax),%eax
 804a048:	83 f8 02             	cmp    $0x2,%eax
 804a04b:	75 75                	jne    804a0c2 <irealloc+0x112>

                /* Check the pointer */
                if ((u_long)ptr & malloc_pagemask) {
 804a04d:	8b 45 08             	mov    0x8(%ebp),%eax
 804a050:	25 ff 0f 00 00       	and    $0xfff,%eax
 804a055:	85 c0                	test   %eax,%eax
 804a057:	74 18                	je     804a071 <irealloc+0xc1>
                        wrtwarning("modified (page-) pointer.\n");
 804a059:	8d 83 77 d9 ff ff    	lea    -0x2689(%ebx),%eax
 804a05f:	89 04 24             	mov    %eax,(%esp)
 804a062:	e8 c0 f0 ff ff       	call   8049127 <wrtwarning>
                        return 0;
 804a067:	b8 00 00 00 00       	mov    $0x0,%eax
 804a06c:	e9 aa 01 00 00       	jmp    804a21b <irealloc+0x26b>
                }

                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
 804a071:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
 804a078:	eb 07                	jmp    804a081 <irealloc+0xd1>
                        osize += malloc_pagesize;
 804a07a:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
                        wrtwarning("modified (page-) pointer.\n");
                        return 0;
                }

                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
 804a081:	83 45 e0 04          	addl   $0x4,-0x20(%ebp)
 804a085:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a088:	8b 00                	mov    (%eax),%eax
 804a08a:	83 f8 03             	cmp    $0x3,%eax
 804a08d:	74 eb                	je     804a07a <irealloc+0xca>
                        osize += malloc_pagesize;

                if (!malloc_realloc &&                  /* unless we have to, */
 804a08f:	8b 83 04 01 00 00    	mov    0x104(%ebx),%eax
 804a095:	85 c0                	test   %eax,%eax
 804a097:	0f 85 14 01 00 00    	jne    804a1b1 <irealloc+0x201>
 804a09d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a0a0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804a0a3:	0f 87 08 01 00 00    	ja     804a1b1 <irealloc+0x201>
                    size <= osize &&                      /* .. or are too small, */
                    size > (osize - malloc_pagesize)) {   /* .. or can free a page, */
 804a0a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a0ac:	2d 00 10 00 00       	sub    $0x1000,%eax
                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
                        osize += malloc_pagesize;

                if (!malloc_realloc &&                  /* unless we have to, */
                    size <= osize &&                      /* .. or are too small, */
 804a0b1:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a0b4:	0f 83 f7 00 00 00    	jae    804a1b1 <irealloc+0x201>
                    size > (osize - malloc_pagesize)) {   /* .. or can free a page, */
                        return ptr;                         /* don't do anything. */
 804a0ba:	8b 45 08             	mov    0x8(%ebp),%eax
 804a0bd:	e9 59 01 00 00       	jmp    804a21b <irealloc+0x26b>
                }

        } else if (*mp >= MALLOC_MAGIC) {           /* Chunk allocation */
 804a0c2:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a0c5:	8b 00                	mov    (%eax),%eax
 804a0c7:	83 f8 03             	cmp    $0x3,%eax
 804a0ca:	0f 86 cc 00 00 00    	jbe    804a19c <irealloc+0x1ec>

                /* Check the pointer for sane values */
                if (((u_long)ptr & ((*mp)->size - 1))) {
 804a0d0:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a0d3:	8b 00                	mov    (%eax),%eax
 804a0d5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804a0d9:	0f b7 c0             	movzwl %ax,%eax
 804a0dc:	83 e8 01             	sub    $0x1,%eax
 804a0df:	89 c2                	mov    %eax,%edx
 804a0e1:	8b 45 08             	mov    0x8(%ebp),%eax
 804a0e4:	21 d0                	and    %edx,%eax
 804a0e6:	85 c0                	test   %eax,%eax
 804a0e8:	74 18                	je     804a102 <irealloc+0x152>
                        wrtwarning("modified (chunk-) pointer.\n");
 804a0ea:	8d 83 92 d9 ff ff    	lea    -0x266e(%ebx),%eax
 804a0f0:	89 04 24             	mov    %eax,(%esp)
 804a0f3:	e8 2f f0 ff ff       	call   8049127 <wrtwarning>
                        return 0;
 804a0f8:	b8 00 00 00 00       	mov    $0x0,%eax
 804a0fd:	e9 19 01 00 00       	jmp    804a21b <irealloc+0x26b>
                }

                /* Find the chunk index in the page */
                i = ((u_long)ptr & malloc_pagemask) >> (*mp)->shift;
 804a102:	8b 45 08             	mov    0x8(%ebp),%eax
 804a105:	89 c2                	mov    %eax,%edx
 804a107:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
 804a10d:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a110:	8b 00                	mov    (%eax),%eax
 804a112:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804a116:	0f b7 c0             	movzwl %ax,%eax
 804a119:	89 d6                	mov    %edx,%esi
 804a11b:	89 c1                	mov    %eax,%ecx
 804a11d:	d3 ee                	shr    %cl,%esi
 804a11f:	89 f0                	mov    %esi,%eax
 804a121:	89 45 d8             	mov    %eax,-0x28(%ebp)

                /* Verify that it isn't a free chunk already */
                if ((*mp)->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804a124:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a127:	8b 00                	mov    (%eax),%eax
 804a129:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804a12c:	c1 ea 05             	shr    $0x5,%edx
 804a12f:	83 c2 04             	add    $0x4,%edx
 804a132:	8b 14 90             	mov    (%eax,%edx,4),%edx
 804a135:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a138:	83 e0 1f             	and    $0x1f,%eax
 804a13b:	be 01 00 00 00       	mov    $0x1,%esi
 804a140:	89 f7                	mov    %esi,%edi
 804a142:	89 c1                	mov    %eax,%ecx
 804a144:	d3 e7                	shl    %cl,%edi
 804a146:	89 f8                	mov    %edi,%eax
 804a148:	21 d0                	and    %edx,%eax
 804a14a:	85 c0                	test   %eax,%eax
 804a14c:	74 18                	je     804a166 <irealloc+0x1b6>
                        wrtwarning("chunk is already free.\n");
 804a14e:	8d 83 ae d9 ff ff    	lea    -0x2652(%ebx),%eax
 804a154:	89 04 24             	mov    %eax,(%esp)
 804a157:	e8 cb ef ff ff       	call   8049127 <wrtwarning>
                        return 0;
 804a15c:	b8 00 00 00 00       	mov    $0x0,%eax
 804a161:	e9 b5 00 00 00       	jmp    804a21b <irealloc+0x26b>
                }

                osize = (*mp)->size;
 804a166:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a169:	8b 00                	mov    (%eax),%eax
 804a16b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804a16f:	0f b7 c0             	movzwl %ax,%eax
 804a172:	89 45 e4             	mov    %eax,-0x1c(%ebp)

                if (!malloc_realloc &&          /* Unless we have to, */
 804a175:	8b 83 04 01 00 00    	mov    0x104(%ebx),%eax
 804a17b:	85 c0                	test   %eax,%eax
 804a17d:	75 32                	jne    804a1b1 <irealloc+0x201>
 804a17f:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a182:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804a185:	73 2a                	jae    804a1b1 <irealloc+0x201>
                    size < osize &&               /* ..or are too small, */
                    (size > osize / 2 ||          /* ..or could use a smaller size, */
 804a187:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a18a:	d1 e8                	shr    %eax
                }

                osize = (*mp)->size;

                if (!malloc_realloc &&          /* Unless we have to, */
                    size < osize &&               /* ..or are too small, */
 804a18c:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a18f:	72 06                	jb     804a197 <irealloc+0x1e7>
                    (size > osize / 2 ||          /* ..or could use a smaller size, */
 804a191:	83 7d e4 10          	cmpl   $0x10,-0x1c(%ebp)
 804a195:	75 1a                	jne    804a1b1 <irealloc+0x201>
                     osize == malloc_minsize)) {   /* ..(if there is one) */
                        return ptr;                 /* ..Don't do anything */
 804a197:	8b 45 08             	mov    0x8(%ebp),%eax
 804a19a:	eb 7f                	jmp    804a21b <irealloc+0x26b>
                }

        } else {
                wrtwarning("pointer to wrong page.\n");
 804a19c:	8d 83 c6 d9 ff ff    	lea    -0x263a(%ebx),%eax
 804a1a2:	89 04 24             	mov    %eax,(%esp)
 804a1a5:	e8 7d ef ff ff       	call   8049127 <wrtwarning>
                return 0;
 804a1aa:	b8 00 00 00 00       	mov    $0x0,%eax
 804a1af:	eb 6a                	jmp    804a21b <irealloc+0x26b>
        }

        p = imalloc(size);
 804a1b1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a1b4:	89 04 24             	mov    %eax,(%esp)
 804a1b7:	e8 3e fd ff ff       	call   8049efa <imalloc>
 804a1bc:	89 45 d4             	mov    %eax,-0x2c(%ebp)

        if (p) {
 804a1bf:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804a1c3:	74 53                	je     804a218 <irealloc+0x268>
                /* copy the lesser of the two sizes, and free the old one */
                if (!size || !osize)
 804a1c5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804a1c9:	74 42                	je     804a20d <irealloc+0x25d>
 804a1cb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804a1cf:	74 3c                	je     804a20d <irealloc+0x25d>
                        ;
                else if (osize < size)
 804a1d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a1d4:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a1d7:	73 1b                	jae    804a1f4 <irealloc+0x244>
                        memcpy(p, ptr, osize);
 804a1d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a1dc:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a1e0:	8b 45 08             	mov    0x8(%ebp),%eax
 804a1e3:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a1e7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804a1ea:	89 04 24             	mov    %eax,(%esp)
 804a1ed:	e8 34 10 00 00       	call   804b226 <memcpy>
 804a1f2:	eb 19                	jmp    804a20d <irealloc+0x25d>
                else
                        memcpy(p, ptr, size);
 804a1f4:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a1f7:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a1fb:	8b 45 08             	mov    0x8(%ebp),%eax
 804a1fe:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a202:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804a205:	89 04 24             	mov    %eax,(%esp)
 804a208:	e8 19 10 00 00       	call   804b226 <memcpy>
                ifree(ptr);
 804a20d:	8b 45 08             	mov    0x8(%ebp),%eax
 804a210:	89 04 24             	mov    %eax,(%esp)
 804a213:	e8 36 06 00 00       	call   804a84e <ifree>
        }
        return p;
 804a218:	8b 45 d4             	mov    -0x2c(%ebp),%eax
}
 804a21b:	83 c4 3c             	add    $0x3c,%esp
 804a21e:	5b                   	pop    %ebx
 804a21f:	5e                   	pop    %esi
 804a220:	5f                   	pop    %edi
 804a221:	5d                   	pop    %ebp
 804a222:	c3                   	ret    

0804a223 <free_pages>:
 * Free a sequence of pages
 */

static __inline__ void
free_pages(void *ptr, int index, struct pginfo *info)
{
 804a223:	55                   	push   %ebp
 804a224:	89 e5                	mov    %esp,%ebp
 804a226:	53                   	push   %ebx
 804a227:	83 ec 34             	sub    $0x34,%esp
 804a22a:	e8 28 ee ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 804a22f:	81 c3 e9 42 00 00    	add    $0x42e9,%ebx
        unsigned int i;
        struct pgfree *pf, *pt = 0;
 804a235:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
        u_long l;
        void *tail;

        if (info == MALLOC_FREE) {
 804a23c:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
 804a240:	75 13                	jne    804a255 <free_pages+0x32>
                wrtwarning("page is already free.\n");
 804a242:	8d 83 de d9 ff ff    	lea    -0x2622(%ebx),%eax
 804a248:	89 04 24             	mov    %eax,(%esp)
 804a24b:	e8 d7 ee ff ff       	call   8049127 <wrtwarning>
                return;
 804a250:	e9 d8 03 00 00       	jmp    804a62d <free_pages+0x40a>
        }

        if (info != MALLOC_FIRST) {
 804a255:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
 804a259:	74 13                	je     804a26e <free_pages+0x4b>
                wrtwarning("pointer to wrong page.\n");
 804a25b:	8d 83 c6 d9 ff ff    	lea    -0x263a(%ebx),%eax
 804a261:	89 04 24             	mov    %eax,(%esp)
 804a264:	e8 be ee ff ff       	call   8049127 <wrtwarning>
                return;
 804a269:	e9 bf 03 00 00       	jmp    804a62d <free_pages+0x40a>
        }

        if ((u_long)ptr & malloc_pagemask) {
 804a26e:	8b 45 08             	mov    0x8(%ebp),%eax
 804a271:	25 ff 0f 00 00       	and    $0xfff,%eax
 804a276:	85 c0                	test   %eax,%eax
 804a278:	74 13                	je     804a28d <free_pages+0x6a>
                wrtwarning("modified (page-) pointer.\n");
 804a27a:	8d 83 77 d9 ff ff    	lea    -0x2689(%ebx),%eax
 804a280:	89 04 24             	mov    %eax,(%esp)
 804a283:	e8 9f ee ff ff       	call   8049127 <wrtwarning>
                return;
 804a288:	e9 a0 03 00 00       	jmp    804a62d <free_pages+0x40a>
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
 804a28d:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 804a293:	8b 55 0c             	mov    0xc(%ebp),%edx
 804a296:	c1 e2 02             	shl    $0x2,%edx
 804a299:	01 d0                	add    %edx,%eax
 804a29b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804a2a1:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
 804a2a8:	eb 1b                	jmp    804a2c5 <free_pages+0xa2>
                page_dir[index + i] = MALLOC_FREE;
 804a2aa:	8b 93 e0 00 00 00    	mov    0xe0(%ebx),%edx
 804a2b0:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a2b3:	03 45 f4             	add    -0xc(%ebp),%eax
 804a2b6:	c1 e0 02             	shl    $0x2,%eax
 804a2b9:	01 d0                	add    %edx,%eax
 804a2bb:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804a2c1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 804a2c5:	8b 93 e0 00 00 00    	mov    0xe0(%ebx),%edx
 804a2cb:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a2ce:	03 45 f4             	add    -0xc(%ebp),%eax
 804a2d1:	c1 e0 02             	shl    $0x2,%eax
 804a2d4:	01 d0                	add    %edx,%eax
 804a2d6:	8b 00                	mov    (%eax),%eax
 804a2d8:	83 f8 03             	cmp    $0x3,%eax
 804a2db:	74 cd                	je     804a2aa <free_pages+0x87>
                page_dir[index + i] = MALLOC_FREE;

        l = i << malloc_pageshift;
 804a2dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a2e0:	c1 e0 0c             	shl    $0xc,%eax
 804a2e3:	89 45 e8             	mov    %eax,-0x18(%ebp)

        if (malloc_junk)
 804a2e6:	8b 83 18 01 00 00    	mov    0x118(%ebx),%eax
 804a2ec:	85 c0                	test   %eax,%eax
 804a2ee:	74 1a                	je     804a30a <free_pages+0xe7>
                memset(ptr, SOME_JUNK, l);
 804a2f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a2f3:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a2f7:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804a2fe:	00 
 804a2ff:	8b 45 08             	mov    0x8(%ebp),%eax
 804a302:	89 04 24             	mov    %eax,(%esp)
 804a305:	e8 6a 10 00 00       	call   804b374 <memset>
#ifdef HAS_MADVISE
        if (malloc_hint)
                madvise(ptr, l, MADV_FREE);
#endif

        tail = (char *)ptr + l;
 804a30a:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a30d:	8b 55 08             	mov    0x8(%ebp),%edx
 804a310:	01 d0                	add    %edx,%eax
 804a312:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        /* add to free-list */
        if (!px)
 804a315:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804a31b:	85 c0                	test   %eax,%eax
 804a31d:	75 12                	jne    804a331 <free_pages+0x10e>
                px = imalloc(sizeof * pt);      /* This cannot fail... */
 804a31f:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 804a326:	e8 cf fb ff ff       	call   8049efa <imalloc>
 804a32b:	89 83 20 01 00 00    	mov    %eax,0x120(%ebx)
        px->page = ptr;
 804a331:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804a337:	8b 55 08             	mov    0x8(%ebp),%edx
 804a33a:	89 50 08             	mov    %edx,0x8(%eax)
        px->end =  tail;
 804a33d:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804a343:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804a346:	89 50 0c             	mov    %edx,0xc(%eax)
        px->size = l;
 804a349:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804a34f:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804a352:	89 50 10             	mov    %edx,0x10(%eax)
        if (!free_list.next) {
 804a355:	8b 83 e8 00 00 00    	mov    0xe8(%ebx),%eax
 804a35b:	85 c0                	test   %eax,%eax
 804a35d:	75 41                	jne    804a3a0 <free_pages+0x17d>

                /* Nothing on free list, put this at head */
                px->next = free_list.next;
 804a35f:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804a365:	8b 93 e8 00 00 00    	mov    0xe8(%ebx),%edx
 804a36b:	89 10                	mov    %edx,(%eax)
                px->prev = &free_list;
 804a36d:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804a373:	8d 93 e8 00 00 00    	lea    0xe8(%ebx),%edx
 804a379:	89 50 04             	mov    %edx,0x4(%eax)
                free_list.next = px;
 804a37c:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804a382:	89 83 e8 00 00 00    	mov    %eax,0xe8(%ebx)
                pf = px;
 804a388:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804a38e:	89 45 f0             	mov    %eax,-0x10(%ebp)
                px = 0;
 804a391:	c7 83 20 01 00 00 00 	movl   $0x0,0x120(%ebx)
 804a398:	00 00 00 
 804a39b:	e9 a2 01 00 00       	jmp    804a542 <free_pages+0x31f>

        } else {

                /* Find the right spot, leave pf pointing to the modified entry. */
                tail = (char *)ptr + l;
 804a3a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a3a3:	8b 55 08             	mov    0x8(%ebp),%edx
 804a3a6:	01 d0                	add    %edx,%eax
 804a3a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)

                for (pf = free_list.next; pf->end < ptr && pf->next; pf = pf->next)
 804a3ab:	8b 83 e8 00 00 00    	mov    0xe8(%ebx),%eax
 804a3b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804a3b4:	eb 08                	jmp    804a3be <free_pages+0x19b>
 804a3b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a3b9:	8b 00                	mov    (%eax),%eax
 804a3bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804a3be:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a3c1:	8b 40 0c             	mov    0xc(%eax),%eax
 804a3c4:	3b 45 08             	cmp    0x8(%ebp),%eax
 804a3c7:	73 09                	jae    804a3d2 <free_pages+0x1af>
 804a3c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a3cc:	8b 00                	mov    (%eax),%eax
 804a3ce:	85 c0                	test   %eax,%eax
 804a3d0:	75 e4                	jne    804a3b6 <free_pages+0x193>
                        ; /* Race ahead here */

                if (pf->page > tail) {
 804a3d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a3d5:	8b 40 08             	mov    0x8(%eax),%eax
 804a3d8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804a3db:	76 4f                	jbe    804a42c <free_pages+0x209>
                        /* Insert before entry */
                        px->next = pf;
 804a3dd:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804a3e3:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804a3e6:	89 10                	mov    %edx,(%eax)
                        px->prev = pf->prev;
 804a3e8:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804a3ee:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804a3f1:	8b 52 04             	mov    0x4(%edx),%edx
 804a3f4:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev = px;
 804a3f7:	8b 93 20 01 00 00    	mov    0x120(%ebx),%edx
 804a3fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a400:	89 50 04             	mov    %edx,0x4(%eax)
                        px->prev->next = px;
 804a403:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804a409:	8b 40 04             	mov    0x4(%eax),%eax
 804a40c:	8b 93 20 01 00 00    	mov    0x120(%ebx),%edx
 804a412:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804a414:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804a41a:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        px = 0;
 804a41d:	c7 83 20 01 00 00 00 	movl   $0x0,0x120(%ebx)
 804a424:	00 00 00 
 804a427:	e9 16 01 00 00       	jmp    804a542 <free_pages+0x31f>
                } else if (pf->end == ptr) {
 804a42c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a42f:	8b 40 0c             	mov    0xc(%eax),%eax
 804a432:	3b 45 08             	cmp    0x8(%ebp),%eax
 804a435:	0f 85 91 00 00 00    	jne    804a4cc <free_pages+0x2a9>
                        /* Append to the previous entry */
                        pf->end = (char *)pf->end + l;
 804a43b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a43e:	8b 40 0c             	mov    0xc(%eax),%eax
 804a441:	89 c2                	mov    %eax,%edx
 804a443:	03 55 e8             	add    -0x18(%ebp),%edx
 804a446:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a449:	89 50 0c             	mov    %edx,0xc(%eax)
                        pf->size += l;
 804a44c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a44f:	8b 40 10             	mov    0x10(%eax),%eax
 804a452:	89 c2                	mov    %eax,%edx
 804a454:	03 55 e8             	add    -0x18(%ebp),%edx
 804a457:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a45a:	89 50 10             	mov    %edx,0x10(%eax)
                        if (pf->next && pf->end == pf->next->page) {
 804a45d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a460:	8b 00                	mov    (%eax),%eax
 804a462:	85 c0                	test   %eax,%eax
 804a464:	0f 84 d8 00 00 00    	je     804a542 <free_pages+0x31f>
 804a46a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a46d:	8b 50 0c             	mov    0xc(%eax),%edx
 804a470:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a473:	8b 00                	mov    (%eax),%eax
 804a475:	8b 40 08             	mov    0x8(%eax),%eax
 804a478:	39 c2                	cmp    %eax,%edx
 804a47a:	0f 85 c2 00 00 00    	jne    804a542 <free_pages+0x31f>
                                /* And collapse the next too. */
                                pt = pf->next;
 804a480:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a483:	8b 00                	mov    (%eax),%eax
 804a485:	89 45 ec             	mov    %eax,-0x14(%ebp)
                                pf->end = pt->end;
 804a488:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a48b:	8b 50 0c             	mov    0xc(%eax),%edx
 804a48e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a491:	89 50 0c             	mov    %edx,0xc(%eax)
                                pf->size += pt->size;
 804a494:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a497:	8b 50 10             	mov    0x10(%eax),%edx
 804a49a:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a49d:	8b 40 10             	mov    0x10(%eax),%eax
 804a4a0:	01 c2                	add    %eax,%edx
 804a4a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a4a5:	89 50 10             	mov    %edx,0x10(%eax)
                                pf->next = pt->next;
 804a4a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a4ab:	8b 10                	mov    (%eax),%edx
 804a4ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a4b0:	89 10                	mov    %edx,(%eax)
                                if (pf->next)
 804a4b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a4b5:	8b 00                	mov    (%eax),%eax
 804a4b7:	85 c0                	test   %eax,%eax
 804a4b9:	0f 84 83 00 00 00    	je     804a542 <free_pages+0x31f>
                                        pf->next->prev = pf;
 804a4bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a4c2:	8b 00                	mov    (%eax),%eax
 804a4c4:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804a4c7:	89 50 04             	mov    %edx,0x4(%eax)
 804a4ca:	eb 76                	jmp    804a542 <free_pages+0x31f>
                        }
                } else if (pf->page == tail) {
 804a4cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a4cf:	8b 40 08             	mov    0x8(%eax),%eax
 804a4d2:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804a4d5:	75 1c                	jne    804a4f3 <free_pages+0x2d0>
                        /* Prepend to entry */
                        pf->size += l;
 804a4d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a4da:	8b 40 10             	mov    0x10(%eax),%eax
 804a4dd:	89 c2                	mov    %eax,%edx
 804a4df:	03 55 e8             	add    -0x18(%ebp),%edx
 804a4e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a4e5:	89 50 10             	mov    %edx,0x10(%eax)
                        pf->page = ptr;
 804a4e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a4eb:	8b 55 08             	mov    0x8(%ebp),%edx
 804a4ee:	89 50 08             	mov    %edx,0x8(%eax)
 804a4f1:	eb 4f                	jmp    804a542 <free_pages+0x31f>
                } else if (!pf->next) {
 804a4f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a4f6:	8b 00                	mov    (%eax),%eax
 804a4f8:	85 c0                	test   %eax,%eax
 804a4fa:	75 38                	jne    804a534 <free_pages+0x311>
                        /* Append at tail of chain */
                        px->next = 0;
 804a4fc:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804a502:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                        px->prev = pf;
 804a508:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804a50e:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804a511:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->next = px;
 804a514:	8b 93 20 01 00 00    	mov    0x120(%ebx),%edx
 804a51a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a51d:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804a51f:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804a525:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        px = 0;
 804a528:	c7 83 20 01 00 00 00 	movl   $0x0,0x120(%ebx)
 804a52f:	00 00 00 
 804a532:	eb 0e                	jmp    804a542 <free_pages+0x31f>
                } else {
                        wrterror("freelist is destroyed.\n");
 804a534:	8d 83 f5 d9 ff ff    	lea    -0x260b(%ebx),%eax
 804a53a:	89 04 24             	mov    %eax,(%esp)
 804a53d:	e8 1a eb ff ff       	call   804905c <wrterror>
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804a542:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a545:	8b 00                	mov    (%eax),%eax
 804a547:	85 c0                	test   %eax,%eax
 804a549:	0f 85 cd 00 00 00    	jne    804a61c <free_pages+0x3f9>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804a54f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a552:	8b 50 10             	mov    0x10(%eax),%edx
 804a555:	8b 83 0c 00 00 00    	mov    0xc(%ebx),%eax
                        wrterror("freelist is destroyed.\n");
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804a55b:	39 c2                	cmp    %eax,%edx
 804a55d:	0f 86 b9 00 00 00    	jbe    804a61c <free_pages+0x3f9>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804a563:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a566:	8b 50 0c             	mov    0xc(%eax),%edx
 804a569:	8b 83 1c 01 00 00    	mov    0x11c(%ebx),%eax
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804a56f:	39 c2                	cmp    %eax,%edx
 804a571:	0f 85 a5 00 00 00    	jne    804a61c <free_pages+0x3f9>
            pf->end == malloc_brk &&                  /* ..and none behind us, */
            malloc_brk == sbrk(0)) {                  /* ..and it's OK to do... */
 804a577:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a57e:	e8 c9 db ff ff       	call   804814c <sbrk>
 804a583:	8b 93 1c 01 00 00    	mov    0x11c(%ebx),%edx
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804a589:	39 d0                	cmp    %edx,%eax
 804a58b:	0f 85 8b 00 00 00    	jne    804a61c <free_pages+0x3f9>

                /*
                 * Keep the cache intact.  Notice that the '>' above guarantees that
                 * the pf will always have at least one page afterwards.
                 */
                pf->end = (char *)pf->page + malloc_cache;
 804a591:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a594:	8b 50 08             	mov    0x8(%eax),%edx
 804a597:	8b 83 0c 00 00 00    	mov    0xc(%ebx),%eax
 804a59d:	01 c2                	add    %eax,%edx
 804a59f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a5a2:	89 50 0c             	mov    %edx,0xc(%eax)
                pf->size = malloc_cache;
 804a5a5:	8b 93 0c 00 00 00    	mov    0xc(%ebx),%edx
 804a5ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a5ae:	89 50 10             	mov    %edx,0x10(%eax)

                brk(pf->end);
 804a5b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a5b4:	8b 40 0c             	mov    0xc(%eax),%eax
 804a5b7:	89 04 24             	mov    %eax,(%esp)
 804a5ba:	e8 5d dc ff ff       	call   804821c <brk>
                malloc_brk = pf->end;
 804a5bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a5c2:	8b 40 0c             	mov    0xc(%eax),%eax
 804a5c5:	89 83 1c 01 00 00    	mov    %eax,0x11c(%ebx)

                index = ptr2index(pf->end);
 804a5cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a5ce:	8b 40 0c             	mov    0xc(%eax),%eax
 804a5d1:	89 c2                	mov    %eax,%edx
 804a5d3:	c1 ea 0c             	shr    $0xc,%edx
 804a5d6:	8b 83 d8 00 00 00    	mov    0xd8(%ebx),%eax
 804a5dc:	89 d1                	mov    %edx,%ecx
 804a5de:	29 c1                	sub    %eax,%ecx
 804a5e0:	89 c8                	mov    %ecx,%eax
 804a5e2:	89 45 0c             	mov    %eax,0xc(%ebp)
                last_index = index - 1;
 804a5e5:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a5e8:	83 e8 01             	sub    $0x1,%eax
 804a5eb:	89 83 dc 00 00 00    	mov    %eax,0xdc(%ebx)

                for (i = index; i <= last_index;)
 804a5f1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a5f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a5f7:	eb 18                	jmp    804a611 <free_pages+0x3ee>
                        page_dir[i++] = MALLOC_NOT_MINE;
 804a5f9:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 804a5ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804a602:	c1 e2 02             	shl    $0x2,%edx
 804a605:	01 d0                	add    %edx,%eax
 804a607:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
 804a60d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                malloc_brk = pf->end;

                index = ptr2index(pf->end);
                last_index = index - 1;

                for (i = index; i <= last_index;)
 804a611:	8b 83 dc 00 00 00    	mov    0xdc(%ebx),%eax
 804a617:	39 45 f4             	cmp    %eax,-0xc(%ebp)
 804a61a:	76 dd                	jbe    804a5f9 <free_pages+0x3d6>
                        page_dir[i++] = MALLOC_NOT_MINE;

                /* XXX: We could realloc/shrink the pagedir here I guess. */
        }
        if (pt)
 804a61c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804a620:	74 0b                	je     804a62d <free_pages+0x40a>
                ifree(pt);
 804a622:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a625:	89 04 24             	mov    %eax,(%esp)
 804a628:	e8 21 02 00 00       	call   804a84e <ifree>
}
 804a62d:	83 c4 34             	add    $0x34,%esp
 804a630:	5b                   	pop    %ebx
 804a631:	5d                   	pop    %ebp
 804a632:	c3                   	ret    

0804a633 <free_bytes>:
 * Free a chunk, and possibly the page it's on, if the page becomes empty.
 */

static __inline__ void
free_bytes(void *ptr, int index, struct pginfo *info)
{
 804a633:	55                   	push   %ebp
 804a634:	89 e5                	mov    %esp,%ebp
 804a636:	57                   	push   %edi
 804a637:	56                   	push   %esi
 804a638:	53                   	push   %ebx
 804a639:	83 ec 3c             	sub    $0x3c,%esp
 804a63c:	e8 16 ea ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 804a641:	81 c3 d7 3e 00 00    	add    $0x3ed7,%ebx
        int i;
        struct pginfo **mp;
        void *vp;

        /* Find the chunk number on the page */
        i = ((u_long)ptr & malloc_pagemask) >> info->shift;
 804a647:	8b 45 08             	mov    0x8(%ebp),%eax
 804a64a:	89 c2                	mov    %eax,%edx
 804a64c:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
 804a652:	8b 45 10             	mov    0x10(%ebp),%eax
 804a655:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804a659:	0f b7 c0             	movzwl %ax,%eax
 804a65c:	89 d6                	mov    %edx,%esi
 804a65e:	89 c1                	mov    %eax,%ecx
 804a660:	d3 ee                	shr    %cl,%esi
 804a662:	89 f0                	mov    %esi,%eax
 804a664:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if (((u_long)ptr & (info->size - 1))) {
 804a667:	8b 45 10             	mov    0x10(%ebp),%eax
 804a66a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804a66e:	0f b7 c0             	movzwl %ax,%eax
 804a671:	83 e8 01             	sub    $0x1,%eax
 804a674:	89 c2                	mov    %eax,%edx
 804a676:	8b 45 08             	mov    0x8(%ebp),%eax
 804a679:	21 d0                	and    %edx,%eax
 804a67b:	85 c0                	test   %eax,%eax
 804a67d:	74 13                	je     804a692 <free_bytes+0x5f>
                wrtwarning("modified (chunk-) pointer.\n");
 804a67f:	8d 83 92 d9 ff ff    	lea    -0x266e(%ebx),%eax
 804a685:	89 04 24             	mov    %eax,(%esp)
 804a688:	e8 9a ea ff ff       	call   8049127 <wrtwarning>
                return;
 804a68d:	e9 b4 01 00 00       	jmp    804a846 <free_bytes+0x213>
        }

        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804a692:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a695:	89 c2                	mov    %eax,%edx
 804a697:	c1 ea 05             	shr    $0x5,%edx
 804a69a:	8b 45 10             	mov    0x10(%ebp),%eax
 804a69d:	83 c2 04             	add    $0x4,%edx
 804a6a0:	8b 14 90             	mov    (%eax,%edx,4),%edx
 804a6a3:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a6a6:	83 e0 1f             	and    $0x1f,%eax
 804a6a9:	be 01 00 00 00       	mov    $0x1,%esi
 804a6ae:	89 f7                	mov    %esi,%edi
 804a6b0:	89 c1                	mov    %eax,%ecx
 804a6b2:	d3 e7                	shl    %cl,%edi
 804a6b4:	89 f8                	mov    %edi,%eax
 804a6b6:	21 d0                	and    %edx,%eax
 804a6b8:	85 c0                	test   %eax,%eax
 804a6ba:	74 13                	je     804a6cf <free_bytes+0x9c>
                wrtwarning("chunk is already free.\n");
 804a6bc:	8d 83 ae d9 ff ff    	lea    -0x2652(%ebx),%eax
 804a6c2:	89 04 24             	mov    %eax,(%esp)
 804a6c5:	e8 5d ea ff ff       	call   8049127 <wrtwarning>
                return;
 804a6ca:	e9 77 01 00 00       	jmp    804a846 <free_bytes+0x213>
        }

        if (malloc_junk)
 804a6cf:	8b 83 18 01 00 00    	mov    0x118(%ebx),%eax
 804a6d5:	85 c0                	test   %eax,%eax
 804a6d7:	74 21                	je     804a6fa <free_bytes+0xc7>
                memset(ptr, SOME_JUNK, info->size);
 804a6d9:	8b 45 10             	mov    0x10(%ebp),%eax
 804a6dc:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804a6e0:	0f b7 c0             	movzwl %ax,%eax
 804a6e3:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a6e7:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804a6ee:	00 
 804a6ef:	8b 45 08             	mov    0x8(%ebp),%eax
 804a6f2:	89 04 24             	mov    %eax,(%esp)
 804a6f5:	e8 7a 0c 00 00       	call   804b374 <memset>

        info->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804a6fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a6fd:	c1 e8 05             	shr    $0x5,%eax
 804a700:	8b 55 10             	mov    0x10(%ebp),%edx
 804a703:	8d 48 04             	lea    0x4(%eax),%ecx
 804a706:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 804a709:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804a70c:	83 e2 1f             	and    $0x1f,%edx
 804a70f:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
 804a716:	8b 7d d4             	mov    -0x2c(%ebp),%edi
 804a719:	89 d1                	mov    %edx,%ecx
 804a71b:	d3 e7                	shl    %cl,%edi
 804a71d:	89 fa                	mov    %edi,%edx
 804a71f:	89 f1                	mov    %esi,%ecx
 804a721:	09 d1                	or     %edx,%ecx
 804a723:	8b 55 10             	mov    0x10(%ebp),%edx
 804a726:	83 c0 04             	add    $0x4,%eax
 804a729:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
        info->free++;
 804a72c:	8b 45 10             	mov    0x10(%ebp),%eax
 804a72f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804a733:	8d 50 01             	lea    0x1(%eax),%edx
 804a736:	8b 45 10             	mov    0x10(%ebp),%eax
 804a739:	66 89 50 0c          	mov    %dx,0xc(%eax)

        mp = page_dir + info->shift;
 804a73d:	8b 93 e0 00 00 00    	mov    0xe0(%ebx),%edx
 804a743:	8b 45 10             	mov    0x10(%ebp),%eax
 804a746:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804a74a:	0f b7 c0             	movzwl %ax,%eax
 804a74d:	c1 e0 02             	shl    $0x2,%eax
 804a750:	01 d0                	add    %edx,%eax
 804a752:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if (info->free == 1) {
 804a755:	8b 45 10             	mov    0x10(%ebp),%eax
 804a758:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804a75c:	66 83 f8 01          	cmp    $0x1,%ax
 804a760:	75 61                	jne    804a7c3 <free_bytes+0x190>

                /* Page became non-full */

                mp = page_dir + info->shift;
 804a762:	8b 93 e0 00 00 00    	mov    0xe0(%ebx),%edx
 804a768:	8b 45 10             	mov    0x10(%ebp),%eax
 804a76b:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804a76f:	0f b7 c0             	movzwl %ax,%eax
 804a772:	c1 e0 02             	shl    $0x2,%eax
 804a775:	01 d0                	add    %edx,%eax
 804a777:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804a77a:	eb 08                	jmp    804a784 <free_bytes+0x151>
                        mp = &(*mp)->next;
 804a77c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a77f:	8b 00                	mov    (%eax),%eax
 804a781:	89 45 e4             	mov    %eax,-0x1c(%ebp)

                /* Page became non-full */

                mp = page_dir + info->shift;
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804a784:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a787:	8b 00                	mov    (%eax),%eax
 804a789:	85 c0                	test   %eax,%eax
 804a78b:	74 1f                	je     804a7ac <free_bytes+0x179>
 804a78d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a790:	8b 00                	mov    (%eax),%eax
 804a792:	8b 00                	mov    (%eax),%eax
 804a794:	85 c0                	test   %eax,%eax
 804a796:	74 14                	je     804a7ac <free_bytes+0x179>
 804a798:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a79b:	8b 00                	mov    (%eax),%eax
 804a79d:	8b 00                	mov    (%eax),%eax
 804a79f:	8b 50 04             	mov    0x4(%eax),%edx
 804a7a2:	8b 45 10             	mov    0x10(%ebp),%eax
 804a7a5:	8b 40 04             	mov    0x4(%eax),%eax
 804a7a8:	39 c2                	cmp    %eax,%edx
 804a7aa:	72 d0                	jb     804a77c <free_bytes+0x149>
                        mp = &(*mp)->next;
                info->next = *mp;
 804a7ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a7af:	8b 10                	mov    (%eax),%edx
 804a7b1:	8b 45 10             	mov    0x10(%ebp),%eax
 804a7b4:	89 10                	mov    %edx,(%eax)
                *mp = info;
 804a7b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a7b9:	8b 55 10             	mov    0x10(%ebp),%edx
 804a7bc:	89 10                	mov    %edx,(%eax)
                return;
 804a7be:	e9 83 00 00 00       	jmp    804a846 <free_bytes+0x213>
        }

        if (info->free != info->total)
 804a7c3:	8b 45 10             	mov    0x10(%ebp),%eax
 804a7c6:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804a7ca:	8b 45 10             	mov    0x10(%ebp),%eax
 804a7cd:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804a7d1:	66 39 c2             	cmp    %ax,%dx
 804a7d4:	74 0c                	je     804a7e2 <free_bytes+0x1af>
                return;
 804a7d6:	eb 6e                	jmp    804a846 <free_bytes+0x213>

        /* Find & remove this page in the queue */
        while (*mp != info) {
                mp = &((*mp)->next);
 804a7d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a7db:	8b 00                	mov    (%eax),%eax
 804a7dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804a7e0:	eb 01                	jmp    804a7e3 <free_bytes+0x1b0>

        if (info->free != info->total)
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
 804a7e2:	90                   	nop
 804a7e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a7e6:	8b 00                	mov    (%eax),%eax
 804a7e8:	3b 45 10             	cmp    0x10(%ebp),%eax
 804a7eb:	75 eb                	jne    804a7d8 <free_bytes+0x1a5>
#ifdef EXTRA_SANITY
                if (!*mp)
                        wrterror("(ES): Not on queue\n");
#endif /* EXTRA_SANITY */
        }
        *mp = info->next;
 804a7ed:	8b 45 10             	mov    0x10(%ebp),%eax
 804a7f0:	8b 10                	mov    (%eax),%edx
 804a7f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a7f5:	89 10                	mov    %edx,(%eax)

        /* Free the page & the info structure if need be */
        page_dir[ptr2index(info->page)] = MALLOC_FIRST;
 804a7f7:	8b 93 e0 00 00 00    	mov    0xe0(%ebx),%edx
 804a7fd:	8b 45 10             	mov    0x10(%ebp),%eax
 804a800:	8b 40 04             	mov    0x4(%eax),%eax
 804a803:	89 c1                	mov    %eax,%ecx
 804a805:	c1 e9 0c             	shr    $0xc,%ecx
 804a808:	8b 83 d8 00 00 00    	mov    0xd8(%ebx),%eax
 804a80e:	89 ce                	mov    %ecx,%esi
 804a810:	29 c6                	sub    %eax,%esi
 804a812:	89 f0                	mov    %esi,%eax
 804a814:	c1 e0 02             	shl    $0x2,%eax
 804a817:	01 d0                	add    %edx,%eax
 804a819:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        vp = info->page;            /* Order is important ! */
 804a81f:	8b 45 10             	mov    0x10(%ebp),%eax
 804a822:	8b 40 04             	mov    0x4(%eax),%eax
 804a825:	89 45 dc             	mov    %eax,-0x24(%ebp)
        if (vp != (void *)info)
 804a828:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a82b:	3b 45 10             	cmp    0x10(%ebp),%eax
 804a82e:	74 0b                	je     804a83b <free_bytes+0x208>
                ifree(info);
 804a830:	8b 45 10             	mov    0x10(%ebp),%eax
 804a833:	89 04 24             	mov    %eax,(%esp)
 804a836:	e8 13 00 00 00       	call   804a84e <ifree>
        ifree(vp);
 804a83b:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a83e:	89 04 24             	mov    %eax,(%esp)
 804a841:	e8 08 00 00 00       	call   804a84e <ifree>
}
 804a846:	83 c4 3c             	add    $0x3c,%esp
 804a849:	5b                   	pop    %ebx
 804a84a:	5e                   	pop    %esi
 804a84b:	5f                   	pop    %edi
 804a84c:	5d                   	pop    %ebp
 804a84d:	c3                   	ret    

0804a84e <ifree>:

static void
ifree(void *ptr)
{
 804a84e:	55                   	push   %ebp
 804a84f:	89 e5                	mov    %esp,%ebp
 804a851:	57                   	push   %edi
 804a852:	56                   	push   %esi
 804a853:	53                   	push   %ebx
 804a854:	83 ec 6c             	sub    $0x6c,%esp
 804a857:	e8 fb e7 ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 804a85c:	81 c3 bc 3c 00 00    	add    $0x3cbc,%ebx
        struct pginfo *info;
        unsigned int index;

        /* This is legal */
        if (!ptr)
 804a862:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804a866:	0f 84 b9 06 00 00    	je     804af25 <ifree+0x6d7>
                return;

        if (!malloc_started) {
 804a86c:	8b 83 d0 00 00 00    	mov    0xd0(%ebx),%eax
 804a872:	85 c0                	test   %eax,%eax
 804a874:	75 13                	jne    804a889 <ifree+0x3b>
                wrtwarning("malloc() has never been called.\n");
 804a876:	8d 83 10 da ff ff    	lea    -0x25f0(%ebx),%eax
 804a87c:	89 04 24             	mov    %eax,(%esp)
 804a87f:	e8 a3 e8 ff ff       	call   8049127 <wrtwarning>
                return;
 804a884:	e9 a3 06 00 00       	jmp    804af2c <ifree+0x6de>
        }

        /* If we're already sinking, don't make matters any worse. */
        if (suicide)
 804a889:	8b 83 00 01 00 00    	mov    0x100(%ebx),%eax
 804a88f:	85 c0                	test   %eax,%eax
 804a891:	0f 85 91 06 00 00    	jne    804af28 <ifree+0x6da>
                return;

        index = ptr2index(ptr);
 804a897:	8b 45 08             	mov    0x8(%ebp),%eax
 804a89a:	89 c2                	mov    %eax,%edx
 804a89c:	c1 ea 0c             	shr    $0xc,%edx
 804a89f:	8b 83 d8 00 00 00    	mov    0xd8(%ebx),%eax
 804a8a5:	89 d1                	mov    %edx,%ecx
 804a8a7:	29 c1                	sub    %eax,%ecx
 804a8a9:	89 c8                	mov    %ecx,%eax
 804a8ab:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if (index < malloc_pageshift) {
 804a8ae:	83 7d e4 0b          	cmpl   $0xb,-0x1c(%ebp)
 804a8b2:	77 13                	ja     804a8c7 <ifree+0x79>
                wrtwarning("junk pointer, too low to make sense.\n");
 804a8b4:	8d 83 28 d9 ff ff    	lea    -0x26d8(%ebx),%eax
 804a8ba:	89 04 24             	mov    %eax,(%esp)
 804a8bd:	e8 65 e8 ff ff       	call   8049127 <wrtwarning>
                return;
 804a8c2:	e9 65 06 00 00       	jmp    804af2c <ifree+0x6de>
        }

        if (index > last_index) {
 804a8c7:	8b 83 dc 00 00 00    	mov    0xdc(%ebx),%eax
 804a8cd:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
 804a8d0:	76 13                	jbe    804a8e5 <ifree+0x97>
                wrtwarning("junk pointer, too high to make sense.\n");
 804a8d2:	8d 83 50 d9 ff ff    	lea    -0x26b0(%ebx),%eax
 804a8d8:	89 04 24             	mov    %eax,(%esp)
 804a8db:	e8 47 e8 ff ff       	call   8049127 <wrtwarning>
                return;
 804a8e0:	e9 47 06 00 00       	jmp    804af2c <ifree+0x6de>
        }

        info = page_dir[index];
 804a8e5:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 804a8eb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804a8ee:	c1 e2 02             	shl    $0x2,%edx
 804a8f1:	01 d0                	add    %edx,%eax
 804a8f3:	8b 00                	mov    (%eax),%eax
 804a8f5:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if (info < MALLOC_MAGIC)
 804a8f8:	83 7d e0 03          	cmpl   $0x3,-0x20(%ebp)
 804a8fc:	0f 87 13 04 00 00    	ja     804ad15 <ifree+0x4c7>
                free_pages(ptr, index, info);
 804a902:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a905:	8b 55 08             	mov    0x8(%ebp),%edx
 804a908:	89 55 dc             	mov    %edx,-0x24(%ebp)
 804a90b:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804a90e:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a911:	89 45 d4             	mov    %eax,-0x2c(%ebp)

static __inline__ void
free_pages(void *ptr, int index, struct pginfo *info)
{
        unsigned int i;
        struct pgfree *pf, *pt = 0;
 804a914:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
        u_long l;
        void *tail;

        if (info == MALLOC_FREE) {
 804a91b:	83 7d d4 01          	cmpl   $0x1,-0x2c(%ebp)
 804a91f:	75 13                	jne    804a934 <ifree+0xe6>
                wrtwarning("page is already free.\n");
 804a921:	8d 83 de d9 ff ff    	lea    -0x2622(%ebx),%eax
 804a927:	89 04 24             	mov    %eax,(%esp)
 804a92a:	e8 f8 e7 ff ff       	call   8049127 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804a92f:	e9 f7 05 00 00       	jmp    804af2b <ifree+0x6dd>
        if (info == MALLOC_FREE) {
                wrtwarning("page is already free.\n");
                return;
        }

        if (info != MALLOC_FIRST) {
 804a934:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
 804a938:	74 13                	je     804a94d <ifree+0xff>
                wrtwarning("pointer to wrong page.\n");
 804a93a:	8d 83 c6 d9 ff ff    	lea    -0x263a(%ebx),%eax
 804a940:	89 04 24             	mov    %eax,(%esp)
 804a943:	e8 df e7 ff ff       	call   8049127 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804a948:	e9 de 05 00 00       	jmp    804af2b <ifree+0x6dd>
        if (info != MALLOC_FIRST) {
                wrtwarning("pointer to wrong page.\n");
                return;
        }

        if ((u_long)ptr & malloc_pagemask) {
 804a94d:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a950:	25 ff 0f 00 00       	and    $0xfff,%eax
 804a955:	85 c0                	test   %eax,%eax
 804a957:	74 13                	je     804a96c <ifree+0x11e>
                wrtwarning("modified (page-) pointer.\n");
 804a959:	8d 83 77 d9 ff ff    	lea    -0x2689(%ebx),%eax
 804a95f:	89 04 24             	mov    %eax,(%esp)
 804a962:	e8 c0 e7 ff ff       	call   8049127 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804a967:	e9 bf 05 00 00       	jmp    804af2b <ifree+0x6dd>
                wrtwarning("modified (page-) pointer.\n");
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
 804a96c:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 804a972:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804a975:	c1 e2 02             	shl    $0x2,%edx
 804a978:	01 d0                	add    %edx,%eax
 804a97a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804a980:	c7 45 cc 01 00 00 00 	movl   $0x1,-0x34(%ebp)
 804a987:	eb 1b                	jmp    804a9a4 <ifree+0x156>
                page_dir[index + i] = MALLOC_FREE;
 804a989:	8b 93 e0 00 00 00    	mov    0xe0(%ebx),%edx
 804a98f:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a992:	03 45 cc             	add    -0x34(%ebp),%eax
 804a995:	c1 e0 02             	shl    $0x2,%eax
 804a998:	01 d0                	add    %edx,%eax
 804a99a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804a9a0:	83 45 cc 01          	addl   $0x1,-0x34(%ebp)
 804a9a4:	8b 93 e0 00 00 00    	mov    0xe0(%ebx),%edx
 804a9aa:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a9ad:	03 45 cc             	add    -0x34(%ebp),%eax
 804a9b0:	c1 e0 02             	shl    $0x2,%eax
 804a9b3:	01 d0                	add    %edx,%eax
 804a9b5:	8b 00                	mov    (%eax),%eax
 804a9b7:	83 f8 03             	cmp    $0x3,%eax
 804a9ba:	74 cd                	je     804a989 <ifree+0x13b>
                page_dir[index + i] = MALLOC_FREE;

        l = i << malloc_pageshift;
 804a9bc:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804a9bf:	c1 e0 0c             	shl    $0xc,%eax
 804a9c2:	89 45 c8             	mov    %eax,-0x38(%ebp)

        if (malloc_junk)
 804a9c5:	8b 83 18 01 00 00    	mov    0x118(%ebx),%eax
 804a9cb:	85 c0                	test   %eax,%eax
 804a9cd:	74 1a                	je     804a9e9 <ifree+0x19b>
                memset(ptr, SOME_JUNK, l);
 804a9cf:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804a9d2:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a9d6:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804a9dd:	00 
 804a9de:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a9e1:	89 04 24             	mov    %eax,(%esp)
 804a9e4:	e8 8b 09 00 00       	call   804b374 <memset>
#ifdef HAS_MADVISE
        if (malloc_hint)
                madvise(ptr, l, MADV_FREE);
#endif

        tail = (char *)ptr + l;
 804a9e9:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804a9ec:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804a9ef:	01 d0                	add    %edx,%eax
 804a9f1:	89 45 c4             	mov    %eax,-0x3c(%ebp)

        /* add to free-list */
        if (!px)
 804a9f4:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804a9fa:	85 c0                	test   %eax,%eax
 804a9fc:	75 12                	jne    804aa10 <ifree+0x1c2>
                px = imalloc(sizeof * pt);      /* This cannot fail... */
 804a9fe:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 804aa05:	e8 f0 f4 ff ff       	call   8049efa <imalloc>
 804aa0a:	89 83 20 01 00 00    	mov    %eax,0x120(%ebx)
        px->page = ptr;
 804aa10:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804aa16:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804aa19:	89 50 08             	mov    %edx,0x8(%eax)
        px->end =  tail;
 804aa1c:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804aa22:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 804aa25:	89 50 0c             	mov    %edx,0xc(%eax)
        px->size = l;
 804aa28:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804aa2e:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804aa31:	89 50 10             	mov    %edx,0x10(%eax)
        if (!free_list.next) {
 804aa34:	8b 83 e8 00 00 00    	mov    0xe8(%ebx),%eax
 804aa3a:	85 c0                	test   %eax,%eax
 804aa3c:	75 41                	jne    804aa7f <ifree+0x231>

                /* Nothing on free list, put this at head */
                px->next = free_list.next;
 804aa3e:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804aa44:	8b 93 e8 00 00 00    	mov    0xe8(%ebx),%edx
 804aa4a:	89 10                	mov    %edx,(%eax)
                px->prev = &free_list;
 804aa4c:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804aa52:	8d 93 e8 00 00 00    	lea    0xe8(%ebx),%edx
 804aa58:	89 50 04             	mov    %edx,0x4(%eax)
                free_list.next = px;
 804aa5b:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804aa61:	89 83 e8 00 00 00    	mov    %eax,0xe8(%ebx)
                pf = px;
 804aa67:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804aa6d:	89 45 c0             	mov    %eax,-0x40(%ebp)
                px = 0;
 804aa70:	c7 83 20 01 00 00 00 	movl   $0x0,0x120(%ebx)
 804aa77:	00 00 00 
 804aa7a:	e9 a2 01 00 00       	jmp    804ac21 <ifree+0x3d3>

        } else {

                /* Find the right spot, leave pf pointing to the modified entry. */
                tail = (char *)ptr + l;
 804aa7f:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804aa82:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804aa85:	01 d0                	add    %edx,%eax
 804aa87:	89 45 c4             	mov    %eax,-0x3c(%ebp)

                for (pf = free_list.next; pf->end < ptr && pf->next; pf = pf->next)
 804aa8a:	8b 83 e8 00 00 00    	mov    0xe8(%ebx),%eax
 804aa90:	89 45 c0             	mov    %eax,-0x40(%ebp)
 804aa93:	eb 08                	jmp    804aa9d <ifree+0x24f>
 804aa95:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804aa98:	8b 00                	mov    (%eax),%eax
 804aa9a:	89 45 c0             	mov    %eax,-0x40(%ebp)
 804aa9d:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804aaa0:	8b 40 0c             	mov    0xc(%eax),%eax
 804aaa3:	39 45 dc             	cmp    %eax,-0x24(%ebp)
 804aaa6:	76 09                	jbe    804aab1 <ifree+0x263>
 804aaa8:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804aaab:	8b 00                	mov    (%eax),%eax
 804aaad:	85 c0                	test   %eax,%eax
 804aaaf:	75 e4                	jne    804aa95 <ifree+0x247>
                        ; /* Race ahead here */

                if (pf->page > tail) {
 804aab1:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804aab4:	8b 40 08             	mov    0x8(%eax),%eax
 804aab7:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
 804aaba:	73 4f                	jae    804ab0b <ifree+0x2bd>
                        /* Insert before entry */
                        px->next = pf;
 804aabc:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804aac2:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804aac5:	89 10                	mov    %edx,(%eax)
                        px->prev = pf->prev;
 804aac7:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804aacd:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804aad0:	8b 52 04             	mov    0x4(%edx),%edx
 804aad3:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev = px;
 804aad6:	8b 93 20 01 00 00    	mov    0x120(%ebx),%edx
 804aadc:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804aadf:	89 50 04             	mov    %edx,0x4(%eax)
                        px->prev->next = px;
 804aae2:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804aae8:	8b 40 04             	mov    0x4(%eax),%eax
 804aaeb:	8b 93 20 01 00 00    	mov    0x120(%ebx),%edx
 804aaf1:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804aaf3:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804aaf9:	89 45 c0             	mov    %eax,-0x40(%ebp)
                        px = 0;
 804aafc:	c7 83 20 01 00 00 00 	movl   $0x0,0x120(%ebx)
 804ab03:	00 00 00 
 804ab06:	e9 16 01 00 00       	jmp    804ac21 <ifree+0x3d3>
                } else if (pf->end == ptr) {
 804ab0b:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ab0e:	8b 40 0c             	mov    0xc(%eax),%eax
 804ab11:	39 45 dc             	cmp    %eax,-0x24(%ebp)
 804ab14:	0f 85 91 00 00 00    	jne    804abab <ifree+0x35d>
                        /* Append to the previous entry */
                        pf->end = (char *)pf->end + l;
 804ab1a:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ab1d:	8b 40 0c             	mov    0xc(%eax),%eax
 804ab20:	89 c2                	mov    %eax,%edx
 804ab22:	03 55 c8             	add    -0x38(%ebp),%edx
 804ab25:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ab28:	89 50 0c             	mov    %edx,0xc(%eax)
                        pf->size += l;
 804ab2b:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ab2e:	8b 40 10             	mov    0x10(%eax),%eax
 804ab31:	89 c2                	mov    %eax,%edx
 804ab33:	03 55 c8             	add    -0x38(%ebp),%edx
 804ab36:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ab39:	89 50 10             	mov    %edx,0x10(%eax)
                        if (pf->next && pf->end == pf->next->page) {
 804ab3c:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ab3f:	8b 00                	mov    (%eax),%eax
 804ab41:	85 c0                	test   %eax,%eax
 804ab43:	0f 84 d8 00 00 00    	je     804ac21 <ifree+0x3d3>
 804ab49:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ab4c:	8b 50 0c             	mov    0xc(%eax),%edx
 804ab4f:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ab52:	8b 00                	mov    (%eax),%eax
 804ab54:	8b 40 08             	mov    0x8(%eax),%eax
 804ab57:	39 c2                	cmp    %eax,%edx
 804ab59:	0f 85 c2 00 00 00    	jne    804ac21 <ifree+0x3d3>
                                /* And collapse the next too. */
                                pt = pf->next;
 804ab5f:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ab62:	8b 00                	mov    (%eax),%eax
 804ab64:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                pf->end = pt->end;
 804ab67:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804ab6a:	8b 50 0c             	mov    0xc(%eax),%edx
 804ab6d:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ab70:	89 50 0c             	mov    %edx,0xc(%eax)
                                pf->size += pt->size;
 804ab73:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ab76:	8b 50 10             	mov    0x10(%eax),%edx
 804ab79:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804ab7c:	8b 40 10             	mov    0x10(%eax),%eax
 804ab7f:	01 c2                	add    %eax,%edx
 804ab81:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ab84:	89 50 10             	mov    %edx,0x10(%eax)
                                pf->next = pt->next;
 804ab87:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804ab8a:	8b 10                	mov    (%eax),%edx
 804ab8c:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ab8f:	89 10                	mov    %edx,(%eax)
                                if (pf->next)
 804ab91:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ab94:	8b 00                	mov    (%eax),%eax
 804ab96:	85 c0                	test   %eax,%eax
 804ab98:	0f 84 83 00 00 00    	je     804ac21 <ifree+0x3d3>
                                        pf->next->prev = pf;
 804ab9e:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804aba1:	8b 00                	mov    (%eax),%eax
 804aba3:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804aba6:	89 50 04             	mov    %edx,0x4(%eax)
 804aba9:	eb 76                	jmp    804ac21 <ifree+0x3d3>
                        }
                } else if (pf->page == tail) {
 804abab:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804abae:	8b 40 08             	mov    0x8(%eax),%eax
 804abb1:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
 804abb4:	75 1c                	jne    804abd2 <ifree+0x384>
                        /* Prepend to entry */
                        pf->size += l;
 804abb6:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804abb9:	8b 40 10             	mov    0x10(%eax),%eax
 804abbc:	89 c2                	mov    %eax,%edx
 804abbe:	03 55 c8             	add    -0x38(%ebp),%edx
 804abc1:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804abc4:	89 50 10             	mov    %edx,0x10(%eax)
                        pf->page = ptr;
 804abc7:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804abca:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804abcd:	89 50 08             	mov    %edx,0x8(%eax)
 804abd0:	eb 4f                	jmp    804ac21 <ifree+0x3d3>
                } else if (!pf->next) {
 804abd2:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804abd5:	8b 00                	mov    (%eax),%eax
 804abd7:	85 c0                	test   %eax,%eax
 804abd9:	75 38                	jne    804ac13 <ifree+0x3c5>
                        /* Append at tail of chain */
                        px->next = 0;
 804abdb:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804abe1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                        px->prev = pf;
 804abe7:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804abed:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804abf0:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->next = px;
 804abf3:	8b 93 20 01 00 00    	mov    0x120(%ebx),%edx
 804abf9:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804abfc:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804abfe:	8b 83 20 01 00 00    	mov    0x120(%ebx),%eax
 804ac04:	89 45 c0             	mov    %eax,-0x40(%ebp)
                        px = 0;
 804ac07:	c7 83 20 01 00 00 00 	movl   $0x0,0x120(%ebx)
 804ac0e:	00 00 00 
 804ac11:	eb 0e                	jmp    804ac21 <ifree+0x3d3>
                } else {
                        wrterror("freelist is destroyed.\n");
 804ac13:	8d 83 f5 d9 ff ff    	lea    -0x260b(%ebx),%eax
 804ac19:	89 04 24             	mov    %eax,(%esp)
 804ac1c:	e8 3b e4 ff ff       	call   804905c <wrterror>
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804ac21:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ac24:	8b 00                	mov    (%eax),%eax
 804ac26:	85 c0                	test   %eax,%eax
 804ac28:	0f 85 cd 00 00 00    	jne    804acfb <ifree+0x4ad>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804ac2e:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ac31:	8b 50 10             	mov    0x10(%eax),%edx
 804ac34:	8b 83 0c 00 00 00    	mov    0xc(%ebx),%eax
                        wrterror("freelist is destroyed.\n");
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804ac3a:	39 c2                	cmp    %eax,%edx
 804ac3c:	0f 86 b9 00 00 00    	jbe    804acfb <ifree+0x4ad>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804ac42:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ac45:	8b 50 0c             	mov    0xc(%eax),%edx
 804ac48:	8b 83 1c 01 00 00    	mov    0x11c(%ebx),%eax
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804ac4e:	39 c2                	cmp    %eax,%edx
 804ac50:	0f 85 a5 00 00 00    	jne    804acfb <ifree+0x4ad>
            pf->end == malloc_brk &&                  /* ..and none behind us, */
            malloc_brk == sbrk(0)) {                  /* ..and it's OK to do... */
 804ac56:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804ac5d:	e8 ea d4 ff ff       	call   804814c <sbrk>
 804ac62:	8b 93 1c 01 00 00    	mov    0x11c(%ebx),%edx
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804ac68:	39 d0                	cmp    %edx,%eax
 804ac6a:	0f 85 8b 00 00 00    	jne    804acfb <ifree+0x4ad>

                /*
                 * Keep the cache intact.  Notice that the '>' above guarantees that
                 * the pf will always have at least one page afterwards.
                 */
                pf->end = (char *)pf->page + malloc_cache;
 804ac70:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ac73:	8b 50 08             	mov    0x8(%eax),%edx
 804ac76:	8b 83 0c 00 00 00    	mov    0xc(%ebx),%eax
 804ac7c:	01 c2                	add    %eax,%edx
 804ac7e:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ac81:	89 50 0c             	mov    %edx,0xc(%eax)
                pf->size = malloc_cache;
 804ac84:	8b 93 0c 00 00 00    	mov    0xc(%ebx),%edx
 804ac8a:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ac8d:	89 50 10             	mov    %edx,0x10(%eax)

                brk(pf->end);
 804ac90:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ac93:	8b 40 0c             	mov    0xc(%eax),%eax
 804ac96:	89 04 24             	mov    %eax,(%esp)
 804ac99:	e8 7e d5 ff ff       	call   804821c <brk>
                malloc_brk = pf->end;
 804ac9e:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804aca1:	8b 40 0c             	mov    0xc(%eax),%eax
 804aca4:	89 83 1c 01 00 00    	mov    %eax,0x11c(%ebx)

                index = ptr2index(pf->end);
 804acaa:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804acad:	8b 40 0c             	mov    0xc(%eax),%eax
 804acb0:	89 c2                	mov    %eax,%edx
 804acb2:	c1 ea 0c             	shr    $0xc,%edx
 804acb5:	8b 83 d8 00 00 00    	mov    0xd8(%ebx),%eax
 804acbb:	89 d6                	mov    %edx,%esi
 804acbd:	29 c6                	sub    %eax,%esi
 804acbf:	89 f0                	mov    %esi,%eax
 804acc1:	89 45 d8             	mov    %eax,-0x28(%ebp)
                last_index = index - 1;
 804acc4:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804acc7:	83 e8 01             	sub    $0x1,%eax
 804acca:	89 83 dc 00 00 00    	mov    %eax,0xdc(%ebx)

                for (i = index; i <= last_index;)
 804acd0:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804acd3:	89 45 cc             	mov    %eax,-0x34(%ebp)
 804acd6:	eb 18                	jmp    804acf0 <ifree+0x4a2>
                        page_dir[i++] = MALLOC_NOT_MINE;
 804acd8:	8b 83 e0 00 00 00    	mov    0xe0(%ebx),%eax
 804acde:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804ace1:	c1 e2 02             	shl    $0x2,%edx
 804ace4:	01 d0                	add    %edx,%eax
 804ace6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
 804acec:	83 45 cc 01          	addl   $0x1,-0x34(%ebp)
                malloc_brk = pf->end;

                index = ptr2index(pf->end);
                last_index = index - 1;

                for (i = index; i <= last_index;)
 804acf0:	8b 83 dc 00 00 00    	mov    0xdc(%ebx),%eax
 804acf6:	39 45 cc             	cmp    %eax,-0x34(%ebp)
 804acf9:	76 dd                	jbe    804acd8 <ifree+0x48a>
                        page_dir[i++] = MALLOC_NOT_MINE;

                /* XXX: We could realloc/shrink the pagedir here I guess. */
        }
        if (pt)
 804acfb:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804acff:	0f 84 26 02 00 00    	je     804af2b <ifree+0x6dd>
                ifree(pt);
 804ad05:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804ad08:	89 04 24             	mov    %eax,(%esp)
 804ad0b:	e8 3e fb ff ff       	call   804a84e <ifree>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804ad10:	e9 16 02 00 00       	jmp    804af2b <ifree+0x6dd>
        info = page_dir[index];

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
 804ad15:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804ad18:	8b 55 08             	mov    0x8(%ebp),%edx
 804ad1b:	89 55 bc             	mov    %edx,-0x44(%ebp)
 804ad1e:	89 45 a8             	mov    %eax,-0x58(%ebp)
 804ad21:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804ad24:	89 45 b8             	mov    %eax,-0x48(%ebp)
        int i;
        struct pginfo **mp;
        void *vp;

        /* Find the chunk number on the page */
        i = ((u_long)ptr & malloc_pagemask) >> info->shift;
 804ad27:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804ad2a:	89 c2                	mov    %eax,%edx
 804ad2c:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
 804ad32:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ad35:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804ad39:	0f b7 c0             	movzwl %ax,%eax
 804ad3c:	89 d6                	mov    %edx,%esi
 804ad3e:	89 c1                	mov    %eax,%ecx
 804ad40:	d3 ee                	shr    %cl,%esi
 804ad42:	89 f0                	mov    %esi,%eax
 804ad44:	89 45 b4             	mov    %eax,-0x4c(%ebp)

        if (((u_long)ptr & (info->size - 1))) {
 804ad47:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ad4a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804ad4e:	0f b7 c0             	movzwl %ax,%eax
 804ad51:	83 e8 01             	sub    $0x1,%eax
 804ad54:	89 c2                	mov    %eax,%edx
 804ad56:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804ad59:	21 d0                	and    %edx,%eax
 804ad5b:	85 c0                	test   %eax,%eax
 804ad5d:	74 13                	je     804ad72 <ifree+0x524>
                wrtwarning("modified (chunk-) pointer.\n");
 804ad5f:	8d 83 92 d9 ff ff    	lea    -0x266e(%ebx),%eax
 804ad65:	89 04 24             	mov    %eax,(%esp)
 804ad68:	e8 ba e3 ff ff       	call   8049127 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804ad6d:	e9 b9 01 00 00       	jmp    804af2b <ifree+0x6dd>
        if (((u_long)ptr & (info->size - 1))) {
                wrtwarning("modified (chunk-) pointer.\n");
                return;
        }

        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804ad72:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804ad75:	89 c2                	mov    %eax,%edx
 804ad77:	c1 ea 05             	shr    $0x5,%edx
 804ad7a:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ad7d:	83 c2 04             	add    $0x4,%edx
 804ad80:	8b 14 90             	mov    (%eax,%edx,4),%edx
 804ad83:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804ad86:	83 e0 1f             	and    $0x1f,%eax
 804ad89:	be 01 00 00 00       	mov    $0x1,%esi
 804ad8e:	89 f7                	mov    %esi,%edi
 804ad90:	89 c1                	mov    %eax,%ecx
 804ad92:	d3 e7                	shl    %cl,%edi
 804ad94:	89 f8                	mov    %edi,%eax
 804ad96:	21 d0                	and    %edx,%eax
 804ad98:	85 c0                	test   %eax,%eax
 804ad9a:	74 13                	je     804adaf <ifree+0x561>
                wrtwarning("chunk is already free.\n");
 804ad9c:	8d 83 ae d9 ff ff    	lea    -0x2652(%ebx),%eax
 804ada2:	89 04 24             	mov    %eax,(%esp)
 804ada5:	e8 7d e3 ff ff       	call   8049127 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804adaa:	e9 7c 01 00 00       	jmp    804af2b <ifree+0x6dd>
        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
                wrtwarning("chunk is already free.\n");
                return;
        }

        if (malloc_junk)
 804adaf:	8b 83 18 01 00 00    	mov    0x118(%ebx),%eax
 804adb5:	85 c0                	test   %eax,%eax
 804adb7:	74 21                	je     804adda <ifree+0x58c>
                memset(ptr, SOME_JUNK, info->size);
 804adb9:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804adbc:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804adc0:	0f b7 c0             	movzwl %ax,%eax
 804adc3:	89 44 24 08          	mov    %eax,0x8(%esp)
 804adc7:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804adce:	00 
 804adcf:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804add2:	89 04 24             	mov    %eax,(%esp)
 804add5:	e8 9a 05 00 00       	call   804b374 <memset>

        info->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804adda:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804addd:	c1 e8 05             	shr    $0x5,%eax
 804ade0:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804ade3:	8d 48 04             	lea    0x4(%eax),%ecx
 804ade6:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 804ade9:	8b 55 b4             	mov    -0x4c(%ebp),%edx
 804adec:	83 e2 1f             	and    $0x1f,%edx
 804adef:	c7 45 a4 01 00 00 00 	movl   $0x1,-0x5c(%ebp)
 804adf6:	8b 7d a4             	mov    -0x5c(%ebp),%edi
 804adf9:	89 d1                	mov    %edx,%ecx
 804adfb:	d3 e7                	shl    %cl,%edi
 804adfd:	89 fa                	mov    %edi,%edx
 804adff:	89 f1                	mov    %esi,%ecx
 804ae01:	09 d1                	or     %edx,%ecx
 804ae03:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804ae06:	83 c0 04             	add    $0x4,%eax
 804ae09:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
        info->free++;
 804ae0c:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ae0f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804ae13:	8d 50 01             	lea    0x1(%eax),%edx
 804ae16:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ae19:	66 89 50 0c          	mov    %dx,0xc(%eax)

        mp = page_dir + info->shift;
 804ae1d:	8b 93 e0 00 00 00    	mov    0xe0(%ebx),%edx
 804ae23:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ae26:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804ae2a:	0f b7 c0             	movzwl %ax,%eax
 804ae2d:	c1 e0 02             	shl    $0x2,%eax
 804ae30:	01 d0                	add    %edx,%eax
 804ae32:	89 45 b0             	mov    %eax,-0x50(%ebp)

        if (info->free == 1) {
 804ae35:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ae38:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804ae3c:	66 83 f8 01          	cmp    $0x1,%ax
 804ae40:	75 61                	jne    804aea3 <ifree+0x655>

                /* Page became non-full */

                mp = page_dir + info->shift;
 804ae42:	8b 93 e0 00 00 00    	mov    0xe0(%ebx),%edx
 804ae48:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ae4b:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804ae4f:	0f b7 c0             	movzwl %ax,%eax
 804ae52:	c1 e0 02             	shl    $0x2,%eax
 804ae55:	01 d0                	add    %edx,%eax
 804ae57:	89 45 b0             	mov    %eax,-0x50(%ebp)
 804ae5a:	eb 08                	jmp    804ae64 <ifree+0x616>
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
                        mp = &(*mp)->next;
 804ae5c:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804ae5f:	8b 00                	mov    (%eax),%eax
 804ae61:	89 45 b0             	mov    %eax,-0x50(%ebp)

                /* Page became non-full */

                mp = page_dir + info->shift;
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804ae64:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804ae67:	8b 00                	mov    (%eax),%eax
 804ae69:	85 c0                	test   %eax,%eax
 804ae6b:	74 1f                	je     804ae8c <ifree+0x63e>
 804ae6d:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804ae70:	8b 00                	mov    (%eax),%eax
 804ae72:	8b 00                	mov    (%eax),%eax
 804ae74:	85 c0                	test   %eax,%eax
 804ae76:	74 14                	je     804ae8c <ifree+0x63e>
 804ae78:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804ae7b:	8b 00                	mov    (%eax),%eax
 804ae7d:	8b 00                	mov    (%eax),%eax
 804ae7f:	8b 50 04             	mov    0x4(%eax),%edx
 804ae82:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ae85:	8b 40 04             	mov    0x4(%eax),%eax
 804ae88:	39 c2                	cmp    %eax,%edx
 804ae8a:	72 d0                	jb     804ae5c <ifree+0x60e>
                        mp = &(*mp)->next;
                info->next = *mp;
 804ae8c:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804ae8f:	8b 10                	mov    (%eax),%edx
 804ae91:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ae94:	89 10                	mov    %edx,(%eax)
                *mp = info;
 804ae96:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804ae99:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804ae9c:	89 10                	mov    %edx,(%eax)

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804ae9e:	e9 88 00 00 00       	jmp    804af2b <ifree+0x6dd>
                info->next = *mp;
                *mp = info;
                return;
        }

        if (info->free != info->total)
 804aea3:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804aea6:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804aeaa:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804aead:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804aeb1:	66 39 c2             	cmp    %ax,%dx
 804aeb4:	75 75                	jne    804af2b <ifree+0x6dd>
 804aeb6:	eb 08                	jmp    804aec0 <ifree+0x672>
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
                mp = &((*mp)->next);
 804aeb8:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804aebb:	8b 00                	mov    (%eax),%eax
 804aebd:	89 45 b0             	mov    %eax,-0x50(%ebp)

        if (info->free != info->total)
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
 804aec0:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804aec3:	8b 00                	mov    (%eax),%eax
 804aec5:	39 45 b8             	cmp    %eax,-0x48(%ebp)
 804aec8:	75 ee                	jne    804aeb8 <ifree+0x66a>
#ifdef EXTRA_SANITY
                if (!*mp)
                        wrterror("(ES): Not on queue\n");
#endif /* EXTRA_SANITY */
        }
        *mp = info->next;
 804aeca:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804aecd:	8b 10                	mov    (%eax),%edx
 804aecf:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804aed2:	89 10                	mov    %edx,(%eax)

        /* Free the page & the info structure if need be */
        page_dir[ptr2index(info->page)] = MALLOC_FIRST;
 804aed4:	8b 93 e0 00 00 00    	mov    0xe0(%ebx),%edx
 804aeda:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804aedd:	8b 40 04             	mov    0x4(%eax),%eax
 804aee0:	89 c1                	mov    %eax,%ecx
 804aee2:	c1 e9 0c             	shr    $0xc,%ecx
 804aee5:	8b 83 d8 00 00 00    	mov    0xd8(%ebx),%eax
 804aeeb:	89 ce                	mov    %ecx,%esi
 804aeed:	29 c6                	sub    %eax,%esi
 804aeef:	89 f0                	mov    %esi,%eax
 804aef1:	c1 e0 02             	shl    $0x2,%eax
 804aef4:	01 d0                	add    %edx,%eax
 804aef6:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        vp = info->page;            /* Order is important ! */
 804aefc:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804aeff:	8b 40 04             	mov    0x4(%eax),%eax
 804af02:	89 45 ac             	mov    %eax,-0x54(%ebp)
        if (vp != (void *)info)
 804af05:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804af08:	3b 45 ac             	cmp    -0x54(%ebp),%eax
 804af0b:	74 0b                	je     804af18 <ifree+0x6ca>
                ifree(info);
 804af0d:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804af10:	89 04 24             	mov    %eax,(%esp)
 804af13:	e8 36 f9 ff ff       	call   804a84e <ifree>
        ifree(vp);
 804af18:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804af1b:	89 04 24             	mov    %eax,(%esp)
 804af1e:	e8 2b f9 ff ff       	call   804a84e <ifree>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804af23:	eb 06                	jmp    804af2b <ifree+0x6dd>
        struct pginfo *info;
        unsigned int index;

        /* This is legal */
        if (!ptr)
                return;
 804af25:	90                   	nop
 804af26:	eb 04                	jmp    804af2c <ifree+0x6de>
                return;
        }

        /* If we're already sinking, don't make matters any worse. */
        if (suicide)
                return;
 804af28:	90                   	nop
 804af29:	eb 01                	jmp    804af2c <ifree+0x6de>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804af2b:	90                   	nop
}
 804af2c:	83 c4 6c             	add    $0x6c,%esp
 804af2f:	5b                   	pop    %ebx
 804af30:	5e                   	pop    %esi
 804af31:	5f                   	pop    %edi
 804af32:	5d                   	pop    %ebp
 804af33:	c3                   	ret    

0804af34 <malloc>:
 */


void *
malloc(size_t size)
{
 804af34:	55                   	push   %ebp
 804af35:	89 e5                	mov    %esp,%ebp
 804af37:	56                   	push   %esi
 804af38:	53                   	push   %ebx
 804af39:	83 ec 10             	sub    $0x10,%esp
 804af3c:	e8 16 e1 ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 804af41:	81 c3 d7 35 00 00    	add    $0x35d7,%ebx
        register void *r;

        THREAD_LOCK();
        malloc_func = " in malloc():";
 804af47:	8d 83 31 da ff ff    	lea    -0x25cf(%ebx),%eax
 804af4d:	89 83 24 01 00 00    	mov    %eax,0x124(%ebx)
        if (malloc_active++) {
 804af53:	8b 83 d4 00 00 00    	mov    0xd4(%ebx),%eax
 804af59:	85 c0                	test   %eax,%eax
 804af5b:	0f 95 c2             	setne  %dl
 804af5e:	83 c0 01             	add    $0x1,%eax
 804af61:	89 83 d4 00 00 00    	mov    %eax,0xd4(%ebx)
 804af67:	84 d2                	test   %dl,%dl
 804af69:	74 24                	je     804af8f <malloc+0x5b>
                wrtwarning("recursive call.\n");
 804af6b:	8d 83 3f da ff ff    	lea    -0x25c1(%ebx),%eax
 804af71:	89 04 24             	mov    %eax,(%esp)
 804af74:	e8 ae e1 ff ff       	call   8049127 <wrtwarning>
                malloc_active--;
 804af79:	8b 83 d4 00 00 00    	mov    0xd4(%ebx),%eax
 804af7f:	83 e8 01             	sub    $0x1,%eax
 804af82:	89 83 d4 00 00 00    	mov    %eax,0xd4(%ebx)
                return (0);
 804af88:	b8 00 00 00 00       	mov    $0x0,%eax
 804af8d:	eb 60                	jmp    804afef <malloc+0xbb>
        }
        if (!malloc_started) {
 804af8f:	8b 83 d0 00 00 00    	mov    0xd0(%ebx),%eax
 804af95:	85 c0                	test   %eax,%eax
 804af97:	75 05                	jne    804af9e <malloc+0x6a>
                malloc_init();
 804af99:	e8 db e3 ff ff       	call   8049379 <malloc_init>
        }
        if (malloc_sysv && !size)
 804af9e:	8b 83 10 01 00 00    	mov    0x110(%ebx),%eax
 804afa4:	85 c0                	test   %eax,%eax
 804afa6:	74 0d                	je     804afb5 <malloc+0x81>
 804afa8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804afac:	75 07                	jne    804afb5 <malloc+0x81>
                r = 0;
 804afae:	be 00 00 00 00       	mov    $0x0,%esi
 804afb3:	eb 0d                	jmp    804afc2 <malloc+0x8e>
        else
                r = imalloc(size);
 804afb5:	8b 45 08             	mov    0x8(%ebp),%eax
 804afb8:	89 04 24             	mov    %eax,(%esp)
 804afbb:	e8 3a ef ff ff       	call   8049efa <imalloc>
 804afc0:	89 c6                	mov    %eax,%esi
        UTRACE(0, size, r);
        malloc_active--;
 804afc2:	8b 83 d4 00 00 00    	mov    0xd4(%ebx),%eax
 804afc8:	83 e8 01             	sub    $0x1,%eax
 804afcb:	89 83 d4 00 00 00    	mov    %eax,0xd4(%ebx)
        THREAD_UNLOCK();
        if (malloc_xmalloc && !r)
 804afd1:	8b 83 0c 01 00 00    	mov    0x10c(%ebx),%eax
 804afd7:	85 c0                	test   %eax,%eax
 804afd9:	74 12                	je     804afed <malloc+0xb9>
 804afdb:	85 f6                	test   %esi,%esi
 804afdd:	75 0e                	jne    804afed <malloc+0xb9>
                wrterror("out of memory.\n");
 804afdf:	8d 83 50 da ff ff    	lea    -0x25b0(%ebx),%eax
 804afe5:	89 04 24             	mov    %eax,(%esp)
 804afe8:	e8 6f e0 ff ff       	call   804905c <wrterror>
        return (r);
 804afed:	89 f0                	mov    %esi,%eax
}
 804afef:	83 c4 10             	add    $0x10,%esp
 804aff2:	5b                   	pop    %ebx
 804aff3:	5e                   	pop    %esi
 804aff4:	5d                   	pop    %ebp
 804aff5:	c3                   	ret    

0804aff6 <free>:

void
free(void *ptr)
{
 804aff6:	55                   	push   %ebp
 804aff7:	89 e5                	mov    %esp,%ebp
 804aff9:	53                   	push   %ebx
 804affa:	83 ec 14             	sub    $0x14,%esp
 804affd:	e8 55 e0 ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 804b002:	81 c3 16 35 00 00    	add    $0x3516,%ebx
        THREAD_LOCK();
        malloc_func = " in free():";
 804b008:	8d 83 60 da ff ff    	lea    -0x25a0(%ebx),%eax
 804b00e:	89 83 24 01 00 00    	mov    %eax,0x124(%ebx)
        if (malloc_active++) {
 804b014:	8b 83 d4 00 00 00    	mov    0xd4(%ebx),%eax
 804b01a:	85 c0                	test   %eax,%eax
 804b01c:	0f 95 c2             	setne  %dl
 804b01f:	83 c0 01             	add    $0x1,%eax
 804b022:	89 83 d4 00 00 00    	mov    %eax,0xd4(%ebx)
 804b028:	84 d2                	test   %dl,%dl
 804b02a:	74 1f                	je     804b04b <free+0x55>
                wrtwarning("recursive call.\n");
 804b02c:	8d 83 3f da ff ff    	lea    -0x25c1(%ebx),%eax
 804b032:	89 04 24             	mov    %eax,(%esp)
 804b035:	e8 ed e0 ff ff       	call   8049127 <wrtwarning>
                malloc_active--;
 804b03a:	8b 83 d4 00 00 00    	mov    0xd4(%ebx),%eax
 804b040:	83 e8 01             	sub    $0x1,%eax
 804b043:	89 83 d4 00 00 00    	mov    %eax,0xd4(%ebx)
                return;
 804b049:	eb 1b                	jmp    804b066 <free+0x70>
        } else {
                ifree(ptr);
 804b04b:	8b 45 08             	mov    0x8(%ebp),%eax
 804b04e:	89 04 24             	mov    %eax,(%esp)
 804b051:	e8 f8 f7 ff ff       	call   804a84e <ifree>
                UTRACE(ptr, 0, 0);
        }
        malloc_active--;
 804b056:	8b 83 d4 00 00 00    	mov    0xd4(%ebx),%eax
 804b05c:	83 e8 01             	sub    $0x1,%eax
 804b05f:	89 83 d4 00 00 00    	mov    %eax,0xd4(%ebx)
        THREAD_UNLOCK();
        return;
 804b065:	90                   	nop
}
 804b066:	83 c4 14             	add    $0x14,%esp
 804b069:	5b                   	pop    %ebx
 804b06a:	5d                   	pop    %ebp
 804b06b:	c3                   	ret    

0804b06c <realloc>:

void *
realloc(void *ptr, size_t size)
{
 804b06c:	55                   	push   %ebp
 804b06d:	89 e5                	mov    %esp,%ebp
 804b06f:	56                   	push   %esi
 804b070:	53                   	push   %ebx
 804b071:	83 ec 10             	sub    $0x10,%esp
 804b074:	e8 de df ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 804b079:	81 c3 9f 34 00 00    	add    $0x349f,%ebx
        register void *r;

        THREAD_LOCK();
        malloc_func = " in realloc():";
 804b07f:	8d 83 6c da ff ff    	lea    -0x2594(%ebx),%eax
 804b085:	89 83 24 01 00 00    	mov    %eax,0x124(%ebx)
        if (malloc_active++) {
 804b08b:	8b 83 d4 00 00 00    	mov    0xd4(%ebx),%eax
 804b091:	85 c0                	test   %eax,%eax
 804b093:	0f 95 c2             	setne  %dl
 804b096:	83 c0 01             	add    $0x1,%eax
 804b099:	89 83 d4 00 00 00    	mov    %eax,0xd4(%ebx)
 804b09f:	84 d2                	test   %dl,%dl
 804b0a1:	74 27                	je     804b0ca <realloc+0x5e>
                wrtwarning("recursive call.\n");
 804b0a3:	8d 83 3f da ff ff    	lea    -0x25c1(%ebx),%eax
 804b0a9:	89 04 24             	mov    %eax,(%esp)
 804b0ac:	e8 76 e0 ff ff       	call   8049127 <wrtwarning>
                malloc_active--;
 804b0b1:	8b 83 d4 00 00 00    	mov    0xd4(%ebx),%eax
 804b0b7:	83 e8 01             	sub    $0x1,%eax
 804b0ba:	89 83 d4 00 00 00    	mov    %eax,0xd4(%ebx)
                return (0);
 804b0c0:	b8 00 00 00 00       	mov    $0x0,%eax
 804b0c5:	e9 ac 00 00 00       	jmp    804b176 <realloc+0x10a>
        }
        if (ptr && !malloc_started) {
 804b0ca:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804b0ce:	74 1f                	je     804b0ef <realloc+0x83>
 804b0d0:	8b 83 d0 00 00 00    	mov    0xd0(%ebx),%eax
 804b0d6:	85 c0                	test   %eax,%eax
 804b0d8:	75 15                	jne    804b0ef <realloc+0x83>
                wrtwarning("malloc() has never been called.\n");
 804b0da:	8d 83 10 da ff ff    	lea    -0x25f0(%ebx),%eax
 804b0e0:	89 04 24             	mov    %eax,(%esp)
 804b0e3:	e8 3f e0 ff ff       	call   8049127 <wrtwarning>
                ptr = 0;
 804b0e8:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        }
        if (!malloc_started)
 804b0ef:	8b 83 d0 00 00 00    	mov    0xd0(%ebx),%eax
 804b0f5:	85 c0                	test   %eax,%eax
 804b0f7:	75 05                	jne    804b0fe <realloc+0x92>
                malloc_init();
 804b0f9:	e8 7b e2 ff ff       	call   8049379 <malloc_init>
        if (malloc_sysv && !size) {
 804b0fe:	8b 83 10 01 00 00    	mov    0x110(%ebx),%eax
 804b104:	85 c0                	test   %eax,%eax
 804b106:	74 18                	je     804b120 <realloc+0xb4>
 804b108:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b10c:	75 12                	jne    804b120 <realloc+0xb4>
                ifree(ptr);
 804b10e:	8b 45 08             	mov    0x8(%ebp),%eax
 804b111:	89 04 24             	mov    %eax,(%esp)
 804b114:	e8 35 f7 ff ff       	call   804a84e <ifree>
                r = 0;
 804b119:	be 00 00 00 00       	mov    $0x0,%esi
 804b11e:	eb 29                	jmp    804b149 <realloc+0xdd>
        } else if (!ptr) {
 804b120:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804b124:	75 0f                	jne    804b135 <realloc+0xc9>
                r = imalloc(size);
 804b126:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b129:	89 04 24             	mov    %eax,(%esp)
 804b12c:	e8 c9 ed ff ff       	call   8049efa <imalloc>
 804b131:	89 c6                	mov    %eax,%esi
 804b133:	eb 14                	jmp    804b149 <realloc+0xdd>
        } else {
                r = irealloc(ptr, size);
 804b135:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b138:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b13c:	8b 45 08             	mov    0x8(%ebp),%eax
 804b13f:	89 04 24             	mov    %eax,(%esp)
 804b142:	e8 69 ee ff ff       	call   8049fb0 <irealloc>
 804b147:	89 c6                	mov    %eax,%esi
        }
        UTRACE(ptr, size, r);
        malloc_active--;
 804b149:	8b 83 d4 00 00 00    	mov    0xd4(%ebx),%eax
 804b14f:	83 e8 01             	sub    $0x1,%eax
 804b152:	89 83 d4 00 00 00    	mov    %eax,0xd4(%ebx)
        THREAD_UNLOCK();
        if (malloc_xmalloc && !r)
 804b158:	8b 83 0c 01 00 00    	mov    0x10c(%ebx),%eax
 804b15e:	85 c0                	test   %eax,%eax
 804b160:	74 12                	je     804b174 <realloc+0x108>
 804b162:	85 f6                	test   %esi,%esi
 804b164:	75 0e                	jne    804b174 <realloc+0x108>
                wrterror("out of memory.\n");
 804b166:	8d 83 50 da ff ff    	lea    -0x25b0(%ebx),%eax
 804b16c:	89 04 24             	mov    %eax,(%esp)
 804b16f:	e8 e8 de ff ff       	call   804905c <wrterror>
        return (r);
 804b174:	89 f0                	mov    %esi,%eax
}
 804b176:	83 c4 10             	add    $0x10,%esp
 804b179:	5b                   	pop    %ebx
 804b17a:	5e                   	pop    %esi
 804b17b:	5d                   	pop    %ebp
 804b17c:	c3                   	ret    

0804b17d <calloc>:

/* Added */
void *calloc(size_t nelem, size_t elsize)
{
 804b17d:	55                   	push   %ebp
 804b17e:	89 e5                	mov    %esp,%ebp
 804b180:	53                   	push   %ebx
 804b181:	83 ec 24             	sub    $0x24,%esp
 804b184:	e8 ce de ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 804b189:	81 c3 8f 33 00 00    	add    $0x338f,%ebx
        void *tmp;
        if (NULL == (tmp = malloc(nelem * elsize))) {
 804b18f:	8b 45 08             	mov    0x8(%ebp),%eax
 804b192:	0f af 45 0c          	imul   0xc(%ebp),%eax
 804b196:	89 04 24             	mov    %eax,(%esp)
 804b199:	e8 96 fd ff ff       	call   804af34 <malloc>
 804b19e:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b1a1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804b1a5:	75 07                	jne    804b1ae <calloc+0x31>
                return NULL;
 804b1a7:	b8 00 00 00 00       	mov    $0x0,%eax
 804b1ac:	eb 21                	jmp    804b1cf <calloc+0x52>
        } else {
                memset(tmp, 0, nelem * elsize);
 804b1ae:	8b 45 08             	mov    0x8(%ebp),%eax
 804b1b1:	0f af 45 0c          	imul   0xc(%ebp),%eax
 804b1b5:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b1b9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804b1c0:	00 
 804b1c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b1c4:	89 04 24             	mov    %eax,(%esp)
 804b1c7:	e8 a8 01 00 00       	call   804b374 <memset>
                return tmp;
 804b1cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
        }
}
 804b1cf:	83 c4 24             	add    $0x24,%esp
 804b1d2:	5b                   	pop    %ebx
 804b1d3:	5d                   	pop    %ebp
 804b1d4:	c3                   	ret    
 804b1d5:	90                   	nop
 804b1d6:	90                   	nop
 804b1d7:	90                   	nop

0804b1d8 <memcmp>:
#include "stdlib.h"
#include "string.h"
#include "errno.h"

int memcmp(const void *cs, const void *ct, size_t count)
{
 804b1d8:	55                   	push   %ebp
 804b1d9:	89 e5                	mov    %esp,%ebp
 804b1db:	83 ec 10             	sub    $0x10,%esp
        const unsigned char *su1, *su2;
        signed char res = 0;
 804b1de:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

        for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
 804b1e2:	8b 45 08             	mov    0x8(%ebp),%eax
 804b1e5:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804b1e8:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b1eb:	89 45 f8             	mov    %eax,-0x8(%ebp)
 804b1ee:	eb 27                	jmp    804b217 <memcmp+0x3f>
                if ((res = *su1 - *su2) != 0)
 804b1f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804b1f3:	0f b6 10             	movzbl (%eax),%edx
 804b1f6:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804b1f9:	0f b6 00             	movzbl (%eax),%eax
 804b1fc:	89 d1                	mov    %edx,%ecx
 804b1fe:	28 c1                	sub    %al,%cl
 804b200:	89 c8                	mov    %ecx,%eax
 804b202:	88 45 f7             	mov    %al,-0x9(%ebp)
 804b205:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
 804b209:	75 14                	jne    804b21f <memcmp+0x47>
int memcmp(const void *cs, const void *ct, size_t count)
{
        const unsigned char *su1, *su2;
        signed char res = 0;

        for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
 804b20b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804b20f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
 804b213:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
 804b217:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804b21b:	75 d3                	jne    804b1f0 <memcmp+0x18>
 804b21d:	eb 01                	jmp    804b220 <memcmp+0x48>
                if ((res = *su1 - *su2) != 0)
                        break;
 804b21f:	90                   	nop
        return res;
 804b220:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
}
 804b224:	c9                   	leave  
 804b225:	c3                   	ret    

0804b226 <memcpy>:

void *memcpy(void *dest, const void *src, size_t count)
{
 804b226:	55                   	push   %ebp
 804b227:	89 e5                	mov    %esp,%ebp
 804b229:	83 ec 10             	sub    $0x10,%esp
        char *tmp = (char *) dest;
 804b22c:	8b 45 08             	mov    0x8(%ebp),%eax
 804b22f:	89 45 fc             	mov    %eax,-0x4(%ebp)
        const char *s = src;
 804b232:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b235:	89 45 f8             	mov    %eax,-0x8(%ebp)

        while (count--)
 804b238:	eb 13                	jmp    804b24d <memcpy+0x27>
                *tmp++ = *s++;
 804b23a:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804b23d:	0f b6 10             	movzbl (%eax),%edx
 804b240:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804b243:	88 10                	mov    %dl,(%eax)
 804b245:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804b249:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
void *memcpy(void *dest, const void *src, size_t count)
{
        char *tmp = (char *) dest;
        const char *s = src;

        while (count--)
 804b24d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804b251:	0f 95 c0             	setne  %al
 804b254:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
 804b258:	84 c0                	test   %al,%al
 804b25a:	75 de                	jne    804b23a <memcpy+0x14>
                *tmp++ = *s++;

        return dest;
 804b25c:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804b25f:	c9                   	leave  
 804b260:	c3                   	ret    

0804b261 <strncmp>:

int strncmp(const char *cs, const char *ct, size_t count)
{
 804b261:	55                   	push   %ebp
 804b262:	89 e5                	mov    %esp,%ebp
 804b264:	56                   	push   %esi
        register signed char __res = 0;
 804b265:	be 00 00 00 00       	mov    $0x0,%esi

        while (count) {
 804b26a:	eb 3c                	jmp    804b2a8 <strncmp+0x47>
                if ((__res = *cs - *ct++) != 0 || !*cs++)
 804b26c:	8b 45 08             	mov    0x8(%ebp),%eax
 804b26f:	0f b6 00             	movzbl (%eax),%eax
 804b272:	89 c2                	mov    %eax,%edx
 804b274:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b277:	0f b6 00             	movzbl (%eax),%eax
 804b27a:	89 d1                	mov    %edx,%ecx
 804b27c:	28 c1                	sub    %al,%cl
 804b27e:	89 c8                	mov    %ecx,%eax
 804b280:	89 c6                	mov    %eax,%esi
 804b282:	89 f0                	mov    %esi,%eax
 804b284:	84 c0                	test   %al,%al
 804b286:	0f 95 c0             	setne  %al
 804b289:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
 804b28d:	84 c0                	test   %al,%al
 804b28f:	75 1d                	jne    804b2ae <strncmp+0x4d>
 804b291:	8b 45 08             	mov    0x8(%ebp),%eax
 804b294:	0f b6 00             	movzbl (%eax),%eax
 804b297:	84 c0                	test   %al,%al
 804b299:	0f 94 c0             	sete   %al
 804b29c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804b2a0:	84 c0                	test   %al,%al
 804b2a2:	75 0a                	jne    804b2ae <strncmp+0x4d>
                        break;
                count--;
 804b2a4:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

int strncmp(const char *cs, const char *ct, size_t count)
{
        register signed char __res = 0;

        while (count) {
 804b2a8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804b2ac:	75 be                	jne    804b26c <strncmp+0xb>
                if ((__res = *cs - *ct++) != 0 || !*cs++)
                        break;
                count--;
        }

        return __res;
 804b2ae:	89 f2                	mov    %esi,%edx
 804b2b0:	0f be c2             	movsbl %dl,%eax
}
 804b2b3:	5e                   	pop    %esi
 804b2b4:	5d                   	pop    %ebp
 804b2b5:	c3                   	ret    

0804b2b6 <strcmp>:

int strcmp(const char *cs, const char *ct)
{
 804b2b6:	55                   	push   %ebp
 804b2b7:	89 e5                	mov    %esp,%ebp
 804b2b9:	56                   	push   %esi
 804b2ba:	eb 01                	jmp    804b2bd <strcmp+0x7>
        register signed char __res;

        while (1) {
                if ((__res = *cs - *ct++) != 0 || !*cs++)
                        break;
        }
 804b2bc:	90                   	nop
int strcmp(const char *cs, const char *ct)
{
        register signed char __res;

        while (1) {
                if ((__res = *cs - *ct++) != 0 || !*cs++)
 804b2bd:	8b 45 08             	mov    0x8(%ebp),%eax
 804b2c0:	0f b6 00             	movzbl (%eax),%eax
 804b2c3:	89 c2                	mov    %eax,%edx
 804b2c5:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b2c8:	0f b6 00             	movzbl (%eax),%eax
 804b2cb:	89 d1                	mov    %edx,%ecx
 804b2cd:	28 c1                	sub    %al,%cl
 804b2cf:	89 c8                	mov    %ecx,%eax
 804b2d1:	89 c6                	mov    %eax,%esi
 804b2d3:	89 f0                	mov    %esi,%eax
 804b2d5:	84 c0                	test   %al,%al
 804b2d7:	0f 95 c0             	setne  %al
 804b2da:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
 804b2de:	84 c0                	test   %al,%al
 804b2e0:	75 13                	jne    804b2f5 <strcmp+0x3f>
 804b2e2:	8b 45 08             	mov    0x8(%ebp),%eax
 804b2e5:	0f b6 00             	movzbl (%eax),%eax
 804b2e8:	84 c0                	test   %al,%al
 804b2ea:	0f 94 c0             	sete   %al
 804b2ed:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804b2f1:	84 c0                	test   %al,%al
 804b2f3:	74 c7                	je     804b2bc <strcmp+0x6>
                        break;
        }

        return __res;
 804b2f5:	89 f2                	mov    %esi,%edx
 804b2f7:	0f be c2             	movsbl %dl,%eax
}
 804b2fa:	5e                   	pop    %esi
 804b2fb:	5d                   	pop    %ebp
 804b2fc:	c3                   	ret    

0804b2fd <strcpy>:

char *strcpy(char *dest, const char *src)
{
 804b2fd:	55                   	push   %ebp
 804b2fe:	89 e5                	mov    %esp,%ebp
 804b300:	83 ec 10             	sub    $0x10,%esp
        char *tmp = dest;
 804b303:	8b 45 08             	mov    0x8(%ebp),%eax
 804b306:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while ((*dest++ = *src++) != '\0')
 804b309:	90                   	nop
 804b30a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b30d:	0f b6 10             	movzbl (%eax),%edx
 804b310:	8b 45 08             	mov    0x8(%ebp),%eax
 804b313:	88 10                	mov    %dl,(%eax)
 804b315:	8b 45 08             	mov    0x8(%ebp),%eax
 804b318:	0f b6 00             	movzbl (%eax),%eax
 804b31b:	84 c0                	test   %al,%al
 804b31d:	0f 95 c0             	setne  %al
 804b320:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804b324:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
 804b328:	84 c0                	test   %al,%al
 804b32a:	75 de                	jne    804b30a <strcpy+0xd>
                /* nothing */;
        return tmp;
 804b32c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804b32f:	c9                   	leave  
 804b330:	c3                   	ret    

0804b331 <strncpy>:

char *strncpy(char *dest, const char *src, size_t count)
{
 804b331:	55                   	push   %ebp
 804b332:	89 e5                	mov    %esp,%ebp
 804b334:	83 ec 10             	sub    $0x10,%esp
        char *tmp = dest;
 804b337:	8b 45 08             	mov    0x8(%ebp),%eax
 804b33a:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (count-- && (*dest++ = *src++) != '\0')
 804b33d:	90                   	nop
 804b33e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804b342:	0f 95 c0             	setne  %al
 804b345:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
 804b349:	84 c0                	test   %al,%al
 804b34b:	74 22                	je     804b36f <strncpy+0x3e>
 804b34d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b350:	0f b6 10             	movzbl (%eax),%edx
 804b353:	8b 45 08             	mov    0x8(%ebp),%eax
 804b356:	88 10                	mov    %dl,(%eax)
 804b358:	8b 45 08             	mov    0x8(%ebp),%eax
 804b35b:	0f b6 00             	movzbl (%eax),%eax
 804b35e:	84 c0                	test   %al,%al
 804b360:	0f 95 c0             	setne  %al
 804b363:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804b367:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
 804b36b:	84 c0                	test   %al,%al
 804b36d:	75 cf                	jne    804b33e <strncpy+0xd>
                /* nothing */;

        return tmp;
 804b36f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804b372:	c9                   	leave  
 804b373:	c3                   	ret    

0804b374 <memset>:

void *memset(void *s, int c, size_t count)
{
 804b374:	55                   	push   %ebp
 804b375:	89 e5                	mov    %esp,%ebp
 804b377:	83 ec 10             	sub    $0x10,%esp
        char *xs = (char *) s;
 804b37a:	8b 45 08             	mov    0x8(%ebp),%eax
 804b37d:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (count--)
 804b380:	eb 0e                	jmp    804b390 <memset+0x1c>
                *xs++ = c;
 804b382:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b385:	89 c2                	mov    %eax,%edx
 804b387:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804b38a:	88 10                	mov    %dl,(%eax)
 804b38c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)

void *memset(void *s, int c, size_t count)
{
        char *xs = (char *) s;

        while (count--)
 804b390:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804b394:	0f 95 c0             	setne  %al
 804b397:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
 804b39b:	84 c0                	test   %al,%al
 804b39d:	75 e3                	jne    804b382 <memset+0xe>
                *xs++ = c;

        return s;
 804b39f:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804b3a2:	c9                   	leave  
 804b3a3:	c3                   	ret    

0804b3a4 <strnlen>:

size_t strnlen(const char *s, size_t count)
{
 804b3a4:	55                   	push   %ebp
 804b3a5:	89 e5                	mov    %esp,%ebp
 804b3a7:	83 ec 10             	sub    $0x10,%esp
        const char *sc;

        for (sc = s; count-- && *sc != '\0'; ++sc)
 804b3aa:	8b 45 08             	mov    0x8(%ebp),%eax
 804b3ad:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804b3b0:	eb 04                	jmp    804b3b6 <strnlen+0x12>
 804b3b2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804b3b6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b3ba:	0f 95 c0             	setne  %al
 804b3bd:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
 804b3c1:	84 c0                	test   %al,%al
 804b3c3:	74 0a                	je     804b3cf <strnlen+0x2b>
 804b3c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804b3c8:	0f b6 00             	movzbl (%eax),%eax
 804b3cb:	84 c0                	test   %al,%al
 804b3cd:	75 e3                	jne    804b3b2 <strnlen+0xe>
                /* nothing */;
        return sc - s;
 804b3cf:	8b 55 fc             	mov    -0x4(%ebp),%edx
 804b3d2:	8b 45 08             	mov    0x8(%ebp),%eax
 804b3d5:	89 d1                	mov    %edx,%ecx
 804b3d7:	29 c1                	sub    %eax,%ecx
 804b3d9:	89 c8                	mov    %ecx,%eax
}
 804b3db:	c9                   	leave  
 804b3dc:	c3                   	ret    

0804b3dd <strcat>:


char *strcat(char *dest, const char *src)
{
 804b3dd:	55                   	push   %ebp
 804b3de:	89 e5                	mov    %esp,%ebp
 804b3e0:	83 ec 10             	sub    $0x10,%esp
        char *tmp = dest;
 804b3e3:	8b 45 08             	mov    0x8(%ebp),%eax
 804b3e6:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (*dest)
 804b3e9:	eb 04                	jmp    804b3ef <strcat+0x12>
                dest++;
 804b3eb:	83 45 08 01          	addl   $0x1,0x8(%ebp)

char *strcat(char *dest, const char *src)
{
        char *tmp = dest;

        while (*dest)
 804b3ef:	8b 45 08             	mov    0x8(%ebp),%eax
 804b3f2:	0f b6 00             	movzbl (%eax),%eax
 804b3f5:	84 c0                	test   %al,%al
 804b3f7:	75 f2                	jne    804b3eb <strcat+0xe>
                dest++;

        while ((*dest++ = *src++) != '\0');
 804b3f9:	90                   	nop
 804b3fa:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b3fd:	0f b6 10             	movzbl (%eax),%edx
 804b400:	8b 45 08             	mov    0x8(%ebp),%eax
 804b403:	88 10                	mov    %dl,(%eax)
 804b405:	8b 45 08             	mov    0x8(%ebp),%eax
 804b408:	0f b6 00             	movzbl (%eax),%eax
 804b40b:	84 c0                	test   %al,%al
 804b40d:	0f 95 c0             	setne  %al
 804b410:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804b414:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
 804b418:	84 c0                	test   %al,%al
 804b41a:	75 de                	jne    804b3fa <strcat+0x1d>

        return tmp;
 804b41c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804b41f:	c9                   	leave  
 804b420:	c3                   	ret    

0804b421 <strlen>:

size_t strlen(const char *s)
{
 804b421:	55                   	push   %ebp
 804b422:	89 e5                	mov    %esp,%ebp
 804b424:	83 ec 10             	sub    $0x10,%esp
        const char *sc;

        for (sc = s; *sc != '\0'; ++sc)
 804b427:	8b 45 08             	mov    0x8(%ebp),%eax
 804b42a:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804b42d:	eb 04                	jmp    804b433 <strlen+0x12>
 804b42f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804b433:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804b436:	0f b6 00             	movzbl (%eax),%eax
 804b439:	84 c0                	test   %al,%al
 804b43b:	75 f2                	jne    804b42f <strlen+0xe>
                /* nothing */;
        return sc - s;
 804b43d:	8b 55 fc             	mov    -0x4(%ebp),%edx
 804b440:	8b 45 08             	mov    0x8(%ebp),%eax
 804b443:	89 d1                	mov    %edx,%ecx
 804b445:	29 c1                	sub    %eax,%ecx
 804b447:	89 c8                	mov    %ecx,%eax
}
 804b449:	c9                   	leave  
 804b44a:	c3                   	ret    

0804b44b <strchr>:

char *strchr(const char *s, int c)
{
 804b44b:	55                   	push   %ebp
 804b44c:	89 e5                	mov    %esp,%ebp
        for (; *s != (char) c; ++s)
 804b44e:	eb 15                	jmp    804b465 <strchr+0x1a>
                if (*s == '\0')
 804b450:	8b 45 08             	mov    0x8(%ebp),%eax
 804b453:	0f b6 00             	movzbl (%eax),%eax
 804b456:	84 c0                	test   %al,%al
 804b458:	75 07                	jne    804b461 <strchr+0x16>
                        return NULL;
 804b45a:	b8 00 00 00 00       	mov    $0x0,%eax
 804b45f:	eb 14                	jmp    804b475 <strchr+0x2a>
        return sc - s;
}

char *strchr(const char *s, int c)
{
        for (; *s != (char) c; ++s)
 804b461:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804b465:	8b 45 08             	mov    0x8(%ebp),%eax
 804b468:	0f b6 10             	movzbl (%eax),%edx
 804b46b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b46e:	38 c2                	cmp    %al,%dl
 804b470:	75 de                	jne    804b450 <strchr+0x5>
                if (*s == '\0')
                        return NULL;
        return (char *)s;
 804b472:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804b475:	5d                   	pop    %ebp
 804b476:	c3                   	ret    

0804b477 <strrchr>:

char *strrchr(const char *s, int c)
{
 804b477:	55                   	push   %ebp
 804b478:	89 e5                	mov    %esp,%ebp
 804b47a:	83 ec 10             	sub    $0x10,%esp
        char *r = NULL;
 804b47d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
        for (; *s; ++s)
 804b484:	eb 17                	jmp    804b49d <strrchr+0x26>
                if (*s == (char)c)
 804b486:	8b 45 08             	mov    0x8(%ebp),%eax
 804b489:	0f b6 10             	movzbl (%eax),%edx
 804b48c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b48f:	38 c2                	cmp    %al,%dl
 804b491:	75 06                	jne    804b499 <strrchr+0x22>
                        r = (char *)s;
 804b493:	8b 45 08             	mov    0x8(%ebp),%eax
 804b496:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

char *strrchr(const char *s, int c)
{
        char *r = NULL;
        for (; *s; ++s)
 804b499:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804b49d:	8b 45 08             	mov    0x8(%ebp),%eax
 804b4a0:	0f b6 00             	movzbl (%eax),%eax
 804b4a3:	84 c0                	test   %al,%al
 804b4a5:	75 df                	jne    804b486 <strrchr+0xf>
                if (*s == (char)c)
                        r = (char *)s;
        return r;
 804b4a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804b4aa:	c9                   	leave  
 804b4ab:	c3                   	ret    

0804b4ac <strstr>:

char *strstr(const char *s1, const char *s2)
{
 804b4ac:	55                   	push   %ebp
 804b4ad:	89 e5                	mov    %esp,%ebp
 804b4af:	53                   	push   %ebx
 804b4b0:	83 ec 24             	sub    $0x24,%esp
 804b4b3:	e8 9f db ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 804b4b8:	81 c3 60 30 00 00    	add    $0x3060,%ebx
        int l1, l2;

        l2 = strlen(s2);
 804b4be:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b4c1:	89 04 24             	mov    %eax,(%esp)
 804b4c4:	e8 58 ff ff ff       	call   804b421 <strlen>
 804b4c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (!l2)
 804b4cc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804b4d0:	75 05                	jne    804b4d7 <strstr+0x2b>
                return (char *) s1;
 804b4d2:	8b 45 08             	mov    0x8(%ebp),%eax
 804b4d5:	eb 47                	jmp    804b51e <strstr+0x72>
        l1 = strlen(s1);
 804b4d7:	8b 45 08             	mov    0x8(%ebp),%eax
 804b4da:	89 04 24             	mov    %eax,(%esp)
 804b4dd:	e8 3f ff ff ff       	call   804b421 <strlen>
 804b4e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
        while (l1 >= l2) {
 804b4e5:	eb 2a                	jmp    804b511 <strstr+0x65>
                l1--;
 804b4e7:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
                if (!memcmp(s1, s2, l2))
 804b4eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b4ee:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b4f2:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b4f5:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b4f9:	8b 45 08             	mov    0x8(%ebp),%eax
 804b4fc:	89 04 24             	mov    %eax,(%esp)
 804b4ff:	e8 d4 fc ff ff       	call   804b1d8 <memcmp>
 804b504:	85 c0                	test   %eax,%eax
 804b506:	75 05                	jne    804b50d <strstr+0x61>
                        return (char *) s1;
 804b508:	8b 45 08             	mov    0x8(%ebp),%eax
 804b50b:	eb 11                	jmp    804b51e <strstr+0x72>
                s1++;
 804b50d:	83 45 08 01          	addl   $0x1,0x8(%ebp)

        l2 = strlen(s2);
        if (!l2)
                return (char *) s1;
        l1 = strlen(s1);
        while (l1 >= l2) {
 804b511:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b514:	3b 45 f0             	cmp    -0x10(%ebp),%eax
 804b517:	7d ce                	jge    804b4e7 <strstr+0x3b>
                l1--;
                if (!memcmp(s1, s2, l2))
                        return (char *) s1;
                s1++;
        }
        return NULL;
 804b519:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804b51e:	83 c4 24             	add    $0x24,%esp
 804b521:	5b                   	pop    %ebx
 804b522:	5d                   	pop    %ebp
 804b523:	c3                   	ret    

0804b524 <strdup>:

char *strdup(const char *s)
{
 804b524:	55                   	push   %ebp
 804b525:	89 e5                	mov    %esp,%ebp
        /* TODO - alvin */
        return NULL;
 804b527:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804b52c:	5d                   	pop    %ebp
 804b52d:	c3                   	ret    

0804b52e <strpbrk>:
 * Got this from /onnv-gate/usr/src/common/uti/string.c.
 */

char *
strpbrk(const char *string, const char *brkset)
{
 804b52e:	55                   	push   %ebp
 804b52f:	89 e5                	mov    %esp,%ebp
 804b531:	83 ec 10             	sub    $0x10,%esp
        const char *p;

        do {
                for (p = brkset; *p != '\0' && *p != *string; ++p)
 804b534:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b537:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804b53a:	eb 04                	jmp    804b540 <strpbrk+0x12>
 804b53c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804b540:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804b543:	0f b6 00             	movzbl (%eax),%eax
 804b546:	84 c0                	test   %al,%al
 804b548:	74 10                	je     804b55a <strpbrk+0x2c>
 804b54a:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804b54d:	0f b6 10             	movzbl (%eax),%edx
 804b550:	8b 45 08             	mov    0x8(%ebp),%eax
 804b553:	0f b6 00             	movzbl (%eax),%eax
 804b556:	38 c2                	cmp    %al,%dl
 804b558:	75 e2                	jne    804b53c <strpbrk+0xe>
                        ;
                if (*p != '\0')
 804b55a:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804b55d:	0f b6 00             	movzbl (%eax),%eax
 804b560:	84 c0                	test   %al,%al
 804b562:	74 05                	je     804b569 <strpbrk+0x3b>
                        return ((char *)string);
 804b564:	8b 45 08             	mov    0x8(%ebp),%eax
 804b567:	eb 18                	jmp    804b581 <strpbrk+0x53>
        } while (*string++);
 804b569:	8b 45 08             	mov    0x8(%ebp),%eax
 804b56c:	0f b6 00             	movzbl (%eax),%eax
 804b56f:	84 c0                	test   %al,%al
 804b571:	0f 95 c0             	setne  %al
 804b574:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804b578:	84 c0                	test   %al,%al
 804b57a:	75 b8                	jne    804b534 <strpbrk+0x6>

        return (NULL);
 804b57c:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804b581:	c9                   	leave  
 804b582:	c3                   	ret    

0804b583 <strspn>:

size_t
strspn(const char *string, const char *charset)
{
 804b583:	55                   	push   %ebp
 804b584:	89 e5                	mov    %esp,%ebp
 804b586:	83 ec 10             	sub    $0x10,%esp
        const char *p, *q;

        for (q = string; *q != '\0'; ++q) {
 804b589:	8b 45 08             	mov    0x8(%ebp),%eax
 804b58c:	89 45 f8             	mov    %eax,-0x8(%ebp)
 804b58f:	eb 34                	jmp    804b5c5 <strspn+0x42>
                for (p = charset; *p != '\0' && *p != *q; ++p)
 804b591:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b594:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804b597:	eb 04                	jmp    804b59d <strspn+0x1a>
 804b599:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804b59d:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804b5a0:	0f b6 00             	movzbl (%eax),%eax
 804b5a3:	84 c0                	test   %al,%al
 804b5a5:	74 10                	je     804b5b7 <strspn+0x34>
 804b5a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804b5aa:	0f b6 10             	movzbl (%eax),%edx
 804b5ad:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804b5b0:	0f b6 00             	movzbl (%eax),%eax
 804b5b3:	38 c2                	cmp    %al,%dl
 804b5b5:	75 e2                	jne    804b599 <strspn+0x16>
                        ;
                if (*p == '\0')
 804b5b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804b5ba:	0f b6 00             	movzbl (%eax),%eax
 804b5bd:	84 c0                	test   %al,%al
 804b5bf:	74 10                	je     804b5d1 <strspn+0x4e>
size_t
strspn(const char *string, const char *charset)
{
        const char *p, *q;

        for (q = string; *q != '\0'; ++q) {
 804b5c1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
 804b5c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804b5c8:	0f b6 00             	movzbl (%eax),%eax
 804b5cb:	84 c0                	test   %al,%al
 804b5cd:	75 c2                	jne    804b591 <strspn+0xe>
 804b5cf:	eb 01                	jmp    804b5d2 <strspn+0x4f>
                for (p = charset; *p != '\0' && *p != *q; ++p)
                        ;
                if (*p == '\0')
                        break;
 804b5d1:	90                   	nop
        }

        return (q - string);
 804b5d2:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804b5d5:	8b 45 08             	mov    0x8(%ebp),%eax
 804b5d8:	89 d1                	mov    %edx,%ecx
 804b5da:	29 c1                	sub    %eax,%ecx
 804b5dc:	89 c8                	mov    %ecx,%eax
}
 804b5de:	c9                   	leave  
 804b5df:	c3                   	ret    

0804b5e0 <strtok>:

char *
strtok(char *string, const char *sepset)
{
 804b5e0:	55                   	push   %ebp
 804b5e1:	89 e5                	mov    %esp,%ebp
 804b5e3:	53                   	push   %ebx
 804b5e4:	83 ec 24             	sub    $0x24,%esp
 804b5e7:	e8 6b da ff ff       	call   8049057 <__i686.get_pc_thunk.bx>
 804b5ec:	81 c3 2c 2f 00 00    	add    $0x2f2c,%ebx
        static char     *savept;

        /*
         * Set `p' to our current location in the string.
         */
        p = (string == NULL) ? savept : string;
 804b5f2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804b5f6:	75 08                	jne    804b600 <strtok+0x20>
 804b5f8:	8b 83 28 01 00 00    	mov    0x128(%ebx),%eax
 804b5fe:	eb 03                	jmp    804b603 <strtok+0x23>
 804b600:	8b 45 08             	mov    0x8(%ebp),%eax
 804b603:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (p == NULL)
 804b606:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804b60a:	75 07                	jne    804b613 <strtok+0x33>
                return (NULL);
 804b60c:	b8 00 00 00 00       	mov    $0x0,%eax
 804b611:	eb 66                	jmp    804b679 <strtok+0x99>

        /*
         * Skip leading separators; bail if no tokens remain.
         */
        q = p + strspn(p, sepset);
 804b613:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b616:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b61a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b61d:	89 04 24             	mov    %eax,(%esp)
 804b620:	e8 5e ff ff ff       	call   804b583 <strspn>
 804b625:	03 45 f4             	add    -0xc(%ebp),%eax
 804b628:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (*q == '\0')
 804b62b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b62e:	0f b6 00             	movzbl (%eax),%eax
 804b631:	84 c0                	test   %al,%al
 804b633:	75 07                	jne    804b63c <strtok+0x5c>
                return (NULL);
 804b635:	b8 00 00 00 00       	mov    $0x0,%eax
 804b63a:	eb 3d                	jmp    804b679 <strtok+0x99>

        /*
         * Mark the end of the token and set `savept' for the next iteration.
         */
        if ((r = strpbrk(q, sepset)) == NULL)
 804b63c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b63f:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b643:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b646:	89 04 24             	mov    %eax,(%esp)
 804b649:	e8 e0 fe ff ff       	call   804b52e <strpbrk>
 804b64e:	89 45 ec             	mov    %eax,-0x14(%ebp)
 804b651:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804b655:	75 0c                	jne    804b663 <strtok+0x83>
                savept = NULL;
 804b657:	c7 83 28 01 00 00 00 	movl   $0x0,0x128(%ebx)
 804b65e:	00 00 00 
 804b661:	eb 13                	jmp    804b676 <strtok+0x96>
        else {
                *r = '\0';
 804b663:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b666:	c6 00 00             	movb   $0x0,(%eax)
                savept = ++r;
 804b669:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
 804b66d:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b670:	89 83 28 01 00 00    	mov    %eax,0x128(%ebx)
        }

        return (q);
 804b676:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 804b679:	83 c4 24             	add    $0x24,%esp
 804b67c:	5b                   	pop    %ebx
 804b67d:	5d                   	pop    %ebp
 804b67e:	c3                   	ret    

0804b67f <strerror>:

/* created with the help of:
 * perl -p -e 's/#define\s+(\w+)\s+\d+\s+\/\* ([^\t\*]+)\s*\*\/\s*$/case $1: return "$2";\n/' < /usr/include/sys/errno.h
 */
char *strerror(int errnum)
{
 804b67f:	55                   	push   %ebp
 804b680:	89 e5                	mov    %esp,%ebp
 804b682:	e8 cc d9 ff ff       	call   8049053 <__i686.get_pc_thunk.cx>
 804b687:	81 c1 91 2e 00 00    	add    $0x2e91,%ecx
        switch (errnum) {
 804b68d:	81 7d 08 83 00 00 00 	cmpl   $0x83,0x8(%ebp)
 804b694:	0f 87 fd 06 00 00    	ja     804bd97 <strerror+0x718>
 804b69a:	8b 45 08             	mov    0x8(%ebp),%eax
 804b69d:	c1 e0 02             	shl    $0x2,%eax
 804b6a0:	8b 84 08 98 d1 ff ff 	mov    -0x2e68(%eax,%ecx,1),%eax
 804b6a7:	89 ca                	mov    %ecx,%edx
 804b6a9:	29 c2                	sub    %eax,%edx
 804b6ab:	89 d0                	mov    %edx,%eax
 804b6ad:	ff e0                	jmp    *%eax
 804b6af:	90                   	nop
 804b6b0:	81 27 00 00 58 2c    	andl   $0x2c580000,(%edi)
 804b6b6:	00 00                	add    %al,(%eax)
 804b6b8:	4d                   	dec    %ebp
 804b6b9:	2c 00                	sub    $0x0,%al
 804b6bb:	00 42 2c             	add    %al,0x2c(%edx)
 804b6be:	00 00                	add    %al,(%eax)
 804b6c0:	37                   	aaa    
 804b6c1:	2c 00                	sub    $0x0,%al
 804b6c3:	00 2c 2c             	add    %ch,(%esp,%ebp,1)
 804b6c6:	00 00                	add    %al,(%eax)
 804b6c8:	21 2c 00             	and    %ebp,(%eax,%eax,1)
 804b6cb:	00 16                	add    %dl,(%esi)
 804b6cd:	2c 00                	sub    $0x0,%al
 804b6cf:	00 0b                	add    %cl,(%ebx)
 804b6d1:	2c 00                	sub    $0x0,%al
 804b6d3:	00 00                	add    %al,(%eax)
 804b6d5:	2c 00                	sub    $0x0,%al
 804b6d7:	00 f5                	add    %dh,%ch
 804b6d9:	2b 00                	sub    (%eax),%eax
 804b6db:	00 ea                	add    %ch,%dl
 804b6dd:	2b 00                	sub    (%eax),%eax
 804b6df:	00 df                	add    %bl,%bh
 804b6e1:	2b 00                	sub    (%eax),%eax
 804b6e3:	00 d4                	add    %dl,%ah
 804b6e5:	2b 00                	sub    (%eax),%eax
 804b6e7:	00 c9                	add    %cl,%cl
 804b6e9:	2b 00                	sub    (%eax),%eax
 804b6eb:	00 be 2b 00 00 b3    	add    %bh,-0x4cffffd5(%esi)
 804b6f1:	2b 00                	sub    (%eax),%eax
 804b6f3:	00 a8 2b 00 00 9d    	add    %ch,-0x62ffffd5(%eax)
 804b6f9:	2b 00                	sub    (%eax),%eax
 804b6fb:	00 92 2b 00 00 87    	add    %dl,-0x78ffffd5(%edx)
 804b701:	2b 00                	sub    (%eax),%eax
 804b703:	00 7c 2b 00          	add    %bh,0x0(%ebx,%ebp,1)
 804b707:	00 71 2b             	add    %dh,0x2b(%ecx)
 804b70a:	00 00                	add    %al,(%eax)
 804b70c:	66 2b 00             	sub    (%eax),%ax
 804b70f:	00 5b 2b             	add    %bl,0x2b(%ebx)
 804b712:	00 00                	add    %al,(%eax)
 804b714:	50                   	push   %eax
 804b715:	2b 00                	sub    (%eax),%eax
 804b717:	00 45 2b             	add    %al,0x2b(%ebp)
 804b71a:	00 00                	add    %al,(%eax)
 804b71c:	3a 2b                	cmp    (%ebx),%ch
 804b71e:	00 00                	add    %al,(%eax)
 804b720:	2f                   	das    
 804b721:	2b 00                	sub    (%eax),%eax
 804b723:	00 24 2b             	add    %ah,(%ebx,%ebp,1)
 804b726:	00 00                	add    %al,(%eax)
 804b728:	19 2b                	sbb    %ebp,(%ebx)
 804b72a:	00 00                	add    %al,(%eax)
 804b72c:	0e                   	push   %cs
 804b72d:	2b 00                	sub    (%eax),%eax
 804b72f:	00 03                	add    %al,(%ebx)
 804b731:	2b 00                	sub    (%eax),%eax
 804b733:	00 f8                	add    %bh,%al
 804b735:	2a 00                	sub    (%eax),%al
 804b737:	00 ed                	add    %ch,%ch
 804b739:	2a 00                	sub    (%eax),%al
 804b73b:	00 74 2a 00          	add    %dh,0x0(%edx,%ebp,1)
 804b73f:	00 40 29             	add    %al,0x29(%eax)
 804b742:	00 00                	add    %al,(%eax)
 804b744:	69 2a 00 00 c7 28    	imul   $0x28c70000,(%edx),%ebp
 804b74a:	00 00                	add    %al,(%eax)
 804b74c:	9b                   	fwait
 804b74d:	28 00                	sub    %al,(%eax)
 804b74f:	00 bc 28 00 00 81 27 	add    %bh,0x27810000(%eax,%ebp,1)
 804b756:	00 00                	add    %al,(%eax)
 804b758:	e2 2a                	loop   804b784 <strerror+0x105>
 804b75a:	00 00                	add    %al,(%eax)
 804b75c:	d7                   	xlat   %ds:(%ebx)
 804b75d:	2a 00                	sub    (%eax),%al
 804b75f:	00 cc                	add    %cl,%ah
 804b761:	2a 00                	sub    (%eax),%al
 804b763:	00 c1                	add    %al,%cl
 804b765:	2a 00                	sub    (%eax),%al
 804b767:	00 b6 2a 00 00 ab    	add    %dh,-0x54ffffd6(%esi)
 804b76d:	2a 00                	sub    (%eax),%al
 804b76f:	00 a0 2a 00 00 95    	add    %ah,-0x6affffd6(%eax)
 804b775:	2a 00                	sub    (%eax),%al
 804b777:	00 8a 2a 00 00 7f    	add    %cl,0x7f00002a(%edx)
 804b77d:	2a 00                	sub    (%eax),%al
 804b77f:	00 3d 2a 00 00 32    	add    %bh,0x3200002a
 804b785:	2a 00                	sub    (%eax),%al
 804b787:	00 27                	add    %ah,(%edi)
 804b789:	2a 00                	sub    (%eax),%al
 804b78b:	00 1c 2a             	add    %bl,(%edx,%ebp,1)
 804b78e:	00 00                	add    %al,(%eax)
 804b790:	11 2a                	adc    %ebp,(%edx)
 804b792:	00 00                	add    %al,(%eax)
 804b794:	06                   	push   %es
 804b795:	2a 00                	sub    (%eax),%al
 804b797:	00 81 27 00 00 fb    	add    %al,-0x4ffffd9(%ecx)
 804b79d:	29 00                	sub    %eax,(%eax)
 804b79f:	00 da                	add    %bl,%dl
 804b7a1:	29 00                	sub    %eax,(%eax)
 804b7a3:	00 cf                	add    %cl,%bh
 804b7a5:	29 00                	sub    %eax,(%eax)
 804b7a7:	00 c4                	add    %al,%ah
 804b7a9:	29 00                	sub    %eax,(%eax)
 804b7ab:	00 b9 29 00 00 ae    	add    %bh,-0x51ffffd7(%ecx)
 804b7b1:	29 00                	sub    %eax,(%eax)
 804b7b3:	00 a3 29 00 00 98    	add    %ah,-0x67ffffd7(%ebx)
 804b7b9:	29 00                	sub    %eax,(%eax)
 804b7bb:	00 8d 29 00 00 82    	add    %cl,-0x7dffffd7(%ebp)
 804b7c1:	29 00                	sub    %eax,(%eax)
 804b7c3:	00 77 29             	add    %dh,0x29(%edi)
 804b7c6:	00 00                	add    %al,(%eax)
 804b7c8:	6c                   	insb   (%dx),%es:(%edi)
 804b7c9:	29 00                	sub    %eax,(%eax)
 804b7cb:	00 61 29             	add    %ah,0x29(%ecx)
 804b7ce:	00 00                	add    %al,(%eax)
 804b7d0:	56                   	push   %esi
 804b7d1:	29 00                	sub    %eax,(%eax)
 804b7d3:	00 81 27 00 00 4b    	add    %al,0x4b000027(%ecx)
 804b7d9:	29 00                	sub    %eax,(%eax)
 804b7db:	00 35 29 00 00 2a    	add    %dh,0x2a000029
 804b7e1:	29 00                	sub    %eax,(%eax)
 804b7e3:	00 1f                	add    %bl,(%edi)
 804b7e5:	29 00                	sub    %eax,(%eax)
 804b7e7:	00 14 29             	add    %dl,(%ecx,%ebp,1)
 804b7ea:	00 00                	add    %al,(%eax)
 804b7ec:	09 29                	or     %ebp,(%ecx)
 804b7ee:	00 00                	add    %al,(%eax)
 804b7f0:	fe                   	(bad)  
 804b7f1:	28 00                	sub    %al,(%eax)
 804b7f3:	00 f3                	add    %dh,%bl
 804b7f5:	28 00                	sub    %al,(%eax)
 804b7f7:	00 e8                	add    %ch,%al
 804b7f9:	28 00                	sub    %al,(%eax)
 804b7fb:	00 dd                	add    %bl,%ch
 804b7fd:	28 00                	sub    %al,(%eax)
 804b7ff:	00 d2                	add    %dl,%dl
 804b801:	28 00                	sub    %al,(%eax)
 804b803:	00 b1 28 00 00 a6    	add    %dh,-0x59ffffd8(%ecx)
 804b809:	28 00                	sub    %al,(%eax)
 804b80b:	00 90 28 00 00 85    	add    %dl,-0x7affffd8(%eax)
 804b811:	28 00                	sub    %al,(%eax)
 804b813:	00 7a 28             	add    %bh,0x28(%edx)
 804b816:	00 00                	add    %al,(%eax)
 804b818:	6f                   	outsl  %ds:(%esi),(%dx)
 804b819:	28 00                	sub    %al,(%eax)
 804b81b:	00 64 28 00          	add    %ah,0x0(%eax,%ebp,1)
 804b81f:	00 59 28             	add    %bl,0x28(%ecx)
 804b822:	00 00                	add    %al,(%eax)
 804b824:	4e                   	dec    %esi
 804b825:	28 00                	sub    %al,(%eax)
 804b827:	00 43 28             	add    %al,0x28(%ebx)
 804b82a:	00 00                	add    %al,(%eax)
 804b82c:	53                   	push   %ebx
 804b82d:	2a 00                	sub    (%eax),%al
 804b82f:	00 38                	add    %bh,(%eax)
 804b831:	28 00                	sub    %al,(%eax)
 804b833:	00 2d 28 00 00 22    	add    %ch,0x22000028
 804b839:	28 00                	sub    %al,(%eax)
 804b83b:	00 17                	add    %dl,(%edi)
 804b83d:	28 00                	sub    %al,(%eax)
 804b83f:	00 0c 28             	add    %cl,(%eax,%ebp,1)
 804b842:	00 00                	add    %al,(%eax)
 804b844:	01 28                	add    %ebp,(%eax)
 804b846:	00 00                	add    %al,(%eax)
 804b848:	f9                   	stc    
 804b849:	27                   	daa    
 804b84a:	00 00                	add    %al,(%eax)
 804b84c:	f1                   	icebp  
 804b84d:	27                   	daa    
 804b84e:	00 00                	add    %al,(%eax)
 804b850:	e9 27 00 00 e1       	jmp    e904b87c <_end+0xe0ffd230>
 804b855:	27                   	daa    
 804b856:	00 00                	add    %al,(%eax)
 804b858:	d9 27                	fldenv (%edi)
 804b85a:	00 00                	add    %al,(%eax)
 804b85c:	d1 27                	shll   (%edi)
 804b85e:	00 00                	add    %al,(%eax)
 804b860:	c9                   	leave  
 804b861:	27                   	daa    
 804b862:	00 00                	add    %al,(%eax)
 804b864:	c1 27 00             	shll   $0x0,(%edi)
 804b867:	00 b9 27 00 00 b1    	add    %bh,-0x4effffd9(%ecx)
 804b86d:	27                   	daa    
 804b86e:	00 00                	add    %al,(%eax)
 804b870:	a9 27 00 00 a1       	test   $0xa1000027,%eax
 804b875:	27                   	daa    
 804b876:	00 00                	add    %al,(%eax)
 804b878:	99                   	cltd   
 804b879:	27                   	daa    
 804b87a:	00 00                	add    %al,(%eax)
 804b87c:	91                   	xchg   %eax,%ecx
 804b87d:	27                   	daa    
 804b87e:	00 00                	add    %al,(%eax)
 804b880:	89 27                	mov    %esp,(%edi)
 804b882:	00 00                	add    %al,(%eax)
 804b884:	81 27 00 00 81 27    	andl   $0x27810000,(%edi)
 804b88a:	00 00                	add    %al,(%eax)
 804b88c:	81 27 00 00 81 27    	andl   $0x27810000,(%edi)
 804b892:	00 00                	add    %al,(%eax)
 804b894:	81 27 00 00 48 2a    	andl   $0x2a480000,(%edi)
 804b89a:	00 00                	add    %al,(%eax)
 804b89c:	81 27 00 00 81 27    	andl   $0x27810000,(%edi)
 804b8a2:	00 00                	add    %al,(%eax)
 804b8a4:	5e                   	pop    %esi
 804b8a5:	2a 00                	sub    (%eax),%al
 804b8a7:	00 81 27 00 00 81    	add    %al,-0x7effffd9(%ecx)
 804b8ad:	27                   	daa    
 804b8ae:	00 00                	add    %al,(%eax)
 804b8b0:	81 27 00 00 81 27    	andl   $0x27810000,(%edi)
 804b8b6:	00 00                	add    %al,(%eax)
 804b8b8:	f0 29 00             	lock sub %eax,(%eax)
 804b8bb:	00 e5                	add    %ah,%ch
 804b8bd:	29 00                	sub    %eax,(%eax)
 804b8bf:	00 8d 81 7c da ff    	add    %cl,-0x25837f(%ebp)
                case EPERM: return "Not super-user";
 804b8c5:	ff e9                	ljmp   *<internal disassembler error>
 804b8c7:	d1 04 00             	roll   (%eax,%eax,1)
 804b8ca:	00 8d 81 8b da ff    	add    %cl,-0x25747f(%ebp)
                case ENOENT: return "No such file or directory";
 804b8d0:	ff e9                	ljmp   *<internal disassembler error>
 804b8d2:	c6 04 00 00          	movb   $0x0,(%eax,%eax,1)
                case ESRCH: return "No such process";
 804b8d6:	8d 81 a5 da ff ff    	lea    -0x255b(%ecx),%eax
 804b8dc:	e9 bb 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case EINTR: return "interrupted system call";
 804b8e1:	8d 81 b5 da ff ff    	lea    -0x254b(%ecx),%eax
 804b8e7:	e9 b0 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case EIO: return "I/O error";
 804b8ec:	8d 81 cd da ff ff    	lea    -0x2533(%ecx),%eax
 804b8f2:	e9 a5 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENXIO: return "No such device or address";
 804b8f7:	8d 81 d7 da ff ff    	lea    -0x2529(%ecx),%eax
 804b8fd:	e9 9a 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case E2BIG: return "Arg list too long";
 804b902:	8d 81 f1 da ff ff    	lea    -0x250f(%ecx),%eax
 804b908:	e9 8f 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOEXEC: return "Exec format error";
 804b90d:	8d 81 03 db ff ff    	lea    -0x24fd(%ecx),%eax
 804b913:	e9 84 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case EBADF: return "Bad file number";
 804b918:	8d 81 15 db ff ff    	lea    -0x24eb(%ecx),%eax
 804b91e:	e9 79 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case ECHILD: return "No children";
 804b923:	8d 81 25 db ff ff    	lea    -0x24db(%ecx),%eax
 804b929:	e9 6e 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case EAGAIN: return "Resource temporarily unavailable";
 804b92e:	8d 81 34 db ff ff    	lea    -0x24cc(%ecx),%eax
 804b934:	e9 63 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOMEM: return "Not enough core";
 804b939:	8d 81 55 db ff ff    	lea    -0x24ab(%ecx),%eax
 804b93f:	e9 58 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case EACCES: return "Permission denied";
 804b944:	8d 81 65 db ff ff    	lea    -0x249b(%ecx),%eax
 804b94a:	e9 4d 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case EFAULT: return "Bad address";
 804b94f:	8d 81 77 db ff ff    	lea    -0x2489(%ecx),%eax
 804b955:	e9 42 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOTBLK: return "Block device required";
 804b95a:	8d 81 83 db ff ff    	lea    -0x247d(%ecx),%eax
 804b960:	e9 37 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case EBUSY: return "Mount device busy";
 804b965:	8d 81 99 db ff ff    	lea    -0x2467(%ecx),%eax
 804b96b:	e9 2c 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case EEXIST: return "File exists";
 804b970:	8d 81 ab db ff ff    	lea    -0x2455(%ecx),%eax
 804b976:	e9 21 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case EXDEV: return "Cross-device link";
 804b97b:	8d 81 b7 db ff ff    	lea    -0x2449(%ecx),%eax
 804b981:	e9 16 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENODEV: return "No such device";
 804b986:	8d 81 c9 db ff ff    	lea    -0x2437(%ecx),%eax
 804b98c:	e9 0b 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOTDIR: return "Not a directory";
 804b991:	8d 81 d8 db ff ff    	lea    -0x2428(%ecx),%eax
 804b997:	e9 00 04 00 00       	jmp    804bd9c <strerror+0x71d>
                case EISDIR: return "Is a directory";
 804b99c:	8d 81 e8 db ff ff    	lea    -0x2418(%ecx),%eax
 804b9a2:	e9 f5 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case EINVAL: return "Invalid argument";
 804b9a7:	8d 81 f7 db ff ff    	lea    -0x2409(%ecx),%eax
 804b9ad:	e9 ea 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENFILE: return "File table overflow";
 804b9b2:	8d 81 08 dc ff ff    	lea    -0x23f8(%ecx),%eax
 804b9b8:	e9 df 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case EMFILE: return "Too many open files";
 804b9bd:	8d 81 1c dc ff ff    	lea    -0x23e4(%ecx),%eax
 804b9c3:	e9 d4 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOTTY: return "Inappropriate ioctl for device";
 804b9c8:	8d 81 30 dc ff ff    	lea    -0x23d0(%ecx),%eax
 804b9ce:	e9 c9 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case ETXTBSY: return "Text file busy";
 804b9d3:	8d 81 4f dc ff ff    	lea    -0x23b1(%ecx),%eax
 804b9d9:	e9 be 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case EFBIG: return "File too large";
 804b9de:	8d 81 5e dc ff ff    	lea    -0x23a2(%ecx),%eax
 804b9e4:	e9 b3 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOSPC: return "No space left on device";
 804b9e9:	8d 81 6d dc ff ff    	lea    -0x2393(%ecx),%eax
 804b9ef:	e9 a8 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case ESPIPE: return "Illegal seek";
 804b9f4:	8d 81 85 dc ff ff    	lea    -0x237b(%ecx),%eax
 804b9fa:	e9 9d 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case EROFS: return "Read only file system";
 804b9ff:	8d 81 92 dc ff ff    	lea    -0x236e(%ecx),%eax
 804ba05:	e9 92 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case EMLINK: return "Too many links";
 804ba0a:	8d 81 a8 dc ff ff    	lea    -0x2358(%ecx),%eax
 804ba10:	e9 87 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case EPIPE: return "Broken pipe";
 804ba15:	8d 81 b7 dc ff ff    	lea    -0x2349(%ecx),%eax
 804ba1b:	e9 7c 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case EDOM: return "Math arg out of domain of func";
 804ba20:	8d 81 c4 dc ff ff    	lea    -0x233c(%ecx),%eax
 804ba26:	e9 71 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case ERANGE: return "Math result not representable";
 804ba2b:	8d 81 e3 dc ff ff    	lea    -0x231d(%ecx),%eax
 804ba31:	e9 66 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOMSG: return "No message of desired type";
 804ba36:	8d 81 01 dd ff ff    	lea    -0x22ff(%ecx),%eax
 804ba3c:	e9 5b 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case EIDRM: return "Identifier removed";
 804ba41:	8d 81 1c dd ff ff    	lea    -0x22e4(%ecx),%eax
 804ba47:	e9 50 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case ECHRNG: return "Channel number out of range";
 804ba4c:	8d 81 2f dd ff ff    	lea    -0x22d1(%ecx),%eax
 804ba52:	e9 45 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case EL2NSYNC: return "Level 2 not synchronized";
 804ba57:	8d 81 4b dd ff ff    	lea    -0x22b5(%ecx),%eax
 804ba5d:	e9 3a 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case EL3HLT: return "Level 3 halted";
 804ba62:	8d 81 64 dd ff ff    	lea    -0x229c(%ecx),%eax
 804ba68:	e9 2f 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case EL3RST: return "Level 3 reset";
 804ba6d:	8d 81 73 dd ff ff    	lea    -0x228d(%ecx),%eax
 804ba73:	e9 24 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case ELNRNG: return "Link number out of range";
 804ba78:	8d 81 81 dd ff ff    	lea    -0x227f(%ecx),%eax
 804ba7e:	e9 19 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case EUNATCH: return "Protocol driver not attached";
 804ba83:	8d 81 9a dd ff ff    	lea    -0x2266(%ecx),%eax
 804ba89:	e9 0e 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOCSI: return "No CSI structure available";
 804ba8e:	8d 81 b7 dd ff ff    	lea    -0x2249(%ecx),%eax
 804ba94:	e9 03 03 00 00       	jmp    804bd9c <strerror+0x71d>
                case EL2HLT: return "Level 2 halted";
 804ba99:	8d 81 d2 dd ff ff    	lea    -0x222e(%ecx),%eax
 804ba9f:	e9 f8 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case EDEADLK: return "Deadlock condition.";
 804baa4:	8d 81 e1 dd ff ff    	lea    -0x221f(%ecx),%eax
 804baaa:	e9 ed 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOLCK: return "No record locks available.";
 804baaf:	8d 81 f5 dd ff ff    	lea    -0x220b(%ecx),%eax
 804bab5:	e9 e2 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case ECANCELED: return "Operation canceled";
 804baba:	8d 81 10 de ff ff    	lea    -0x21f0(%ecx),%eax
 804bac0:	e9 d7 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOTSUP: return "Operation not supported";
 804bac5:	8d 81 23 de ff ff    	lea    -0x21dd(%ecx),%eax
 804bacb:	e9 cc 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case EDQUOT: return "Disc quota exceeded";
 804bad0:	8d 81 3b de ff ff    	lea    -0x21c5(%ecx),%eax
 804bad6:	e9 c1 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case EBADE: return "invalid exchange";
 804badb:	8d 81 4f de ff ff    	lea    -0x21b1(%ecx),%eax
 804bae1:	e9 b6 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case EBADR: return "invalid request descriptor";
 804bae6:	8d 81 60 de ff ff    	lea    -0x21a0(%ecx),%eax
 804baec:	e9 ab 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case EXFULL: return "exchange full";
 804baf1:	8d 81 7b de ff ff    	lea    -0x2185(%ecx),%eax
 804baf7:	e9 a0 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOANO: return "no anode";
 804bafc:	8d 81 89 de ff ff    	lea    -0x2177(%ecx),%eax
 804bb02:	e9 95 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case EBADRQC: return "invalid request code";
 804bb07:	8d 81 92 de ff ff    	lea    -0x216e(%ecx),%eax
 804bb0d:	e9 8a 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case EBADSLT: return "invalid slot";
 804bb12:	8d 81 a7 de ff ff    	lea    -0x2159(%ecx),%eax
 804bb18:	e9 7f 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case EBFONT: return "bad font file fmt";
 804bb1d:	8d 81 b4 de ff ff    	lea    -0x214c(%ecx),%eax
 804bb23:	e9 74 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case EOWNERDEAD: return "process died with the lock";
 804bb28:	8d 81 c6 de ff ff    	lea    -0x213a(%ecx),%eax
 804bb2e:	e9 69 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOTRECOVERABLE: return "lock is not recoverable";
 804bb33:	8d 81 e1 de ff ff    	lea    -0x211f(%ecx),%eax
 804bb39:	e9 5e 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOSTR: return "Device not a stream";
 804bb3e:	8d 81 f9 de ff ff    	lea    -0x2107(%ecx),%eax
 804bb44:	e9 53 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENODATA: return "no data (for no delay io)";
 804bb49:	8d 81 0d df ff ff    	lea    -0x20f3(%ecx),%eax
 804bb4f:	e9 48 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case ETIME: return "timer expired";
 804bb54:	8d 81 27 df ff ff    	lea    -0x20d9(%ecx),%eax
 804bb5a:	e9 3d 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOSR: return "out of streams resources";
 804bb5f:	8d 81 35 df ff ff    	lea    -0x20cb(%ecx),%eax
 804bb65:	e9 32 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENONET: return "Machine is not on the network";
 804bb6a:	8d 81 4e df ff ff    	lea    -0x20b2(%ecx),%eax
 804bb70:	e9 27 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOPKG: return "Package not installed";
 804bb75:	8d 81 6c df ff ff    	lea    -0x2094(%ecx),%eax
 804bb7b:	e9 1c 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case EREMOTE: return "The object is remote";
 804bb80:	8d 81 82 df ff ff    	lea    -0x207e(%ecx),%eax
 804bb86:	e9 11 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOLINK: return "the link has been severed";
 804bb8b:	8d 81 97 df ff ff    	lea    -0x2069(%ecx),%eax
 804bb91:	e9 06 02 00 00       	jmp    804bd9c <strerror+0x71d>
                case EADV: return "advertise error";
 804bb96:	8d 81 b1 df ff ff    	lea    -0x204f(%ecx),%eax
 804bb9c:	e9 fb 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case ESRMNT: return "srmount error";
 804bba1:	8d 81 c1 df ff ff    	lea    -0x203f(%ecx),%eax
 804bba7:	e9 f0 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case ECOMM: return "Communication error on send";
 804bbac:	8d 81 cf df ff ff    	lea    -0x2031(%ecx),%eax
 804bbb2:	e9 e5 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case EPROTO: return "Protocol error";
 804bbb7:	8d 81 eb df ff ff    	lea    -0x2015(%ecx),%eax
 804bbbd:	e9 da 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case EMULTIHOP: return "multihop attempted";
 804bbc2:	8d 81 fa df ff ff    	lea    -0x2006(%ecx),%eax
 804bbc8:	e9 cf 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case EBADMSG: return "trying to read unreadable message";
 804bbcd:	8d 81 10 e0 ff ff    	lea    -0x1ff0(%ecx),%eax
 804bbd3:	e9 c4 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENAMETOOLONG: return "path name is too long";
 804bbd8:	8d 81 32 e0 ff ff    	lea    -0x1fce(%ecx),%eax
 804bbde:	e9 b9 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case EOVERFLOW: return "value too large to be stored in data type";
 804bbe3:	8d 81 48 e0 ff ff    	lea    -0x1fb8(%ecx),%eax
 804bbe9:	e9 ae 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOTUNIQ: return "given log. name not unique";
 804bbee:	8d 81 72 e0 ff ff    	lea    -0x1f8e(%ecx),%eax
 804bbf4:	e9 a3 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case EBADFD: return "f.d. invalid for this operation";
 804bbf9:	8d 81 90 e0 ff ff    	lea    -0x1f70(%ecx),%eax
 804bbff:	e9 98 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case EREMCHG: return "Remote address changed";
 804bc04:	8d 81 b0 e0 ff ff    	lea    -0x1f50(%ecx),%eax
 804bc0a:	e9 8d 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case ELIBACC: return "Can't access a needed shared lib.";
 804bc0f:	8d 81 c8 e0 ff ff    	lea    -0x1f38(%ecx),%eax
 804bc15:	e9 82 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case ELIBBAD: return "Accessing a corrupted shared lib.";
 804bc1a:	8d 81 ec e0 ff ff    	lea    -0x1f14(%ecx),%eax
 804bc20:	e9 77 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case ELIBSCN: return ".lib section in a.out corrupted.";
 804bc25:	8d 81 10 e1 ff ff    	lea    -0x1ef0(%ecx),%eax
 804bc2b:	e9 6c 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case ELIBMAX: return "Attempting to link in too many libs.";
 804bc30:	8d 81 34 e1 ff ff    	lea    -0x1ecc(%ecx),%eax
 804bc36:	e9 61 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case ELIBEXEC: return "Attempting to exec a shared library.";
 804bc3b:	8d 81 5c e1 ff ff    	lea    -0x1ea4(%ecx),%eax
 804bc41:	e9 56 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case EILSEQ: return "Illegal byte sequence.";
 804bc46:	8d 81 81 e1 ff ff    	lea    -0x1e7f(%ecx),%eax
 804bc4c:	e9 4b 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOSYS: return "Unsupported file system operation";
 804bc51:	8d 81 98 e1 ff ff    	lea    -0x1e68(%ecx),%eax
 804bc57:	e9 40 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case ELOOP: return "Symbolic link loop";
 804bc5c:	8d 81 ba e1 ff ff    	lea    -0x1e46(%ecx),%eax
 804bc62:	e9 35 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case ERESTART: return "Restartable system call";
 804bc67:	8d 81 cd e1 ff ff    	lea    -0x1e33(%ecx),%eax
 804bc6d:	e9 2a 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case ESTRPIPE: return "if pipe/FIFO, don't sleep in stream head";
 804bc72:	8d 81 e8 e1 ff ff    	lea    -0x1e18(%ecx),%eax
 804bc78:	e9 1f 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOTEMPTY: return "directory not empty";
 804bc7d:	8d 81 11 e2 ff ff    	lea    -0x1def(%ecx),%eax
 804bc83:	e9 14 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case EUSERS: return "Too many users (for UFS)";
 804bc88:	8d 81 25 e2 ff ff    	lea    -0x1ddb(%ecx),%eax
 804bc8e:	e9 09 01 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOTSOCK: return "Socket operation on non-socket";
 804bc93:	8d 81 40 e2 ff ff    	lea    -0x1dc0(%ecx),%eax
 804bc99:	e9 fe 00 00 00       	jmp    804bd9c <strerror+0x71d>
                case EDESTADDRREQ: return "Destination address required";
 804bc9e:	8d 81 5f e2 ff ff    	lea    -0x1da1(%ecx),%eax
 804bca4:	e9 f3 00 00 00       	jmp    804bd9c <strerror+0x71d>
                case EMSGSIZE: return "Message too long";
 804bca9:	8d 81 7c e2 ff ff    	lea    -0x1d84(%ecx),%eax
 804bcaf:	e9 e8 00 00 00       	jmp    804bd9c <strerror+0x71d>
                case EPROTOTYPE: return "Protocol wrong type for socket";
 804bcb4:	8d 81 90 e2 ff ff    	lea    -0x1d70(%ecx),%eax
 804bcba:	e9 dd 00 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENOPROTOOPT: return "Protocol not available";
 804bcbf:	8d 81 af e2 ff ff    	lea    -0x1d51(%ecx),%eax
 804bcc5:	e9 d2 00 00 00       	jmp    804bd9c <strerror+0x71d>
                case EPROTONOSUPPORT: return "Protocol not supported";
 804bcca:	8d 81 c6 e2 ff ff    	lea    -0x1d3a(%ecx),%eax
 804bcd0:	e9 c7 00 00 00       	jmp    804bd9c <strerror+0x71d>
                case ESOCKTNOSUPPORT: return "Socket type not supported";
 804bcd5:	8d 81 dd e2 ff ff    	lea    -0x1d23(%ecx),%eax
 804bcdb:	e9 bc 00 00 00       	jmp    804bd9c <strerror+0x71d>
                case EPFNOSUPPORT: return "Protocol family not supported";
 804bce0:	8d 81 f7 e2 ff ff    	lea    -0x1d09(%ecx),%eax
 804bce6:	e9 b1 00 00 00       	jmp    804bd9c <strerror+0x71d>
                case EAFNOSUPPORT: return "Address family not supported by protocol family";
 804bceb:	8d 81 18 e3 ff ff    	lea    -0x1ce8(%ecx),%eax
 804bcf1:	e9 a6 00 00 00       	jmp    804bd9c <strerror+0x71d>
                case EADDRINUSE: return "Address already in use";
 804bcf6:	8d 81 48 e3 ff ff    	lea    -0x1cb8(%ecx),%eax
 804bcfc:	e9 9b 00 00 00       	jmp    804bd9c <strerror+0x71d>
                case EADDRNOTAVAIL: return "Can't assign requested address";
 804bd01:	8d 81 60 e3 ff ff    	lea    -0x1ca0(%ecx),%eax
 804bd07:	e9 90 00 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENETDOWN: return "Network is down";
 804bd0c:	8d 81 7f e3 ff ff    	lea    -0x1c81(%ecx),%eax
 804bd12:	e9 85 00 00 00       	jmp    804bd9c <strerror+0x71d>
                case ENETUNREACH: return "Network is unreachable";
 804bd17:	8d 81 8f e3 ff ff    	lea    -0x1c71(%ecx),%eax
 804bd1d:	eb 7d                	jmp    804bd9c <strerror+0x71d>
                case ENETRESET: return "Network dropped connection because of reset";
 804bd1f:	8d 81 a8 e3 ff ff    	lea    -0x1c58(%ecx),%eax
 804bd25:	eb 75                	jmp    804bd9c <strerror+0x71d>
                case ECONNABORTED: return "Software caused connection abort";
 804bd27:	8d 81 d4 e3 ff ff    	lea    -0x1c2c(%ecx),%eax
 804bd2d:	eb 6d                	jmp    804bd9c <strerror+0x71d>
                case ECONNRESET: return "Connection reset by peer";
 804bd2f:	8d 81 f5 e3 ff ff    	lea    -0x1c0b(%ecx),%eax
 804bd35:	eb 65                	jmp    804bd9c <strerror+0x71d>
                case ENOBUFS: return "No buffer space available";
 804bd37:	8d 81 0e e4 ff ff    	lea    -0x1bf2(%ecx),%eax
 804bd3d:	eb 5d                	jmp    804bd9c <strerror+0x71d>
                case EISCONN: return "Socket is already connected";
 804bd3f:	8d 81 28 e4 ff ff    	lea    -0x1bd8(%ecx),%eax
 804bd45:	eb 55                	jmp    804bd9c <strerror+0x71d>
                case ENOTCONN: return "Socket is not connected";
 804bd47:	8d 81 44 e4 ff ff    	lea    -0x1bbc(%ecx),%eax
 804bd4d:	eb 4d                	jmp    804bd9c <strerror+0x71d>
                case ESHUTDOWN: return "Can't send after socket shutdown";
 804bd4f:	8d 81 5c e4 ff ff    	lea    -0x1ba4(%ecx),%eax
 804bd55:	eb 45                	jmp    804bd9c <strerror+0x71d>
                case ETOOMANYREFS: return "Too many references: can't splice";
 804bd57:	8d 81 80 e4 ff ff    	lea    -0x1b80(%ecx),%eax
 804bd5d:	eb 3d                	jmp    804bd9c <strerror+0x71d>
                case ETIMEDOUT: return "Connection timed out";
 804bd5f:	8d 81 a2 e4 ff ff    	lea    -0x1b5e(%ecx),%eax
 804bd65:	eb 35                	jmp    804bd9c <strerror+0x71d>
                case ECONNREFUSED: return "Connection refused";
 804bd67:	8d 81 b7 e4 ff ff    	lea    -0x1b49(%ecx),%eax
 804bd6d:	eb 2d                	jmp    804bd9c <strerror+0x71d>
                case EHOSTDOWN: return "Host is down";
 804bd6f:	8d 81 ca e4 ff ff    	lea    -0x1b36(%ecx),%eax
 804bd75:	eb 25                	jmp    804bd9c <strerror+0x71d>
                case EHOSTUNREACH: return "No route to host";
 804bd77:	8d 81 d7 e4 ff ff    	lea    -0x1b29(%ecx),%eax
 804bd7d:	eb 1d                	jmp    804bd9c <strerror+0x71d>
                case EALREADY: return "operation already in progress";
 804bd7f:	8d 81 e8 e4 ff ff    	lea    -0x1b18(%ecx),%eax
 804bd85:	eb 15                	jmp    804bd9c <strerror+0x71d>
                case EINPROGRESS: return "operation now in progress";
 804bd87:	8d 81 06 e5 ff ff    	lea    -0x1afa(%ecx),%eax
 804bd8d:	eb 0d                	jmp    804bd9c <strerror+0x71d>
                case ESTALE: return "Stale NFS file handle";
 804bd8f:	8d 81 20 e5 ff ff    	lea    -0x1ae0(%ecx),%eax
 804bd95:	eb 05                	jmp    804bd9c <strerror+0x71d>
                default: return 0;
 804bd97:	b8 00 00 00 00       	mov    $0x0,%eax
        }
}
 804bd9c:	5d                   	pop    %ebp
 804bd9d:	c3                   	ret    
