
user/bin/uname.exec:     file format elf32-i386


Disassembly of section .text:

08048094 <main>:

static int doflag(int c);
static struct utsname un;

int main(int argc, char **argv)
{
 8048094:	55                   	push   %ebp
 8048095:	89 e5                	mov    %esp,%ebp
 8048097:	83 e4 f0             	and    $0xfffffff0,%esp
 804809a:	83 ec 20             	sub    $0x20,%esp
        int     ii;

        uname(&un);
 804809d:	c7 04 24 00 03 05 08 	movl   $0x8050300,(%esp)
 80480a4:	e8 56 12 00 00       	call   80492ff <uname>

        for (ii = 1; ii < argc ; ii++) {
 80480a9:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
 80480b0:	00 
 80480b1:	eb 53                	jmp    8048106 <main+0x72>
                if (argv[ii][0] == '-') {
 80480b3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80480b7:	c1 e0 02             	shl    $0x2,%eax
 80480ba:	03 45 0c             	add    0xc(%ebp),%eax
 80480bd:	8b 00                	mov    (%eax),%eax
 80480bf:	0f b6 00             	movzbl (%eax),%eax
 80480c2:	3c 2d                	cmp    $0x2d,%al
 80480c4:	75 3b                	jne    8048101 <main+0x6d>
                        char *str;
                        str = &argv[ii][1];
 80480c6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80480ca:	c1 e0 02             	shl    $0x2,%eax
 80480cd:	03 45 0c             	add    0xc(%ebp),%eax
 80480d0:	8b 00                	mov    (%eax),%eax
 80480d2:	83 c0 01             	add    $0x1,%eax
 80480d5:	89 44 24 18          	mov    %eax,0x18(%esp)
                        while (*str) {
 80480d9:	eb 1b                	jmp    80480f6 <main+0x62>
                                if (doflag(*str++) < 0)
 80480db:	8b 44 24 18          	mov    0x18(%esp),%eax
 80480df:	0f b6 00             	movzbl (%eax),%eax
 80480e2:	0f be c0             	movsbl %al,%eax
 80480e5:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
 80480ea:	89 04 24             	mov    %eax,(%esp)
 80480ed:	e8 53 00 00 00       	call   8048145 <doflag>
 80480f2:	85 c0                	test   %eax,%eax
 80480f4:	78 47                	js     804813d <main+0xa9>

        for (ii = 1; ii < argc ; ii++) {
                if (argv[ii][0] == '-') {
                        char *str;
                        str = &argv[ii][1];
                        while (*str) {
 80480f6:	8b 44 24 18          	mov    0x18(%esp),%eax
 80480fa:	0f b6 00             	movzbl (%eax),%eax
 80480fd:	84 c0                	test   %al,%al
 80480ff:	75 da                	jne    80480db <main+0x47>
{
        int     ii;

        uname(&un);

        for (ii = 1; ii < argc ; ii++) {
 8048101:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
 8048106:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804810a:	3b 45 08             	cmp    0x8(%ebp),%eax
 804810d:	7c a4                	jl     80480b3 <main+0x1f>
                                if (doflag(*str++) < 0)
                                        goto usage;
                        }
                }
        }
	if (argc == 1)
 804810f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
 8048113:	75 0c                	jne    8048121 <main+0x8d>
                doflag('s');
 8048115:	c7 04 24 73 00 00 00 	movl   $0x73,(%esp)
 804811c:	e8 24 00 00 00       	call   8048145 <doflag>
        fprintf(stdout, "\n");
 8048121:	a1 d4 01 05 08       	mov    0x80501d4,%eax
 8048126:	c7 44 24 04 ee d6 04 	movl   $0x804d6ee,0x4(%esp)
 804812d:	08 
 804812e:	89 04 24             	mov    %eax,(%esp)
 8048131:	e8 86 01 00 00       	call   80482bc <fprintf>
        return 0;
 8048136:	b8 00 00 00 00       	mov    $0x0,%eax
 804813b:	eb 06                	jmp    8048143 <main+0xaf>
                if (argv[ii][0] == '-') {
                        char *str;
                        str = &argv[ii][1];
                        while (*str) {
                                if (doflag(*str++) < 0)
                                        goto usage;
 804813d:	90                   	nop
                doflag('s');
        fprintf(stdout, "\n");
        return 0;

usage:
        return 1;
 804813e:	b8 01 00 00 00       	mov    $0x1,%eax
}
 8048143:	c9                   	leave  
 8048144:	c3                   	ret    

08048145 <doflag>:

static int doflag(int c)
{
 8048145:	55                   	push   %ebp
 8048146:	89 e5                	mov    %esp,%ebp
 8048148:	83 ec 18             	sub    $0x18,%esp
        switch (c) {
 804814b:	8b 45 08             	mov    0x8(%ebp),%eax
 804814e:	83 e8 54             	sub    $0x54,%eax
 8048151:	83 f8 22             	cmp    $0x22,%eax
 8048154:	0f 87 0c 01 00 00    	ja     8048266 <doflag+0x121>
 804815a:	8b 04 85 f8 d6 04 08 	mov    0x804d6f8(,%eax,4),%eax
 8048161:	ff e0                	jmp    *%eax
                case 'a':
                        printf("%s", TAS);
 8048163:	a1 c0 01 05 08       	mov    0x80501c0,%eax
 8048168:	89 44 24 04          	mov    %eax,0x4(%esp)
 804816c:	c7 04 24 f0 d6 04 08 	movl   $0x804d6f0,(%esp)
 8048173:	e8 0c 01 00 00       	call   8048284 <printf>
                        printf("%s ", un.sysname);
 8048178:	c7 44 24 04 00 03 05 	movl   $0x8050300,0x4(%esp)
 804817f:	08 
 8048180:	c7 04 24 f3 d6 04 08 	movl   $0x804d6f3,(%esp)
 8048187:	e8 f8 00 00 00       	call   8048284 <printf>
                        printf("%s ", un.nodename);
 804818c:	c7 44 24 04 80 03 05 	movl   $0x8050380,0x4(%esp)
 8048193:	08 
 8048194:	c7 04 24 f3 d6 04 08 	movl   $0x804d6f3,(%esp)
 804819b:	e8 e4 00 00 00       	call   8048284 <printf>
                        printf("%s ", un.release);
 80481a0:	c7 44 24 04 00 04 05 	movl   $0x8050400,0x4(%esp)
 80481a7:	08 
 80481a8:	c7 04 24 f3 d6 04 08 	movl   $0x804d6f3,(%esp)
 80481af:	e8 d0 00 00 00       	call   8048284 <printf>
                        printf("%s ", un.version);
 80481b4:	c7 44 24 04 80 04 05 	movl   $0x8050480,0x4(%esp)
 80481bb:	08 
 80481bc:	c7 04 24 f3 d6 04 08 	movl   $0x804d6f3,(%esp)
 80481c3:	e8 bc 00 00 00       	call   8048284 <printf>
                        printf("%s ", un.machine);
 80481c8:	c7 44 24 04 00 05 05 	movl   $0x8050500,0x4(%esp)
 80481cf:	08 
 80481d0:	c7 04 24 f3 d6 04 08 	movl   $0x804d6f3,(%esp)
 80481d7:	e8 a8 00 00 00       	call   8048284 <printf>
                        break;
 80481dc:	e9 8c 00 00 00       	jmp    804826d <doflag+0x128>
                case 's':
                        printf("%s", un.sysname);
 80481e1:	c7 44 24 04 00 03 05 	movl   $0x8050300,0x4(%esp)
 80481e8:	08 
 80481e9:	c7 04 24 f0 d6 04 08 	movl   $0x804d6f0,(%esp)
 80481f0:	e8 8f 00 00 00       	call   8048284 <printf>
                        break;
 80481f5:	eb 76                	jmp    804826d <doflag+0x128>
                case 'n':
                        printf("%s", un.nodename);
 80481f7:	c7 44 24 04 80 03 05 	movl   $0x8050380,0x4(%esp)
 80481fe:	08 
 80481ff:	c7 04 24 f0 d6 04 08 	movl   $0x804d6f0,(%esp)
 8048206:	e8 79 00 00 00       	call   8048284 <printf>
                        break;
 804820b:	eb 60                	jmp    804826d <doflag+0x128>
                case 'r':
                        printf("%s", un.release);
 804820d:	c7 44 24 04 00 04 05 	movl   $0x8050400,0x4(%esp)
 8048214:	08 
 8048215:	c7 04 24 f0 d6 04 08 	movl   $0x804d6f0,(%esp)
 804821c:	e8 63 00 00 00       	call   8048284 <printf>
                        break;
 8048221:	eb 4a                	jmp    804826d <doflag+0x128>
                case 'T':
                        printf("%s", TAS);
 8048223:	a1 c0 01 05 08       	mov    0x80501c0,%eax
 8048228:	89 44 24 04          	mov    %eax,0x4(%esp)
 804822c:	c7 04 24 f0 d6 04 08 	movl   $0x804d6f0,(%esp)
 8048233:	e8 4c 00 00 00       	call   8048284 <printf>
                        break;
 8048238:	eb 33                	jmp    804826d <doflag+0x128>
                case 'v':
                        printf("%s", un.version);
 804823a:	c7 44 24 04 80 04 05 	movl   $0x8050480,0x4(%esp)
 8048241:	08 
 8048242:	c7 04 24 f0 d6 04 08 	movl   $0x804d6f0,(%esp)
 8048249:	e8 36 00 00 00       	call   8048284 <printf>
                        break;
 804824e:	eb 1d                	jmp    804826d <doflag+0x128>
                case 'm':
                        printf("%s", un.machine);
 8048250:	c7 44 24 04 00 05 05 	movl   $0x8050500,0x4(%esp)
 8048257:	08 
 8048258:	c7 04 24 f0 d6 04 08 	movl   $0x804d6f0,(%esp)
 804825f:	e8 20 00 00 00       	call   8048284 <printf>
                        break;
 8048264:	eb 07                	jmp    804826d <doflag+0x128>
                default:
                        return -1;
 8048266:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804826b:	eb 05                	jmp    8048272 <doflag+0x12d>
        }
        return 0;
 804826d:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8048272:	c9                   	leave  
 8048273:	c3                   	ret    

08048274 <__libc_static_entry>:
#ifndef __DYNAMIC__

.globl __libc_static_entry

__libc_static_entry:
	addl $4, %esp; /* Make sure when we overwrite dummy return address
 8048274:	83 c4 04             	add    $0x4,%esp
	                  with the correct one, so args will be in the right
	                  place when we call main */
	call main;
 8048277:	e8 18 fe ff ff       	call   8048094 <main>
	push %eax; /* Argument to exit is return value from main */
 804827c:	50                   	push   %eax
	call exit;
 804827d:	e8 56 04 00 00       	call   80486d8 <exit>
 8048282:	90                   	nop
 8048283:	90                   	nop

08048284 <printf>:

#include "stdio.h"
#include "unistd.h"

int printf(const char *fmt, ...)
{
 8048284:	55                   	push   %ebp
 8048285:	89 e5                	mov    %esp,%ebp
 8048287:	53                   	push   %ebx
 8048288:	83 ec 24             	sub    $0x24,%esp
 804828b:	e8 d5 01 00 00       	call   8048465 <__i686.get_pc_thunk.bx>
 8048290:	81 c3 1c 7f 00 00    	add    $0x7f1c,%ebx
        va_list args;
        int i;

        va_start(args, fmt);
 8048296:	8d 55 0c             	lea    0xc(%ebp),%edx
 8048299:	8d 45 f0             	lea    -0x10(%ebp),%eax
 804829c:	89 10                	mov    %edx,(%eax)
        i = vprintf(fmt, args);
 804829e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80482a1:	89 44 24 04          	mov    %eax,0x4(%esp)
 80482a5:	8b 45 08             	mov    0x8(%ebp),%eax
 80482a8:	89 04 24             	mov    %eax,(%esp)
 80482ab:	e8 d0 00 00 00       	call   8048380 <vprintf>
 80482b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 80482b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 80482b6:	83 c4 24             	add    $0x24,%esp
 80482b9:	5b                   	pop    %ebx
 80482ba:	5d                   	pop    %ebp
 80482bb:	c3                   	ret    

080482bc <fprintf>:

int fprintf(FILE *stream, const char *fmt, ...)
{
 80482bc:	55                   	push   %ebp
 80482bd:	89 e5                	mov    %esp,%ebp
 80482bf:	53                   	push   %ebx
 80482c0:	83 ec 24             	sub    $0x24,%esp
 80482c3:	e8 9d 01 00 00       	call   8048465 <__i686.get_pc_thunk.bx>
 80482c8:	81 c3 e4 7e 00 00    	add    $0x7ee4,%ebx
        va_list args;
        int i;

        va_start(args, fmt);
 80482ce:	8d 55 10             	lea    0x10(%ebp),%edx
 80482d1:	8d 45 f0             	lea    -0x10(%ebp),%eax
 80482d4:	89 10                	mov    %edx,(%eax)
        i = vfprintf(stream, fmt, args);
 80482d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80482d9:	89 44 24 08          	mov    %eax,0x8(%esp)
 80482dd:	8b 45 0c             	mov    0xc(%ebp),%eax
 80482e0:	89 44 24 04          	mov    %eax,0x4(%esp)
 80482e4:	8b 45 08             	mov    0x8(%ebp),%eax
 80482e7:	89 04 24             	mov    %eax,(%esp)
 80482ea:	e8 c7 00 00 00       	call   80483b6 <vfprintf>
 80482ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 80482f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 80482f5:	83 c4 24             	add    $0x24,%esp
 80482f8:	5b                   	pop    %ebx
 80482f9:	5d                   	pop    %ebp
 80482fa:	c3                   	ret    

080482fb <sprintf>:

int sprintf(char *buf, const char *fmt, ...)
{
 80482fb:	55                   	push   %ebp
 80482fc:	89 e5                	mov    %esp,%ebp
 80482fe:	53                   	push   %ebx
 80482ff:	83 ec 24             	sub    $0x24,%esp
 8048302:	e8 5e 01 00 00       	call   8048465 <__i686.get_pc_thunk.bx>
 8048307:	81 c3 a5 7e 00 00    	add    $0x7ea5,%ebx
        va_list args;
        int i;

        va_start(args, fmt);
 804830d:	8d 55 10             	lea    0x10(%ebp),%edx
 8048310:	8d 45 f0             	lea    -0x10(%ebp),%eax
 8048313:	89 10                	mov    %edx,(%eax)
        i = vsprintf(buf, fmt, args);
 8048315:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048318:	89 44 24 08          	mov    %eax,0x8(%esp)
 804831c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804831f:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048323:	8b 45 08             	mov    0x8(%ebp),%eax
 8048326:	89 04 24             	mov    %eax,(%esp)
 8048329:	e8 f4 00 00 00       	call   8048422 <vsprintf>
 804832e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 8048331:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048334:	83 c4 24             	add    $0x24,%esp
 8048337:	5b                   	pop    %ebx
 8048338:	5d                   	pop    %ebp
 8048339:	c3                   	ret    

0804833a <snprintf>:

int snprintf(char *buf, size_t size, const char *fmt, ...)
{
 804833a:	55                   	push   %ebp
 804833b:	89 e5                	mov    %esp,%ebp
 804833d:	53                   	push   %ebx
 804833e:	83 ec 24             	sub    $0x24,%esp
 8048341:	e8 1f 01 00 00       	call   8048465 <__i686.get_pc_thunk.bx>
 8048346:	81 c3 66 7e 00 00    	add    $0x7e66,%ebx
        va_list args;
        int i;

        va_start(args, fmt);
 804834c:	8d 55 14             	lea    0x14(%ebp),%edx
 804834f:	8d 45 f0             	lea    -0x10(%ebp),%eax
 8048352:	89 10                	mov    %edx,(%eax)
        i = vsnprintf(buf, size, fmt, args);
 8048354:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048357:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804835b:	8b 45 10             	mov    0x10(%ebp),%eax
 804835e:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048362:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048365:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048369:	8b 45 08             	mov    0x8(%ebp),%eax
 804836c:	89 04 24             	mov    %eax,(%esp)
 804836f:	e8 e3 14 00 00       	call   8049857 <vsnprintf>
 8048374:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 8048377:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804837a:	83 c4 24             	add    $0x24,%esp
 804837d:	5b                   	pop    %ebx
 804837e:	5d                   	pop    %ebp
 804837f:	c3                   	ret    

08048380 <vprintf>:

int vprintf(const char *fmt, va_list args)
{
 8048380:	55                   	push   %ebp
 8048381:	89 e5                	mov    %esp,%ebp
 8048383:	53                   	push   %ebx
 8048384:	83 ec 14             	sub    $0x14,%esp
 8048387:	e8 d9 00 00 00       	call   8048465 <__i686.get_pc_thunk.bx>
 804838c:	81 c3 20 7e 00 00    	add    $0x7e20,%ebx
        return vfprintf(stdout, fmt, args);
 8048392:	8b 83 f4 ff ff ff    	mov    -0xc(%ebx),%eax
 8048398:	8b 00                	mov    (%eax),%eax
 804839a:	8b 55 0c             	mov    0xc(%ebp),%edx
 804839d:	89 54 24 08          	mov    %edx,0x8(%esp)
 80483a1:	8b 55 08             	mov    0x8(%ebp),%edx
 80483a4:	89 54 24 04          	mov    %edx,0x4(%esp)
 80483a8:	89 04 24             	mov    %eax,(%esp)
 80483ab:	e8 06 00 00 00       	call   80483b6 <vfprintf>
}
 80483b0:	83 c4 14             	add    $0x14,%esp
 80483b3:	5b                   	pop    %ebx
 80483b4:	5d                   	pop    %ebp
 80483b5:	c3                   	ret    

080483b6 <vfprintf>:

#define __LIBC_PRINTF_BUFSIZE 1024
int vfprintf(FILE *stream, const char *fmt, va_list args)
{
 80483b6:	55                   	push   %ebp
 80483b7:	89 e5                	mov    %esp,%ebp
 80483b9:	53                   	push   %ebx
 80483ba:	81 ec 24 04 00 00    	sub    $0x424,%esp
 80483c0:	e8 a0 00 00 00       	call   8048465 <__i686.get_pc_thunk.bx>
 80483c5:	81 c3 e7 7d 00 00    	add    $0x7de7,%ebx
        /* I'm really lazy */
        char buf[__LIBC_PRINTF_BUFSIZE];
        int ret = vsnprintf(buf, __LIBC_PRINTF_BUFSIZE, fmt, args);
 80483cb:	8b 45 10             	mov    0x10(%ebp),%eax
 80483ce:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80483d2:	8b 45 0c             	mov    0xc(%ebp),%eax
 80483d5:	89 44 24 08          	mov    %eax,0x8(%esp)
 80483d9:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
 80483e0:	00 
 80483e1:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
 80483e7:	89 04 24             	mov    %eax,(%esp)
 80483ea:	e8 68 14 00 00       	call   8049857 <vsnprintf>
 80483ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (ret > 0) {
 80483f2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 80483f6:	7e 1e                	jle    8048416 <vfprintf+0x60>
                write(*stream, buf, ret);
 80483f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80483fb:	8b 45 08             	mov    0x8(%ebp),%eax
 80483fe:	8b 00                	mov    (%eax),%eax
 8048400:	89 54 24 08          	mov    %edx,0x8(%esp)
 8048404:	8d 95 f4 fb ff ff    	lea    -0x40c(%ebp),%edx
 804840a:	89 54 24 04          	mov    %edx,0x4(%esp)
 804840e:	89 04 24             	mov    %eax,(%esp)
 8048411:	e8 68 07 00 00       	call   8048b7e <write>
        }
        return ret;
 8048416:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048419:	81 c4 24 04 00 00    	add    $0x424,%esp
 804841f:	5b                   	pop    %ebx
 8048420:	5d                   	pop    %ebp
 8048421:	c3                   	ret    

08048422 <vsprintf>:

int vsprintf(char *buf, const char *fmt, va_list args)
{
 8048422:	55                   	push   %ebp
 8048423:	89 e5                	mov    %esp,%ebp
 8048425:	53                   	push   %ebx
 8048426:	83 ec 14             	sub    $0x14,%esp
 8048429:	e8 37 00 00 00       	call   8048465 <__i686.get_pc_thunk.bx>
 804842e:	81 c3 7e 7d 00 00    	add    $0x7d7e,%ebx
        return vsnprintf(buf, 0xffffffffUL, fmt, args);
 8048434:	8b 45 10             	mov    0x10(%ebp),%eax
 8048437:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804843b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804843e:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048442:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
 8048449:	ff 
 804844a:	8b 45 08             	mov    0x8(%ebp),%eax
 804844d:	89 04 24             	mov    %eax,(%esp)
 8048450:	e8 02 14 00 00       	call   8049857 <vsnprintf>
}
 8048455:	83 c4 14             	add    $0x14,%esp
 8048458:	5b                   	pop    %ebx
 8048459:	5d                   	pop    %ebp
 804845a:	c3                   	ret    

0804845b <fflush>:

int fflush(FILE *stream)
{
 804845b:	55                   	push   %ebp
 804845c:	89 e5                	mov    %esp,%ebp
        /* no-op */
        return 0;
 804845e:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8048463:	5d                   	pop    %ebp
 8048464:	c3                   	ret    

08048465 <__i686.get_pc_thunk.bx>:
 8048465:	8b 1c 24             	mov    (%esp),%ebx
 8048468:	c3                   	ret    
 8048469:	90                   	nop
 804846a:	90                   	nop
 804846b:	90                   	nop

0804846c <trap>:
#include "errno.h"

#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
 804846c:	55                   	push   %ebp
 804846d:	89 e5                	mov    %esp,%ebp
 804846f:	56                   	push   %esi
 8048470:	83 ec 14             	sub    $0x14,%esp
 8048473:	e8 3f 0f 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 8048478:	81 c1 34 7d 00 00    	add    $0x7d34,%ecx
        int ret;
        __asm__ volatile(
 804847e:	8b 45 08             	mov    0x8(%ebp),%eax
 8048481:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8048484:	8b 55 0c             	mov    0xc(%ebp),%edx
 8048487:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804848a:	cd 2e                	int    $0x2e
 804848c:	89 c6                	mov    %eax,%esi
 804848e:	89 75 f8             	mov    %esi,-0x8(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048491:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8048498:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804849b:	cd 2e                	int    $0x2e
 804849d:	89 c2                	mov    %eax,%edx
 804849f:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80484a5:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80484a7:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
 80484aa:	83 c4 14             	add    $0x14,%esp
 80484ad:	5e                   	pop    %esi
 80484ae:	5d                   	pop    %ebp
 80484af:	c3                   	ret    

080484b0 <sbrk>:
static void     (*atexit_func[MAX_EXIT_HANDLERS])();
static int      atexit_handlers = 0;


void *sbrk(intptr_t incr)
{
 80484b0:	55                   	push   %ebp
 80484b1:	89 e5                	mov    %esp,%ebp
 80484b3:	56                   	push   %esi
 80484b4:	53                   	push   %ebx
 80484b5:	83 ec 30             	sub    $0x30,%esp
 80484b8:	e8 a8 ff ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 80484bd:	81 c3 ef 7c 00 00    	add    $0x7cef,%ebx
        uintptr_t oldbrk;

        /* If we don't have a saved break, find it from the kernel */
        if (!__curbrk) {
 80484c3:	8b 83 d4 03 00 00    	mov    0x3d4(%ebx),%eax
 80484c9:	85 c0                	test   %eax,%eax
 80484cb:	75 51                	jne    804851e <sbrk+0x6e>
 80484cd:	c7 45 f0 2c 00 00 00 	movl   $0x2c,-0x10(%ebp)
 80484d4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80484db:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80484de:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80484e1:	8b 55 ec             	mov    -0x14(%ebp),%edx
 80484e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80484e7:	cd 2e                	int    $0x2e
 80484e9:	89 c6                	mov    %eax,%esi
 80484eb:	89 75 e8             	mov    %esi,-0x18(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80484ee:	c7 45 e4 27 00 00 00 	movl   $0x27,-0x1c(%ebp)
 80484f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80484f8:	cd 2e                	int    $0x2e
 80484fa:	89 c2                	mov    %eax,%edx
 80484fc:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048502:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048504:	8b 45 e8             	mov    -0x18(%ebp),%eax
                if (0 > (long)(__curbrk = (void *) trap(SYS_brk, (uint32_t) NULL))) {
 8048507:	89 83 d4 03 00 00    	mov    %eax,0x3d4(%ebx)
 804850d:	8b 83 d4 03 00 00    	mov    0x3d4(%ebx),%eax
 8048513:	85 c0                	test   %eax,%eax
 8048515:	79 07                	jns    804851e <sbrk+0x6e>
                        return (void *) -1;
 8048517:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804851c:	eb 5b                	jmp    8048579 <sbrk+0xc9>
                }
        }

        oldbrk = (uintptr_t) __curbrk;
 804851e:	8b 83 d4 03 00 00    	mov    0x3d4(%ebx),%eax
 8048524:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /* Increment or decrement the saved break */

        if (incr < 0) {
 8048527:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804852b:	79 2a                	jns    8048557 <sbrk+0xa7>
                if ((uintptr_t) - incr > oldbrk) {
 804852d:	8b 45 08             	mov    0x8(%ebp),%eax
 8048530:	f7 d8                	neg    %eax
 8048532:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 8048535:	76 07                	jbe    804853e <sbrk+0x8e>
                        return (void *) -1;
 8048537:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804853c:	eb 3b                	jmp    8048579 <sbrk+0xc9>
                } else if (brk((void *)(oldbrk - (uintptr_t) - incr)) < 0) {
 804853e:	8b 45 08             	mov    0x8(%ebp),%eax
 8048541:	03 45 f4             	add    -0xc(%ebp),%eax
 8048544:	89 04 24             	mov    %eax,(%esp)
 8048547:	e8 34 00 00 00       	call   8048580 <brk>
 804854c:	85 c0                	test   %eax,%eax
 804854e:	79 26                	jns    8048576 <sbrk+0xc6>
                        return (void *) -1;
 8048550:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8048555:	eb 22                	jmp    8048579 <sbrk+0xc9>
                }
        } else if (incr > 0) {
 8048557:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804855b:	7e 19                	jle    8048576 <sbrk+0xc6>
                if (brk((void *)(oldbrk + (uintptr_t) incr)) < 0) {
 804855d:	8b 45 08             	mov    0x8(%ebp),%eax
 8048560:	03 45 f4             	add    -0xc(%ebp),%eax
 8048563:	89 04 24             	mov    %eax,(%esp)
 8048566:	e8 15 00 00 00       	call   8048580 <brk>
 804856b:	85 c0                	test   %eax,%eax
 804856d:	79 07                	jns    8048576 <sbrk+0xc6>
                        return (void *) -1;
 804856f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8048574:	eb 03                	jmp    8048579 <sbrk+0xc9>
                }
        }
        return (void *) oldbrk;
 8048576:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048579:	83 c4 30             	add    $0x30,%esp
 804857c:	5b                   	pop    %ebx
 804857d:	5e                   	pop    %esi
 804857e:	5d                   	pop    %ebp
 804857f:	c3                   	ret    

08048580 <brk>:

int brk(void *addr)
{
 8048580:	55                   	push   %ebp
 8048581:	89 e5                	mov    %esp,%ebp
 8048583:	56                   	push   %esi
 8048584:	83 ec 14             	sub    $0x14,%esp
 8048587:	e8 2b 0e 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 804858c:	81 c1 20 7c 00 00    	add    $0x7c20,%ecx
        if (NULL == addr)
 8048592:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8048596:	75 07                	jne    804859f <brk+0x1f>
                return -1;
 8048598:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804859d:	eb 57                	jmp    80485f6 <brk+0x76>
        void *newbrk = (void *) trap(SYS_brk, (uint32_t) addr);
 804859f:	8b 45 08             	mov    0x8(%ebp),%eax
 80485a2:	c7 45 f4 2c 00 00 00 	movl   $0x2c,-0xc(%ebp)
 80485a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80485ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80485af:	89 45 e8             	mov    %eax,-0x18(%ebp)
 80485b2:	8b 55 f0             	mov    -0x10(%ebp),%edx
 80485b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80485b8:	cd 2e                	int    $0x2e
 80485ba:	89 c6                	mov    %eax,%esi
 80485bc:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80485bf:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 80485c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80485c9:	cd 2e                	int    $0x2e
 80485cb:	89 c2                	mov    %eax,%edx
 80485cd:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80485d3:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80485d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80485d8:	89 45 f8             	mov    %eax,-0x8(%ebp)
        if (newbrk == (void *) -1)
 80485db:	83 7d f8 ff          	cmpl   $0xffffffff,-0x8(%ebp)
 80485df:	75 07                	jne    80485e8 <brk+0x68>
                return -1;
 80485e1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80485e6:	eb 0e                	jmp    80485f6 <brk+0x76>
        __curbrk = newbrk;
 80485e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80485eb:	89 81 d4 03 00 00    	mov    %eax,0x3d4(%ecx)
        return 0;
 80485f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
 80485f6:	83 c4 14             	add    $0x14,%esp
 80485f9:	5e                   	pop    %esi
 80485fa:	5d                   	pop    %ebp
 80485fb:	c3                   	ret    

080485fc <fork>:

int fork(void)
{
 80485fc:	55                   	push   %ebp
 80485fd:	89 e5                	mov    %esp,%ebp
 80485ff:	56                   	push   %esi
 8048600:	83 ec 14             	sub    $0x14,%esp
 8048603:	e8 af 0d 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 8048608:	81 c1 a4 7b 00 00    	add    $0x7ba4,%ecx
 804860e:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
 8048615:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804861c:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804861f:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8048622:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048625:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048628:	cd 2e                	int    $0x2e
 804862a:	89 c6                	mov    %eax,%esi
 804862c:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804862f:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8048636:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048639:	cd 2e                	int    $0x2e
 804863b:	89 c2                	mov    %eax,%edx
 804863d:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048643:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048645:	8b 45 f0             	mov    -0x10(%ebp),%eax
        return trap(SYS_fork, 0);
}
 8048648:	83 c4 14             	add    $0x14,%esp
 804864b:	5e                   	pop    %esi
 804864c:	5d                   	pop    %ebp
 804864d:	c3                   	ret    

0804864e <atexit>:

int atexit(void (*func)(void))
{
 804864e:	55                   	push   %ebp
 804864f:	89 e5                	mov    %esp,%ebp
 8048651:	e8 61 0d 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 8048656:	81 c1 56 7b 00 00    	add    $0x7b56,%ecx
        if (atexit_handlers < MAX_EXIT_HANDLERS) {
 804865c:	8b 81 74 04 00 00    	mov    0x474(%ecx),%eax
 8048662:	83 f8 1f             	cmp    $0x1f,%eax
 8048665:	7f 20                	jg     8048687 <atexit+0x39>
                atexit_func[atexit_handlers++] = func;
 8048667:	8b 81 74 04 00 00    	mov    0x474(%ecx),%eax
 804866d:	8b 55 08             	mov    0x8(%ebp),%edx
 8048670:	89 94 81 f4 03 00 00 	mov    %edx,0x3f4(%ecx,%eax,4)
 8048677:	83 c0 01             	add    $0x1,%eax
 804867a:	89 81 74 04 00 00    	mov    %eax,0x474(%ecx)
                return 0;
 8048680:	b8 00 00 00 00       	mov    $0x0,%eax
 8048685:	eb 05                	jmp    804868c <atexit+0x3e>
        }

        return 1;
 8048687:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804868c:	5d                   	pop    %ebp
 804868d:	c3                   	ret    

0804868e <_exit>:

void _exit(int status)
{
 804868e:	55                   	push   %ebp
 804868f:	89 e5                	mov    %esp,%ebp
 8048691:	56                   	push   %esi
 8048692:	83 ec 14             	sub    $0x14,%esp
 8048695:	e8 1d 0d 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 804869a:	81 c1 12 7b 00 00    	add    $0x7b12,%ecx
        trap(SYS_exit, (uint32_t) status);
 80486a0:	8b 45 08             	mov    0x8(%ebp),%eax
 80486a3:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
 80486aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80486ad:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80486b0:	89 45 e8             	mov    %eax,-0x18(%ebp)
 80486b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80486b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80486b9:	cd 2e                	int    $0x2e
 80486bb:	89 c6                	mov    %eax,%esi
 80486bd:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80486c0:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 80486c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80486ca:	cd 2e                	int    $0x2e
 80486cc:	89 c2                	mov    %eax,%edx
 80486ce:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80486d4:	89 10                	mov    %edx,(%eax)

        /* this keeps gcc from warning us about exit returning, because it
         * expects exit not to. We never actually get here. */
        for (;;);
 80486d6:	eb fe                	jmp    80486d6 <_exit+0x48>

080486d8 <exit>:
}

void exit(int status)
{
 80486d8:	55                   	push   %ebp
 80486d9:	89 e5                	mov    %esp,%ebp
 80486db:	53                   	push   %ebx
 80486dc:	83 ec 14             	sub    $0x14,%esp
 80486df:	e8 81 fd ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 80486e4:	81 c3 c8 7a 00 00    	add    $0x7ac8,%ebx
        while (atexit_handlers--) {
 80486ea:	eb 0f                	jmp    80486fb <exit+0x23>
                atexit_func[atexit_handlers]();
 80486ec:	8b 83 74 04 00 00    	mov    0x474(%ebx),%eax
 80486f2:	8b 84 83 f4 03 00 00 	mov    0x3f4(%ebx,%eax,4),%eax
 80486f9:	ff d0                	call   *%eax
        for (;;);
}

void exit(int status)
{
        while (atexit_handlers--) {
 80486fb:	8b 83 74 04 00 00    	mov    0x474(%ebx),%eax
 8048701:	85 c0                	test   %eax,%eax
 8048703:	0f 95 c2             	setne  %dl
 8048706:	83 e8 01             	sub    $0x1,%eax
 8048709:	89 83 74 04 00 00    	mov    %eax,0x474(%ebx)
 804870f:	84 d2                	test   %dl,%dl
 8048711:	75 d9                	jne    80486ec <exit+0x14>
                atexit_func[atexit_handlers]();
        }

        _exit(status);
 8048713:	8b 45 08             	mov    0x8(%ebp),%eax
 8048716:	89 04 24             	mov    %eax,(%esp)
 8048719:	e8 70 ff ff ff       	call   804868e <_exit>
        exit(status); /* gcc doesn't realize that _exit() exits */
 804871e:	8b 45 08             	mov    0x8(%ebp),%eax
 8048721:	89 04 24             	mov    %eax,(%esp)
 8048724:	e8 af ff ff ff       	call   80486d8 <exit>
}
 8048729:	83 c4 14             	add    $0x14,%esp
 804872c:	5b                   	pop    %ebx
 804872d:	5d                   	pop    %ebp
 804872e:	c3                   	ret    

0804872f <yield>:

void yield(void)
{
 804872f:	55                   	push   %ebp
 8048730:	89 e5                	mov    %esp,%ebp
 8048732:	53                   	push   %ebx
 8048733:	83 ec 14             	sub    $0x14,%esp
 8048736:	e8 2a fd ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804873b:	81 c3 71 7a 00 00    	add    $0x7a71,%ebx
        /* Due to a Bochs bug, the yield syscall itself is highly unyielding
         * (for instance, it's impossible to type while a process is in a yield
         * loop. This is good enough. */
        (fork() ? wait(NULL) : exit(0));
 8048741:	e8 b6 fe ff ff       	call   80485fc <fork>
 8048746:	85 c0                	test   %eax,%eax
 8048748:	74 0e                	je     8048758 <yield+0x29>
 804874a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8048751:	e8 14 00 00 00       	call   804876a <wait>
 8048756:	eb 0c                	jmp    8048764 <yield+0x35>
 8048758:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804875f:	e8 74 ff ff ff       	call   80486d8 <exit>
}
 8048764:	83 c4 14             	add    $0x14,%esp
 8048767:	5b                   	pop    %ebx
 8048768:	5d                   	pop    %ebp
 8048769:	c3                   	ret    

0804876a <wait>:

pid_t wait(int *status)
{
 804876a:	55                   	push   %ebp
 804876b:	89 e5                	mov    %esp,%ebp
 804876d:	56                   	push   %esi
 804876e:	83 ec 24             	sub    $0x24,%esp
 8048771:	e8 41 0c 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 8048776:	81 c1 36 7a 00 00    	add    $0x7a36,%ecx
        waitpid_args_t args;

        args.wpa_pid = -1;
 804877c:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
        args.wpa_options = 0;
 8048783:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
        args.wpa_status = status;
 804878a:	8b 45 08             	mov    0x8(%ebp),%eax
 804878d:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_waitpid, (uint32_t) &args);
 8048790:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048793:	c7 45 f8 07 00 00 00 	movl   $0x7,-0x8(%ebp)
 804879a:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804879d:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80487a0:	89 45 d8             	mov    %eax,-0x28(%ebp)
 80487a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80487a6:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80487a9:	cd 2e                	int    $0x2e
 80487ab:	89 c6                	mov    %eax,%esi
 80487ad:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80487b0:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 80487b7:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80487ba:	cd 2e                	int    $0x2e
 80487bc:	89 c2                	mov    %eax,%edx
 80487be:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80487c4:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80487c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 80487c9:	83 c4 24             	add    $0x24,%esp
 80487cc:	5e                   	pop    %esi
 80487cd:	5d                   	pop    %ebp
 80487ce:	c3                   	ret    

080487cf <waitpid>:

pid_t waitpid(pid_t pid, int options, int *status)
{
 80487cf:	55                   	push   %ebp
 80487d0:	89 e5                	mov    %esp,%ebp
 80487d2:	56                   	push   %esi
 80487d3:	83 ec 24             	sub    $0x24,%esp
 80487d6:	e8 dc 0b 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 80487db:	81 c1 d1 79 00 00    	add    $0x79d1,%ecx
        waitpid_args_t args;

        args.wpa_pid = pid;
 80487e1:	8b 45 08             	mov    0x8(%ebp),%eax
 80487e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.wpa_options = options;
 80487e7:	8b 45 0c             	mov    0xc(%ebp),%eax
 80487ea:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.wpa_status = status;
 80487ed:	8b 45 10             	mov    0x10(%ebp),%eax
 80487f0:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_waitpid, (uint32_t) &args);
 80487f3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 80487f6:	c7 45 f8 07 00 00 00 	movl   $0x7,-0x8(%ebp)
 80487fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048800:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048803:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8048806:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048809:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804880c:	cd 2e                	int    $0x2e
 804880e:	89 c6                	mov    %eax,%esi
 8048810:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048813:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 804881a:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804881d:	cd 2e                	int    $0x2e
 804881f:	89 c2                	mov    %eax,%edx
 8048821:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048827:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048829:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 804882c:	83 c4 24             	add    $0x24,%esp
 804882f:	5e                   	pop    %esi
 8048830:	5d                   	pop    %ebp
 8048831:	c3                   	ret    

08048832 <thr_exit>:

void thr_exit(int status)
{
 8048832:	55                   	push   %ebp
 8048833:	89 e5                	mov    %esp,%ebp
 8048835:	56                   	push   %esi
 8048836:	83 ec 14             	sub    $0x14,%esp
 8048839:	e8 79 0b 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 804883e:	81 c1 6e 79 00 00    	add    $0x796e,%ecx
        trap(SYS_thr_exit, (uint32_t) status);
 8048844:	8b 45 08             	mov    0x8(%ebp),%eax
 8048847:	c7 45 f8 1f 00 00 00 	movl   $0x1f,-0x8(%ebp)
 804884e:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048851:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048854:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8048857:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804885a:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804885d:	cd 2e                	int    $0x2e
 804885f:	89 c6                	mov    %eax,%esi
 8048861:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048864:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 804886b:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804886e:	cd 2e                	int    $0x2e
 8048870:	89 c2                	mov    %eax,%edx
 8048872:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048878:	89 10                	mov    %edx,(%eax)
}
 804887a:	83 c4 14             	add    $0x14,%esp
 804887d:	5e                   	pop    %esi
 804887e:	5d                   	pop    %ebp
 804887f:	c3                   	ret    

08048880 <getpid>:

pid_t getpid(void)
{
 8048880:	55                   	push   %ebp
 8048881:	89 e5                	mov    %esp,%ebp
 8048883:	56                   	push   %esi
 8048884:	83 ec 14             	sub    $0x14,%esp
 8048887:	e8 2b 0b 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 804888c:	81 c1 20 79 00 00    	add    $0x7920,%ecx
 8048892:	c7 45 f8 23 00 00 00 	movl   $0x23,-0x8(%ebp)
 8048899:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80488a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80488a3:	89 45 e8             	mov    %eax,-0x18(%ebp)
 80488a6:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80488a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80488ac:	cd 2e                	int    $0x2e
 80488ae:	89 c6                	mov    %eax,%esi
 80488b0:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80488b3:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 80488ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80488bd:	cd 2e                	int    $0x2e
 80488bf:	89 c2                	mov    %eax,%edx
 80488c1:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80488c7:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80488c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
        return trap(SYS_getpid, 0);
}
 80488cc:	83 c4 14             	add    $0x14,%esp
 80488cf:	5e                   	pop    %esi
 80488d0:	5d                   	pop    %ebp
 80488d1:	c3                   	ret    

080488d2 <halt>:

int halt(void)
{
 80488d2:	55                   	push   %ebp
 80488d3:	89 e5                	mov    %esp,%ebp
 80488d5:	56                   	push   %esi
 80488d6:	83 ec 14             	sub    $0x14,%esp
 80488d9:	e8 d9 0a 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 80488de:	81 c1 ce 78 00 00    	add    $0x78ce,%ecx
 80488e4:	c7 45 f8 28 00 00 00 	movl   $0x28,-0x8(%ebp)
 80488eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80488f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80488f5:	89 45 e8             	mov    %eax,-0x18(%ebp)
 80488f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80488fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80488fe:	cd 2e                	int    $0x2e
 8048900:	89 c6                	mov    %eax,%esi
 8048902:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048905:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 804890c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804890f:	cd 2e                	int    $0x2e
 8048911:	89 c2                	mov    %eax,%edx
 8048913:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048919:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804891b:	8b 45 f0             	mov    -0x10(%ebp),%eax
        return trap(SYS_halt, 0);
}
 804891e:	83 c4 14             	add    $0x14,%esp
 8048921:	5e                   	pop    %esi
 8048922:	5d                   	pop    %ebp
 8048923:	c3                   	ret    

08048924 <mmap>:

void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t off)
{
 8048924:	55                   	push   %ebp
 8048925:	89 e5                	mov    %esp,%ebp
 8048927:	56                   	push   %esi
 8048928:	83 ec 34             	sub    $0x34,%esp
 804892b:	e8 87 0a 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 8048930:	81 c1 7c 78 00 00    	add    $0x787c,%ecx
        mmap_args_t args;

        args.mma_addr = addr;
 8048936:	8b 45 08             	mov    0x8(%ebp),%eax
 8048939:	89 45 d8             	mov    %eax,-0x28(%ebp)
        args.mma_len = len;
 804893c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804893f:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.mma_prot = prot;
 8048942:	8b 45 10             	mov    0x10(%ebp),%eax
 8048945:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.mma_flags = flags;
 8048948:	8b 45 14             	mov    0x14(%ebp),%eax
 804894b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.mma_fd = fd;
 804894e:	8b 45 18             	mov    0x18(%ebp),%eax
 8048951:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.mma_off = off;
 8048954:	8b 45 1c             	mov    0x1c(%ebp),%eax
 8048957:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return (void *) trap(SYS_mmap, (uint32_t) &args);
 804895a:	8d 45 d8             	lea    -0x28(%ebp),%eax
 804895d:	c7 45 f8 18 00 00 00 	movl   $0x18,-0x8(%ebp)
 8048964:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048967:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804896a:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804896d:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048970:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8048973:	cd 2e                	int    $0x2e
 8048975:	89 c6                	mov    %eax,%esi
 8048977:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804897a:	c7 45 c8 27 00 00 00 	movl   $0x27,-0x38(%ebp)
 8048981:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8048984:	cd 2e                	int    $0x2e
 8048986:	89 c2                	mov    %eax,%edx
 8048988:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 804898e:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048990:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048993:	83 c4 34             	add    $0x34,%esp
 8048996:	5e                   	pop    %esi
 8048997:	5d                   	pop    %ebp
 8048998:	c3                   	ret    

08048999 <munmap>:

int munmap(void *addr, size_t len)
{
 8048999:	55                   	push   %ebp
 804899a:	89 e5                	mov    %esp,%ebp
 804899c:	56                   	push   %esi
 804899d:	83 ec 24             	sub    $0x24,%esp
 80489a0:	e8 12 0a 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 80489a5:	81 c1 07 78 00 00    	add    $0x7807,%ecx
        munmap_args_t args;

        args.addr = addr;
 80489ab:	8b 45 08             	mov    0x8(%ebp),%eax
 80489ae:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.len = len;
 80489b1:	8b 45 0c             	mov    0xc(%ebp),%eax
 80489b4:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_munmap, (uint32_t) &args);
 80489b7:	8d 45 e8             	lea    -0x18(%ebp),%eax
 80489ba:	c7 45 f8 1a 00 00 00 	movl   $0x1a,-0x8(%ebp)
 80489c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80489c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80489c7:	89 45 d8             	mov    %eax,-0x28(%ebp)
 80489ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80489cd:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80489d0:	cd 2e                	int    $0x2e
 80489d2:	89 c6                	mov    %eax,%esi
 80489d4:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80489d7:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 80489de:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80489e1:	cd 2e                	int    $0x2e
 80489e3:	89 c2                	mov    %eax,%edx
 80489e5:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80489eb:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80489ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 80489f0:	83 c4 24             	add    $0x24,%esp
 80489f3:	5e                   	pop    %esi
 80489f4:	5d                   	pop    %ebp
 80489f5:	c3                   	ret    

080489f6 <sync>:

void sync(void)
{
 80489f6:	55                   	push   %ebp
 80489f7:	89 e5                	mov    %esp,%ebp
 80489f9:	56                   	push   %esi
 80489fa:	83 ec 14             	sub    $0x14,%esp
 80489fd:	e8 b5 09 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 8048a02:	81 c1 aa 77 00 00    	add    $0x77aa,%ecx
 8048a08:	c7 45 f8 0f 00 00 00 	movl   $0xf,-0x8(%ebp)
 8048a0f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048a16:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048a19:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8048a1c:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048a1f:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048a22:	cd 2e                	int    $0x2e
 8048a24:	89 c6                	mov    %eax,%esi
 8048a26:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048a29:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8048a30:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048a33:	cd 2e                	int    $0x2e
 8048a35:	89 c2                	mov    %eax,%edx
 8048a37:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048a3d:	89 10                	mov    %edx,(%eax)
        trap(SYS_sync, 0);
}
 8048a3f:	83 c4 14             	add    $0x14,%esp
 8048a42:	5e                   	pop    %esi
 8048a43:	5d                   	pop    %ebp
 8048a44:	c3                   	ret    

08048a45 <open>:

int open(const char *filename, int flags, int mode)
{
 8048a45:	55                   	push   %ebp
 8048a46:	89 e5                	mov    %esp,%ebp
 8048a48:	56                   	push   %esi
 8048a49:	53                   	push   %ebx
 8048a4a:	83 ec 40             	sub    $0x40,%esp
 8048a4d:	e8 13 fa ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 8048a52:	81 c3 5a 77 00 00    	add    $0x775a,%ebx
        open_args_t args;

        args.filename.as_len = strlen(filename);
 8048a58:	8b 45 08             	mov    0x8(%ebp),%eax
 8048a5b:	89 04 24             	mov    %eax,(%esp)
 8048a5e:	e8 0e 42 00 00       	call   804cc71 <strlen>
 8048a63:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.filename.as_str = filename;
 8048a66:	8b 45 08             	mov    0x8(%ebp),%eax
 8048a69:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.flags = flags;
 8048a6c:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048a6f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.mode = mode;
 8048a72:	8b 45 10             	mov    0x10(%ebp),%eax
 8048a75:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_open, (uint32_t) &args);
 8048a78:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8048a7b:	c7 45 f4 05 00 00 00 	movl   $0x5,-0xc(%ebp)
 8048a82:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048a85:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048a88:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8048a8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048a8e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048a91:	cd 2e                	int    $0x2e
 8048a93:	89 c6                	mov    %eax,%esi
 8048a95:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048a98:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8048a9f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048aa2:	cd 2e                	int    $0x2e
 8048aa4:	89 c2                	mov    %eax,%edx
 8048aa6:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048aac:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048aae:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048ab1:	83 c4 40             	add    $0x40,%esp
 8048ab4:	5b                   	pop    %ebx
 8048ab5:	5e                   	pop    %esi
 8048ab6:	5d                   	pop    %ebp
 8048ab7:	c3                   	ret    

08048ab8 <lseek>:

off_t lseek(int fd, off_t offset, int whence)
{
 8048ab8:	55                   	push   %ebp
 8048ab9:	89 e5                	mov    %esp,%ebp
 8048abb:	56                   	push   %esi
 8048abc:	83 ec 24             	sub    $0x24,%esp
 8048abf:	e8 f3 08 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 8048ac4:	81 c1 e8 76 00 00    	add    $0x76e8,%ecx
        lseek_args_t args;

        args.fd = fd;
 8048aca:	8b 45 08             	mov    0x8(%ebp),%eax
 8048acd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.offset = offset;
 8048ad0:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048ad3:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.whence = whence;
 8048ad6:	8b 45 10             	mov    0x10(%ebp),%eax
 8048ad9:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_lseek, (uint32_t) &args);
 8048adc:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048adf:	c7 45 f8 0e 00 00 00 	movl   $0xe,-0x8(%ebp)
 8048ae6:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048ae9:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048aec:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8048aef:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048af2:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048af5:	cd 2e                	int    $0x2e
 8048af7:	89 c6                	mov    %eax,%esi
 8048af9:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048afc:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 8048b03:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048b06:	cd 2e                	int    $0x2e
 8048b08:	89 c2                	mov    %eax,%edx
 8048b0a:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048b10:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048b12:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048b15:	83 c4 24             	add    $0x24,%esp
 8048b18:	5e                   	pop    %esi
 8048b19:	5d                   	pop    %ebp
 8048b1a:	c3                   	ret    

08048b1b <read>:


int read(int fd, void *buf, size_t nbytes)
{
 8048b1b:	55                   	push   %ebp
 8048b1c:	89 e5                	mov    %esp,%ebp
 8048b1e:	56                   	push   %esi
 8048b1f:	83 ec 24             	sub    $0x24,%esp
 8048b22:	e8 90 08 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 8048b27:	81 c1 85 76 00 00    	add    $0x7685,%ecx
        read_args_t args;

        args.fd = fd;
 8048b2d:	8b 45 08             	mov    0x8(%ebp),%eax
 8048b30:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.buf = buf;
 8048b33:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048b36:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.nbytes = nbytes;
 8048b39:	8b 45 10             	mov    0x10(%ebp),%eax
 8048b3c:	89 45 ec             	mov    %eax,-0x14(%ebp)


        return trap(SYS_read, (uint32_t) &args);
 8048b3f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048b42:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)
 8048b49:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048b4c:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048b4f:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8048b52:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048b55:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048b58:	cd 2e                	int    $0x2e
 8048b5a:	89 c6                	mov    %eax,%esi
 8048b5c:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048b5f:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 8048b66:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048b69:	cd 2e                	int    $0x2e
 8048b6b:	89 c2                	mov    %eax,%edx
 8048b6d:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048b73:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048b75:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048b78:	83 c4 24             	add    $0x24,%esp
 8048b7b:	5e                   	pop    %esi
 8048b7c:	5d                   	pop    %ebp
 8048b7d:	c3                   	ret    

08048b7e <write>:

int write(int fd, const void *buf, size_t nbytes)
{
 8048b7e:	55                   	push   %ebp
 8048b7f:	89 e5                	mov    %esp,%ebp
 8048b81:	56                   	push   %esi
 8048b82:	83 ec 24             	sub    $0x24,%esp
 8048b85:	e8 2d 08 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 8048b8a:	81 c1 22 76 00 00    	add    $0x7622,%ecx
        write_args_t args;

        args.fd = fd;
 8048b90:	8b 45 08             	mov    0x8(%ebp),%eax
 8048b93:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.buf = (void *) buf;
 8048b96:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048b99:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.nbytes = nbytes;
 8048b9c:	8b 45 10             	mov    0x10(%ebp),%eax
 8048b9f:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_write, (uint32_t) &args);
 8048ba2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048ba5:	c7 45 f8 04 00 00 00 	movl   $0x4,-0x8(%ebp)
 8048bac:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048baf:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048bb2:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8048bb5:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048bb8:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048bbb:	cd 2e                	int    $0x2e
 8048bbd:	89 c6                	mov    %eax,%esi
 8048bbf:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048bc2:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 8048bc9:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048bcc:	cd 2e                	int    $0x2e
 8048bce:	89 c2                	mov    %eax,%edx
 8048bd0:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048bd6:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048bd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048bdb:	83 c4 24             	add    $0x24,%esp
 8048bde:	5e                   	pop    %esi
 8048bdf:	5d                   	pop    %ebp
 8048be0:	c3                   	ret    

08048be1 <close>:

int close(int fd)
{
 8048be1:	55                   	push   %ebp
 8048be2:	89 e5                	mov    %esp,%ebp
 8048be4:	56                   	push   %esi
 8048be5:	83 ec 14             	sub    $0x14,%esp
 8048be8:	e8 ca 07 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 8048bed:	81 c1 bf 75 00 00    	add    $0x75bf,%ecx
        return trap(SYS_close, (uint32_t) fd);
 8048bf3:	8b 45 08             	mov    0x8(%ebp),%eax
 8048bf6:	c7 45 f8 06 00 00 00 	movl   $0x6,-0x8(%ebp)
 8048bfd:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048c00:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048c03:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8048c06:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048c09:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048c0c:	cd 2e                	int    $0x2e
 8048c0e:	89 c6                	mov    %eax,%esi
 8048c10:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048c13:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8048c1a:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048c1d:	cd 2e                	int    $0x2e
 8048c1f:	89 c2                	mov    %eax,%edx
 8048c21:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048c27:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048c29:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048c2c:	83 c4 14             	add    $0x14,%esp
 8048c2f:	5e                   	pop    %esi
 8048c30:	5d                   	pop    %ebp
 8048c31:	c3                   	ret    

08048c32 <dup>:

int dup(int fd)
{
 8048c32:	55                   	push   %ebp
 8048c33:	89 e5                	mov    %esp,%ebp
 8048c35:	56                   	push   %esi
 8048c36:	83 ec 14             	sub    $0x14,%esp
 8048c39:	e8 79 07 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 8048c3e:	81 c1 6e 75 00 00    	add    $0x756e,%ecx
        return trap(SYS_dup, (uint32_t) fd);
 8048c44:	8b 45 08             	mov    0x8(%ebp),%eax
 8048c47:	c7 45 f8 11 00 00 00 	movl   $0x11,-0x8(%ebp)
 8048c4e:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048c51:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048c54:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8048c57:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048c5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048c5d:	cd 2e                	int    $0x2e
 8048c5f:	89 c6                	mov    %eax,%esi
 8048c61:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048c64:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8048c6b:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048c6e:	cd 2e                	int    $0x2e
 8048c70:	89 c2                	mov    %eax,%edx
 8048c72:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048c78:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048c7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048c7d:	83 c4 14             	add    $0x14,%esp
 8048c80:	5e                   	pop    %esi
 8048c81:	5d                   	pop    %ebp
 8048c82:	c3                   	ret    

08048c83 <dup2>:

int dup2(int ofd, int nfd)
{
 8048c83:	55                   	push   %ebp
 8048c84:	89 e5                	mov    %esp,%ebp
 8048c86:	56                   	push   %esi
 8048c87:	83 ec 24             	sub    $0x24,%esp
 8048c8a:	e8 28 07 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 8048c8f:	81 c1 1d 75 00 00    	add    $0x751d,%ecx
        dup2_args_t args;

        args.ofd = ofd;
 8048c95:	8b 45 08             	mov    0x8(%ebp),%eax
 8048c98:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.nfd = nfd;
 8048c9b:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048c9e:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_dup2, (uint32_t) &args);
 8048ca1:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8048ca4:	c7 45 f8 2b 00 00 00 	movl   $0x2b,-0x8(%ebp)
 8048cab:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048cae:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048cb1:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8048cb4:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048cb7:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048cba:	cd 2e                	int    $0x2e
 8048cbc:	89 c6                	mov    %eax,%esi
 8048cbe:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048cc1:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 8048cc8:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048ccb:	cd 2e                	int    $0x2e
 8048ccd:	89 c2                	mov    %eax,%edx
 8048ccf:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048cd5:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048cd7:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048cda:	83 c4 24             	add    $0x24,%esp
 8048cdd:	5e                   	pop    %esi
 8048cde:	5d                   	pop    %ebp
 8048cdf:	c3                   	ret    

08048ce0 <mkdir>:

int mkdir(const char *path, int mode)
{
 8048ce0:	55                   	push   %ebp
 8048ce1:	89 e5                	mov    %esp,%ebp
 8048ce3:	56                   	push   %esi
 8048ce4:	53                   	push   %ebx
 8048ce5:	83 ec 40             	sub    $0x40,%esp
 8048ce8:	e8 78 f7 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 8048ced:	81 c3 bf 74 00 00    	add    $0x74bf,%ebx
        mkdir_args_t args;

        args.path.as_len = strlen(path);
 8048cf3:	8b 45 08             	mov    0x8(%ebp),%eax
 8048cf6:	89 04 24             	mov    %eax,(%esp)
 8048cf9:	e8 73 3f 00 00       	call   804cc71 <strlen>
 8048cfe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.path.as_str = path;
 8048d01:	8b 45 08             	mov    0x8(%ebp),%eax
 8048d04:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.mode = mode;
 8048d07:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048d0a:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_mkdir, (uint32_t) &args);
 8048d0d:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8048d10:	c7 45 f4 16 00 00 00 	movl   $0x16,-0xc(%ebp)
 8048d17:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048d1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048d1d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8048d20:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048d23:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048d26:	cd 2e                	int    $0x2e
 8048d28:	89 c6                	mov    %eax,%esi
 8048d2a:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048d2d:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8048d34:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048d37:	cd 2e                	int    $0x2e
 8048d39:	89 c2                	mov    %eax,%edx
 8048d3b:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048d41:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048d43:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048d46:	83 c4 40             	add    $0x40,%esp
 8048d49:	5b                   	pop    %ebx
 8048d4a:	5e                   	pop    %esi
 8048d4b:	5d                   	pop    %ebp
 8048d4c:	c3                   	ret    

08048d4d <rmdir>:

int rmdir(const char *path)
{
 8048d4d:	55                   	push   %ebp
 8048d4e:	89 e5                	mov    %esp,%ebp
 8048d50:	56                   	push   %esi
 8048d51:	53                   	push   %ebx
 8048d52:	83 ec 40             	sub    $0x40,%esp
 8048d55:	e8 0b f7 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 8048d5a:	81 c3 52 74 00 00    	add    $0x7452,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 8048d60:	8b 45 08             	mov    0x8(%ebp),%eax
 8048d63:	89 04 24             	mov    %eax,(%esp)
 8048d66:	e8 06 3f 00 00       	call   804cc71 <strlen>
 8048d6b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 8048d6e:	8b 45 08             	mov    0x8(%ebp),%eax
 8048d71:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_rmdir, (uint32_t) &args);
 8048d74:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048d77:	c7 45 f4 15 00 00 00 	movl   $0x15,-0xc(%ebp)
 8048d7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048d81:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048d84:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8048d87:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048d8a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048d8d:	cd 2e                	int    $0x2e
 8048d8f:	89 c6                	mov    %eax,%esi
 8048d91:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048d94:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8048d9b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048d9e:	cd 2e                	int    $0x2e
 8048da0:	89 c2                	mov    %eax,%edx
 8048da2:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048da8:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048daa:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048dad:	83 c4 40             	add    $0x40,%esp
 8048db0:	5b                   	pop    %ebx
 8048db1:	5e                   	pop    %esi
 8048db2:	5d                   	pop    %ebp
 8048db3:	c3                   	ret    

08048db4 <unlink>:

int unlink(const char *path)
{
 8048db4:	55                   	push   %ebp
 8048db5:	89 e5                	mov    %esp,%ebp
 8048db7:	56                   	push   %esi
 8048db8:	53                   	push   %ebx
 8048db9:	83 ec 40             	sub    $0x40,%esp
 8048dbc:	e8 a4 f6 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 8048dc1:	81 c3 eb 73 00 00    	add    $0x73eb,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 8048dc7:	8b 45 08             	mov    0x8(%ebp),%eax
 8048dca:	89 04 24             	mov    %eax,(%esp)
 8048dcd:	e8 9f 3e 00 00       	call   804cc71 <strlen>
 8048dd2:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 8048dd5:	8b 45 08             	mov    0x8(%ebp),%eax
 8048dd8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_unlink, (uint32_t) &args);
 8048ddb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048dde:	c7 45 f4 09 00 00 00 	movl   $0x9,-0xc(%ebp)
 8048de5:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048de8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048deb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8048dee:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048df1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048df4:	cd 2e                	int    $0x2e
 8048df6:	89 c6                	mov    %eax,%esi
 8048df8:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048dfb:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8048e02:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048e05:	cd 2e                	int    $0x2e
 8048e07:	89 c2                	mov    %eax,%edx
 8048e09:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048e0f:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048e11:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048e14:	83 c4 40             	add    $0x40,%esp
 8048e17:	5b                   	pop    %ebx
 8048e18:	5e                   	pop    %esi
 8048e19:	5d                   	pop    %ebp
 8048e1a:	c3                   	ret    

08048e1b <link>:

int link(const char *from, const char *to)
{
 8048e1b:	55                   	push   %ebp
 8048e1c:	89 e5                	mov    %esp,%ebp
 8048e1e:	56                   	push   %esi
 8048e1f:	53                   	push   %ebx
 8048e20:	83 ec 40             	sub    $0x40,%esp
 8048e23:	e8 3d f6 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 8048e28:	81 c3 84 73 00 00    	add    $0x7384,%ebx
        link_args_t args;

        args.from.as_len = strlen(from);
 8048e2e:	8b 45 08             	mov    0x8(%ebp),%eax
 8048e31:	89 04 24             	mov    %eax,(%esp)
 8048e34:	e8 38 3e 00 00       	call   804cc71 <strlen>
 8048e39:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.from.as_str = from;
 8048e3c:	8b 45 08             	mov    0x8(%ebp),%eax
 8048e3f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.to.as_len = strlen(to);
 8048e42:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048e45:	89 04 24             	mov    %eax,(%esp)
 8048e48:	e8 24 3e 00 00       	call   804cc71 <strlen>
 8048e4d:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.to.as_str = to;
 8048e50:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048e53:	89 45 dc             	mov    %eax,-0x24(%ebp)

        return trap(SYS_link, (uint32_t) &args);
 8048e56:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8048e59:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
 8048e60:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048e63:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048e66:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8048e69:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048e6c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048e6f:	cd 2e                	int    $0x2e
 8048e71:	89 c6                	mov    %eax,%esi
 8048e73:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048e76:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8048e7d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048e80:	cd 2e                	int    $0x2e
 8048e82:	89 c2                	mov    %eax,%edx
 8048e84:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048e8a:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048e8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048e8f:	83 c4 40             	add    $0x40,%esp
 8048e92:	5b                   	pop    %ebx
 8048e93:	5e                   	pop    %esi
 8048e94:	5d                   	pop    %ebp
 8048e95:	c3                   	ret    

08048e96 <rename>:

int rename(const char *oldname, const char *newname)
{
 8048e96:	55                   	push   %ebp
 8048e97:	89 e5                	mov    %esp,%ebp
 8048e99:	56                   	push   %esi
 8048e9a:	53                   	push   %ebx
 8048e9b:	83 ec 40             	sub    $0x40,%esp
 8048e9e:	e8 c2 f5 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 8048ea3:	81 c3 09 73 00 00    	add    $0x7309,%ebx
        rename_args_t args;

        args.oldname.as_len = strlen(oldname);
 8048ea9:	8b 45 08             	mov    0x8(%ebp),%eax
 8048eac:	89 04 24             	mov    %eax,(%esp)
 8048eaf:	e8 bd 3d 00 00       	call   804cc71 <strlen>
 8048eb4:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.oldname.as_str = oldname;
 8048eb7:	8b 45 08             	mov    0x8(%ebp),%eax
 8048eba:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.newname.as_len = strlen(newname);
 8048ebd:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048ec0:	89 04 24             	mov    %eax,(%esp)
 8048ec3:	e8 a9 3d 00 00       	call   804cc71 <strlen>
 8048ec8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.newname.as_str = newname;
 8048ecb:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048ece:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        return trap(SYS_rename, (uint32_t) &args);
 8048ed1:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8048ed4:	c7 45 f4 1b 00 00 00 	movl   $0x1b,-0xc(%ebp)
 8048edb:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048ee1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8048ee4:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048ee7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048eea:	cd 2e                	int    $0x2e
 8048eec:	89 c6                	mov    %eax,%esi
 8048eee:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048ef1:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8048ef8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048efb:	cd 2e                	int    $0x2e
 8048efd:	89 c2                	mov    %eax,%edx
 8048eff:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048f05:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048f07:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048f0a:	83 c4 40             	add    $0x40,%esp
 8048f0d:	5b                   	pop    %ebx
 8048f0e:	5e                   	pop    %esi
 8048f0f:	5d                   	pop    %ebp
 8048f10:	c3                   	ret    

08048f11 <chdir>:

int chdir(const char *path)
{
 8048f11:	55                   	push   %ebp
 8048f12:	89 e5                	mov    %esp,%ebp
 8048f14:	56                   	push   %esi
 8048f15:	53                   	push   %ebx
 8048f16:	83 ec 40             	sub    $0x40,%esp
 8048f19:	e8 47 f5 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 8048f1e:	81 c3 8e 72 00 00    	add    $0x728e,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 8048f24:	8b 45 08             	mov    0x8(%ebp),%eax
 8048f27:	89 04 24             	mov    %eax,(%esp)
 8048f2a:	e8 42 3d 00 00       	call   804cc71 <strlen>
 8048f2f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 8048f32:	8b 45 08             	mov    0x8(%ebp),%eax
 8048f35:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_chdir, (uint32_t) &args);
 8048f38:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048f3b:	c7 45 f4 0b 00 00 00 	movl   $0xb,-0xc(%ebp)
 8048f42:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048f45:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048f48:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8048f4b:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048f4e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048f51:	cd 2e                	int    $0x2e
 8048f53:	89 c6                	mov    %eax,%esi
 8048f55:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048f58:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 8048f5f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048f62:	cd 2e                	int    $0x2e
 8048f64:	89 c2                	mov    %eax,%edx
 8048f66:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048f6c:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048f6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048f71:	83 c4 40             	add    $0x40,%esp
 8048f74:	5b                   	pop    %ebx
 8048f75:	5e                   	pop    %esi
 8048f76:	5d                   	pop    %ebp
 8048f77:	c3                   	ret    

08048f78 <get_free_mem>:

size_t get_free_mem(void)
{
 8048f78:	55                   	push   %ebp
 8048f79:	89 e5                	mov    %esp,%ebp
 8048f7b:	56                   	push   %esi
 8048f7c:	83 ec 14             	sub    $0x14,%esp
 8048f7f:	e8 33 04 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 8048f84:	81 c1 28 72 00 00    	add    $0x7228,%ecx
 8048f8a:	c7 45 f8 29 00 00 00 	movl   $0x29,-0x8(%ebp)
 8048f91:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048f98:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048f9b:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8048f9e:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048fa1:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048fa4:	cd 2e                	int    $0x2e
 8048fa6:	89 c6                	mov    %eax,%esi
 8048fa8:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048fab:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8048fb2:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048fb5:	cd 2e                	int    $0x2e
 8048fb7:	89 c2                	mov    %eax,%edx
 8048fb9:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8048fbf:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048fc1:	8b 45 f0             	mov    -0x10(%ebp),%eax
        return (size_t) trap(SYS_get_free_mem, 0);
}
 8048fc4:	83 c4 14             	add    $0x14,%esp
 8048fc7:	5e                   	pop    %esi
 8048fc8:	5d                   	pop    %ebp
 8048fc9:	c3                   	ret    

08048fca <execve>:

int execve(const char *filename, char *const argv[], char *const envp[])
{
 8048fca:	55                   	push   %ebp
 8048fcb:	89 e5                	mov    %esp,%ebp
 8048fcd:	56                   	push   %esi
 8048fce:	53                   	push   %ebx
 8048fcf:	83 ec 50             	sub    $0x50,%esp
 8048fd2:	e8 8e f4 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 8048fd7:	81 c3 d5 71 00 00    	add    $0x71d5,%ebx
        execve_args_t           args;

        int i;

        args.filename.as_len = strlen(filename);
 8048fdd:	8b 45 08             	mov    0x8(%ebp),%eax
 8048fe0:	89 04 24             	mov    %eax,(%esp)
 8048fe3:	e8 89 3c 00 00       	call   804cc71 <strlen>
 8048fe8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        args.filename.as_str = filename;
 8048feb:	8b 45 08             	mov    0x8(%ebp),%eax
 8048fee:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /* Build argv vector */
        for (i = 0; argv[i] != NULL; i++)
 8048ff1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8048ff8:	eb 04                	jmp    8048ffe <execve+0x34>
 8048ffa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 8048ffe:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049001:	c1 e0 02             	shl    $0x2,%eax
 8049004:	03 45 0c             	add    0xc(%ebp),%eax
 8049007:	8b 00                	mov    (%eax),%eax
 8049009:	85 c0                	test   %eax,%eax
 804900b:	75 ed                	jne    8048ffa <execve+0x30>
                ;
        args.argv.av_len = i;
 804900d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049010:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.argv.av_vec = malloc((args.argv.av_len + 1) * sizeof(argstr_t));
 8049013:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8049016:	83 c0 01             	add    $0x1,%eax
 8049019:	c1 e0 03             	shl    $0x3,%eax
 804901c:	89 04 24             	mov    %eax,(%esp)
 804901f:	e8 e0 2e 00 00       	call   804bf04 <malloc>
 8049024:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for (i = 0; argv[i] != NULL; i++) {
 8049027:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804902e:	eb 3e                	jmp    804906e <execve+0xa4>
                args.argv.av_vec[i].as_len = strlen(argv[i]);
 8049030:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049033:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049036:	c1 e2 03             	shl    $0x3,%edx
 8049039:	8d 34 10             	lea    (%eax,%edx,1),%esi
 804903c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804903f:	c1 e0 02             	shl    $0x2,%eax
 8049042:	03 45 0c             	add    0xc(%ebp),%eax
 8049045:	8b 00                	mov    (%eax),%eax
 8049047:	89 04 24             	mov    %eax,(%esp)
 804904a:	e8 22 3c 00 00       	call   804cc71 <strlen>
 804904f:	89 46 04             	mov    %eax,0x4(%esi)
                args.argv.av_vec[i].as_str = argv[i];
 8049052:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049055:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049058:	c1 e2 03             	shl    $0x3,%edx
 804905b:	01 c2                	add    %eax,%edx
 804905d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049060:	c1 e0 02             	shl    $0x2,%eax
 8049063:	03 45 0c             	add    0xc(%ebp),%eax
 8049066:	8b 00                	mov    (%eax),%eax
 8049068:	89 02                	mov    %eax,(%edx)
        /* Build argv vector */
        for (i = 0; argv[i] != NULL; i++)
                ;
        args.argv.av_len = i;
        args.argv.av_vec = malloc((args.argv.av_len + 1) * sizeof(argstr_t));
        for (i = 0; argv[i] != NULL; i++) {
 804906a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 804906e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049071:	c1 e0 02             	shl    $0x2,%eax
 8049074:	03 45 0c             	add    0xc(%ebp),%eax
 8049077:	8b 00                	mov    (%eax),%eax
 8049079:	85 c0                	test   %eax,%eax
 804907b:	75 b3                	jne    8049030 <execve+0x66>
                args.argv.av_vec[i].as_len = strlen(argv[i]);
                args.argv.av_vec[i].as_str = argv[i];
        }
        args.argv.av_vec[i].as_len = 0;
 804907d:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049080:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049083:	c1 e2 03             	shl    $0x3,%edx
 8049086:	01 d0                	add    %edx,%eax
 8049088:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        args.argv.av_vec[i].as_str = NULL;
 804908f:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049092:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049095:	c1 e2 03             	shl    $0x3,%edx
 8049098:	01 d0                	add    %edx,%eax
 804909a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

        /* Build envp vector */
        for (i = 0; envp[i] != NULL; i++)
 80490a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 80490a7:	eb 04                	jmp    80490ad <execve+0xe3>
 80490a9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 80490ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80490b0:	c1 e0 02             	shl    $0x2,%eax
 80490b3:	03 45 10             	add    0x10(%ebp),%eax
 80490b6:	8b 00                	mov    (%eax),%eax
 80490b8:	85 c0                	test   %eax,%eax
 80490ba:	75 ed                	jne    80490a9 <execve+0xdf>
                ;
        args.envp.av_len = i;
 80490bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80490bf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.envp.av_vec = malloc((args.envp.av_len + 1) * sizeof(argstr_t));
 80490c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80490c5:	83 c0 01             	add    $0x1,%eax
 80490c8:	c1 e0 03             	shl    $0x3,%eax
 80490cb:	89 04 24             	mov    %eax,(%esp)
 80490ce:	e8 31 2e 00 00       	call   804bf04 <malloc>
 80490d3:	89 45 e0             	mov    %eax,-0x20(%ebp)
        for (i = 0; envp[i] != NULL; i++) {
 80490d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 80490dd:	eb 3e                	jmp    804911d <execve+0x153>
                args.envp.av_vec[i].as_len = strlen(envp[i]);
 80490df:	8b 45 e0             	mov    -0x20(%ebp),%eax
 80490e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80490e5:	c1 e2 03             	shl    $0x3,%edx
 80490e8:	8d 34 10             	lea    (%eax,%edx,1),%esi
 80490eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80490ee:	c1 e0 02             	shl    $0x2,%eax
 80490f1:	03 45 10             	add    0x10(%ebp),%eax
 80490f4:	8b 00                	mov    (%eax),%eax
 80490f6:	89 04 24             	mov    %eax,(%esp)
 80490f9:	e8 73 3b 00 00       	call   804cc71 <strlen>
 80490fe:	89 46 04             	mov    %eax,0x4(%esi)
                args.envp.av_vec[i].as_str = envp[i];
 8049101:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049104:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049107:	c1 e2 03             	shl    $0x3,%edx
 804910a:	01 c2                	add    %eax,%edx
 804910c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804910f:	c1 e0 02             	shl    $0x2,%eax
 8049112:	03 45 10             	add    0x10(%ebp),%eax
 8049115:	8b 00                	mov    (%eax),%eax
 8049117:	89 02                	mov    %eax,(%edx)
        /* Build envp vector */
        for (i = 0; envp[i] != NULL; i++)
                ;
        args.envp.av_len = i;
        args.envp.av_vec = malloc((args.envp.av_len + 1) * sizeof(argstr_t));
        for (i = 0; envp[i] != NULL; i++) {
 8049119:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 804911d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049120:	c1 e0 02             	shl    $0x2,%eax
 8049123:	03 45 10             	add    0x10(%ebp),%eax
 8049126:	8b 00                	mov    (%eax),%eax
 8049128:	85 c0                	test   %eax,%eax
 804912a:	75 b3                	jne    80490df <execve+0x115>
                args.envp.av_vec[i].as_len = strlen(envp[i]);
                args.envp.av_vec[i].as_str = envp[i];
        }
        args.envp.av_vec[i].as_len = 0;
 804912c:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804912f:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049132:	c1 e2 03             	shl    $0x3,%edx
 8049135:	01 d0                	add    %edx,%eax
 8049137:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        args.envp.av_vec[i].as_str = NULL;
 804913e:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049141:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049144:	c1 e2 03             	shl    $0x3,%edx
 8049147:	01 d0                	add    %edx,%eax
 8049149:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

        /* Note that we don't need to worry about freeing since we are going to exec
         * (so all our memory will be cleaned up) */

        return trap(SYS_execve, (uint32_t) &args);
 804914f:	8d 45 d0             	lea    -0x30(%ebp),%eax
 8049152:	c7 45 f0 0a 00 00 00 	movl   $0xa,-0x10(%ebp)
 8049159:	89 45 ec             	mov    %eax,-0x14(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804915c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804915f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 8049162:	8b 55 ec             	mov    -0x14(%ebp),%edx
 8049165:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8049168:	cd 2e                	int    $0x2e
 804916a:	89 c6                	mov    %eax,%esi
 804916c:	89 75 e8             	mov    %esi,-0x18(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804916f:	c7 45 c4 27 00 00 00 	movl   $0x27,-0x3c(%ebp)
 8049176:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8049179:	cd 2e                	int    $0x2e
 804917b:	89 c2                	mov    %eax,%edx
 804917d:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8049183:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049185:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
 8049188:	83 c4 50             	add    $0x50,%esp
 804918b:	5b                   	pop    %ebx
 804918c:	5e                   	pop    %esi
 804918d:	5d                   	pop    %ebp
 804918e:	c3                   	ret    

0804918f <thr_set_errno>:

void thr_set_errno(int n)
{
 804918f:	55                   	push   %ebp
 8049190:	89 e5                	mov    %esp,%ebp
 8049192:	56                   	push   %esi
 8049193:	83 ec 14             	sub    $0x14,%esp
 8049196:	e8 1c 02 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 804919b:	81 c1 11 70 00 00    	add    $0x7011,%ecx
        trap(SYS_set_errno, (uint32_t) n);
 80491a1:	8b 45 08             	mov    0x8(%ebp),%eax
 80491a4:	c7 45 f8 2a 00 00 00 	movl   $0x2a,-0x8(%ebp)
 80491ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80491ae:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80491b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
 80491b4:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80491b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80491ba:	cd 2e                	int    $0x2e
 80491bc:	89 c6                	mov    %eax,%esi
 80491be:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80491c1:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 80491c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80491cb:	cd 2e                	int    $0x2e
 80491cd:	89 c2                	mov    %eax,%edx
 80491cf:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 80491d5:	89 10                	mov    %edx,(%eax)
}
 80491d7:	83 c4 14             	add    $0x14,%esp
 80491da:	5e                   	pop    %esi
 80491db:	5d                   	pop    %ebp
 80491dc:	c3                   	ret    

080491dd <thr_errno>:

int thr_errno(void)
{
 80491dd:	55                   	push   %ebp
 80491de:	89 e5                	mov    %esp,%ebp
 80491e0:	56                   	push   %esi
 80491e1:	83 ec 14             	sub    $0x14,%esp
 80491e4:	e8 ce 01 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 80491e9:	81 c1 c3 6f 00 00    	add    $0x6fc3,%ecx
 80491ef:	c7 45 f8 27 00 00 00 	movl   $0x27,-0x8(%ebp)
 80491f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80491fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049200:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8049203:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049206:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049209:	cd 2e                	int    $0x2e
 804920b:	89 c6                	mov    %eax,%esi
 804920d:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049210:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8049217:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804921a:	cd 2e                	int    $0x2e
 804921c:	89 c2                	mov    %eax,%edx
 804921e:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8049224:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049226:	8b 45 f0             	mov    -0x10(%ebp),%eax
        return trap(SYS_errno, 0);
}
 8049229:	83 c4 14             	add    $0x14,%esp
 804922c:	5e                   	pop    %esi
 804922d:	5d                   	pop    %ebp
 804922e:	c3                   	ret    

0804922f <getdents>:

int getdents(int fd, dirent_t *dir, size_t size)
{
 804922f:	55                   	push   %ebp
 8049230:	89 e5                	mov    %esp,%ebp
 8049232:	56                   	push   %esi
 8049233:	83 ec 24             	sub    $0x24,%esp
 8049236:	e8 7c 01 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 804923b:	81 c1 71 6f 00 00    	add    $0x6f71,%ecx
        getdents_args_t args;

        args.fd = fd;
 8049241:	8b 45 08             	mov    0x8(%ebp),%eax
 8049244:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.dirp = dir;
 8049247:	8b 45 0c             	mov    0xc(%ebp),%eax
 804924a:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.count = size;
 804924d:	8b 45 10             	mov    0x10(%ebp),%eax
 8049250:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return trap(SYS_getdents, (uint32_t) &args);
 8049253:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8049256:	c7 45 f8 17 00 00 00 	movl   $0x17,-0x8(%ebp)
 804925d:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049260:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049263:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8049266:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049269:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804926c:	cd 2e                	int    $0x2e
 804926e:	89 c6                	mov    %eax,%esi
 8049270:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049273:	c7 45 d8 27 00 00 00 	movl   $0x27,-0x28(%ebp)
 804927a:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804927d:	cd 2e                	int    $0x2e
 804927f:	89 c2                	mov    %eax,%edx
 8049281:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8049287:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049289:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 804928c:	83 c4 24             	add    $0x24,%esp
 804928f:	5e                   	pop    %esi
 8049290:	5d                   	pop    %ebp
 8049291:	c3                   	ret    

08049292 <stat>:
}
#endif /* MOUNTING */

int
stat(const char *path, struct stat *buf)
{
 8049292:	55                   	push   %ebp
 8049293:	89 e5                	mov    %esp,%ebp
 8049295:	56                   	push   %esi
 8049296:	53                   	push   %ebx
 8049297:	83 ec 40             	sub    $0x40,%esp
 804929a:	e8 c6 f1 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804929f:	81 c3 0d 6f 00 00    	add    $0x6f0d,%ebx
        stat_args_t args;

        args.path.as_len = strlen(path);
 80492a5:	8b 45 08             	mov    0x8(%ebp),%eax
 80492a8:	89 04 24             	mov    %eax,(%esp)
 80492ab:	e8 c1 39 00 00       	call   804cc71 <strlen>
 80492b0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.path.as_str = path;
 80492b3:	8b 45 08             	mov    0x8(%ebp),%eax
 80492b6:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.buf = buf;
 80492b9:	8b 45 0c             	mov    0xc(%ebp),%eax
 80492bc:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_stat, (uint32_t) &args);
 80492bf:	8d 45 e0             	lea    -0x20(%ebp),%eax
 80492c2:	c7 45 f4 2f 00 00 00 	movl   $0x2f,-0xc(%ebp)
 80492c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80492cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80492cf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 80492d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
 80492d5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 80492d8:	cd 2e                	int    $0x2e
 80492da:	89 c6                	mov    %eax,%esi
 80492dc:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80492df:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 80492e6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 80492e9:	cd 2e                	int    $0x2e
 80492eb:	89 c2                	mov    %eax,%edx
 80492ed:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 80492f3:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80492f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 80492f8:	83 c4 40             	add    $0x40,%esp
 80492fb:	5b                   	pop    %ebx
 80492fc:	5e                   	pop    %esi
 80492fd:	5d                   	pop    %ebp
 80492fe:	c3                   	ret    

080492ff <uname>:

int
uname(struct utsname *buf)
{
 80492ff:	55                   	push   %ebp
 8049300:	89 e5                	mov    %esp,%ebp
 8049302:	56                   	push   %esi
 8049303:	83 ec 14             	sub    $0x14,%esp
 8049306:	e8 ac 00 00 00       	call   80493b7 <__i686.get_pc_thunk.cx>
 804930b:	81 c1 a1 6e 00 00    	add    $0x6ea1,%ecx
        return trap(SYS_uname, (uint32_t) buf);
 8049311:	8b 45 08             	mov    0x8(%ebp),%eax
 8049314:	c7 45 f8 1c 00 00 00 	movl   $0x1c,-0x8(%ebp)
 804931b:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804931e:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049321:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8049324:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049327:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804932a:	cd 2e                	int    $0x2e
 804932c:	89 c6                	mov    %eax,%esi
 804932e:	89 75 f0             	mov    %esi,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049331:	c7 45 e8 27 00 00 00 	movl   $0x27,-0x18(%ebp)
 8049338:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804933b:	cd 2e                	int    $0x2e
 804933d:	89 c2                	mov    %eax,%edx
 804933f:	8b 81 fc ff ff ff    	mov    -0x4(%ecx),%eax
 8049345:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049347:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 804934a:	83 c4 14             	add    $0x14,%esp
 804934d:	5e                   	pop    %esi
 804934e:	5d                   	pop    %ebp
 804934f:	c3                   	ret    

08049350 <debug>:

int
debug(const char *str)
{
 8049350:	55                   	push   %ebp
 8049351:	89 e5                	mov    %esp,%ebp
 8049353:	56                   	push   %esi
 8049354:	53                   	push   %ebx
 8049355:	83 ec 40             	sub    $0x40,%esp
 8049358:	e8 08 f1 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804935d:	81 c3 4f 6e 00 00    	add    $0x6e4f,%ebx
        argstr_t argstr;
        argstr.as_len = strlen(str);
 8049363:	8b 45 08             	mov    0x8(%ebp),%eax
 8049366:	89 04 24             	mov    %eax,(%esp)
 8049369:	e8 03 39 00 00       	call   804cc71 <strlen>
 804936e:	89 45 e8             	mov    %eax,-0x18(%ebp)
        argstr.as_str = str;
 8049371:	8b 45 08             	mov    0x8(%ebp),%eax
 8049374:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_debug, (uint32_t) &argstr);
 8049377:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804937a:	c7 45 f4 29 23 00 00 	movl   $0x2329,-0xc(%ebp)
 8049381:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049384:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049387:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804938a:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804938d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049390:	cd 2e                	int    $0x2e
 8049392:	89 c6                	mov    %eax,%esi
 8049394:	89 75 ec             	mov    %esi,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049397:	c7 45 d4 27 00 00 00 	movl   $0x27,-0x2c(%ebp)
 804939e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 80493a1:	cd 2e                	int    $0x2e
 80493a3:	89 c2                	mov    %eax,%edx
 80493a5:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 80493ab:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80493ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 80493b0:	83 c4 40             	add    $0x40,%esp
 80493b3:	5b                   	pop    %ebx
 80493b4:	5e                   	pop    %esi
 80493b5:	5d                   	pop    %ebp
 80493b6:	c3                   	ret    

080493b7 <__i686.get_pc_thunk.cx>:
 80493b7:	8b 0c 24             	mov    (%esp),%ecx
 80493ba:	c3                   	ret    
 80493bb:	90                   	nop

080493bc <__tolower>:

#define isascii(c) (((unsigned char)(c))<=0x7f)
#define toascii(c) (((unsigned char)(c))&0x7f)

static inline unsigned char __tolower(unsigned char c)
{
 80493bc:	55                   	push   %ebp
 80493bd:	89 e5                	mov    %esp,%ebp
 80493bf:	83 ec 04             	sub    $0x4,%esp
 80493c2:	e8 f0 ff ff ff       	call   80493b7 <__i686.get_pc_thunk.cx>
 80493c7:	81 c1 e5 6d 00 00    	add    $0x6de5,%ecx
 80493cd:	8b 45 08             	mov    0x8(%ebp),%eax
 80493d0:	88 45 fc             	mov    %al,-0x4(%ebp)
        if (isupper(c))
 80493d3:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
 80493d7:	0f b6 84 01 34 00 00 	movzbl 0x34(%ecx,%eax,1),%eax
 80493de:	00 
 80493df:	0f b6 c0             	movzbl %al,%eax
 80493e2:	83 e0 01             	and    $0x1,%eax
 80493e5:	84 c0                	test   %al,%al
 80493e7:	74 04                	je     80493ed <__tolower+0x31>
                c -= 'A' - 'a';
 80493e9:	80 45 fc 20          	addb   $0x20,-0x4(%ebp)
        return c;
 80493ed:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
}
 80493f1:	c9                   	leave  
 80493f2:	c3                   	ret    

080493f3 <__toupper>:

static inline unsigned char __toupper(unsigned char c)
{
 80493f3:	55                   	push   %ebp
 80493f4:	89 e5                	mov    %esp,%ebp
 80493f6:	83 ec 04             	sub    $0x4,%esp
 80493f9:	e8 b9 ff ff ff       	call   80493b7 <__i686.get_pc_thunk.cx>
 80493fe:	81 c1 ae 6d 00 00    	add    $0x6dae,%ecx
 8049404:	8b 45 08             	mov    0x8(%ebp),%eax
 8049407:	88 45 fc             	mov    %al,-0x4(%ebp)
        if (islower(c))
 804940a:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
 804940e:	0f b6 84 01 34 00 00 	movzbl 0x34(%ecx,%eax,1),%eax
 8049415:	00 
 8049416:	0f b6 c0             	movzbl %al,%eax
 8049419:	83 e0 02             	and    $0x2,%eax
 804941c:	85 c0                	test   %eax,%eax
 804941e:	74 04                	je     8049424 <__toupper+0x31>
                c -= 'a' - 'A';
 8049420:	80 6d fc 20          	subb   $0x20,-0x4(%ebp)
        return c;
 8049424:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
}
 8049428:	c9                   	leave  
 8049429:	c3                   	ret    

0804942a <skip_atoi>:
#include "stddef.h"
#include "stdio.h"
#include "string.h"

static int skip_atoi(const char **s)
{
 804942a:	55                   	push   %ebp
 804942b:	89 e5                	mov    %esp,%ebp
 804942d:	53                   	push   %ebx
 804942e:	83 ec 10             	sub    $0x10,%esp
 8049431:	e8 2f f0 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 8049436:	81 c3 76 6d 00 00    	add    $0x6d76,%ebx
        int i = 0;
 804943c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

        while (isdigit(**s))
 8049443:	eb 29                	jmp    804946e <skip_atoi+0x44>
                i = i * 10 + *((*s)++) - '0';
 8049445:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8049448:	89 d0                	mov    %edx,%eax
 804944a:	c1 e0 02             	shl    $0x2,%eax
 804944d:	01 d0                	add    %edx,%eax
 804944f:	01 c0                	add    %eax,%eax
 8049451:	89 c1                	mov    %eax,%ecx
 8049453:	8b 45 08             	mov    0x8(%ebp),%eax
 8049456:	8b 00                	mov    (%eax),%eax
 8049458:	0f b6 10             	movzbl (%eax),%edx
 804945b:	0f be d2             	movsbl %dl,%edx
 804945e:	01 ca                	add    %ecx,%edx
 8049460:	83 ea 30             	sub    $0x30,%edx
 8049463:	89 55 f8             	mov    %edx,-0x8(%ebp)
 8049466:	8d 50 01             	lea    0x1(%eax),%edx
 8049469:	8b 45 08             	mov    0x8(%ebp),%eax
 804946c:	89 10                	mov    %edx,(%eax)

static int skip_atoi(const char **s)
{
        int i = 0;

        while (isdigit(**s))
 804946e:	8b 45 08             	mov    0x8(%ebp),%eax
 8049471:	8b 00                	mov    (%eax),%eax
 8049473:	0f b6 00             	movzbl (%eax),%eax
 8049476:	0f b6 c0             	movzbl %al,%eax
 8049479:	0f b6 84 03 34 00 00 	movzbl 0x34(%ebx,%eax,1),%eax
 8049480:	00 
 8049481:	0f b6 c0             	movzbl %al,%eax
 8049484:	83 e0 04             	and    $0x4,%eax
 8049487:	85 c0                	test   %eax,%eax
 8049489:	75 ba                	jne    8049445 <skip_atoi+0x1b>
                i = i * 10 + *((*s)++) - '0';
        return i;
 804948b:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
 804948e:	83 c4 10             	add    $0x10,%esp
 8049491:	5b                   	pop    %ebx
 8049492:	5d                   	pop    %ebp
 8049493:	c3                   	ret    

08049494 <number>:
#define LEFT    16              /* left justified */
#define SPECIAL 32              /* 0x */
#define LARGE   64              /* use 'ABCDEF' instead of 'abcdef' */

static char *number(char *buf, char *end, long long num, int base, int size, int precision, int type)
{
 8049494:	55                   	push   %ebp
 8049495:	89 e5                	mov    %esp,%ebp
 8049497:	57                   	push   %edi
 8049498:	56                   	push   %esi
 8049499:	53                   	push   %ebx
 804949a:	81 ec dc 00 00 00    	sub    $0xdc,%esp
 80494a0:	e8 c0 ef ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 80494a5:	81 c3 07 6d 00 00    	add    $0x6d07,%ebx
 80494ab:	8b 45 10             	mov    0x10(%ebp),%eax
 80494ae:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
 80494b4:	8b 45 14             	mov    0x14(%ebp),%eax
 80494b7:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
        char c, sign, tmp[66];
        const char *digits;
        const char small_digits[] = "0123456789abcdefghijklmnopqrstuvwxyz";
 80494bd:	c7 85 65 ff ff ff 30 	movl   $0x33323130,-0x9b(%ebp)
 80494c4:	31 32 33 
 80494c7:	c7 85 69 ff ff ff 34 	movl   $0x37363534,-0x97(%ebp)
 80494ce:	35 36 37 
 80494d1:	c7 85 6d ff ff ff 38 	movl   $0x62613938,-0x93(%ebp)
 80494d8:	39 61 62 
 80494db:	c7 85 71 ff ff ff 63 	movl   $0x66656463,-0x8f(%ebp)
 80494e2:	64 65 66 
 80494e5:	c7 85 75 ff ff ff 67 	movl   $0x6a696867,-0x8b(%ebp)
 80494ec:	68 69 6a 
 80494ef:	c7 85 79 ff ff ff 6b 	movl   $0x6e6d6c6b,-0x87(%ebp)
 80494f6:	6c 6d 6e 
 80494f9:	c7 85 7d ff ff ff 6f 	movl   $0x7271706f,-0x83(%ebp)
 8049500:	70 71 72 
 8049503:	c7 45 81 73 74 75 76 	movl   $0x76757473,-0x7f(%ebp)
 804950a:	c7 45 85 77 78 79 7a 	movl   $0x7a797877,-0x7b(%ebp)
 8049511:	c6 45 89 00          	movb   $0x0,-0x77(%ebp)
        const char large_digits[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 8049515:	c7 85 40 ff ff ff 30 	movl   $0x33323130,-0xc0(%ebp)
 804951c:	31 32 33 
 804951f:	c7 85 44 ff ff ff 34 	movl   $0x37363534,-0xbc(%ebp)
 8049526:	35 36 37 
 8049529:	c7 85 48 ff ff ff 38 	movl   $0x42413938,-0xb8(%ebp)
 8049530:	39 41 42 
 8049533:	c7 85 4c ff ff ff 43 	movl   $0x46454443,-0xb4(%ebp)
 804953a:	44 45 46 
 804953d:	c7 85 50 ff ff ff 47 	movl   $0x4a494847,-0xb0(%ebp)
 8049544:	48 49 4a 
 8049547:	c7 85 54 ff ff ff 4b 	movl   $0x4e4d4c4b,-0xac(%ebp)
 804954e:	4c 4d 4e 
 8049551:	c7 85 58 ff ff ff 4f 	movl   $0x5251504f,-0xa8(%ebp)
 8049558:	50 51 52 
 804955b:	c7 85 5c ff ff ff 53 	movl   $0x56555453,-0xa4(%ebp)
 8049562:	54 55 56 
 8049565:	c7 85 60 ff ff ff 57 	movl   $0x5a595857,-0xa0(%ebp)
 804956c:	58 59 5a 
 804956f:	c6 85 64 ff ff ff 00 	movb   $0x0,-0x9c(%ebp)
        int i;

        digits = (type & LARGE) ? large_digits : small_digits;
 8049576:	8b 45 24             	mov    0x24(%ebp),%eax
 8049579:	83 e0 40             	and    $0x40,%eax
 804957c:	85 c0                	test   %eax,%eax
 804957e:	74 08                	je     8049588 <number+0xf4>
 8049580:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
 8049586:	eb 06                	jmp    804958e <number+0xfa>
 8049588:	8d 85 65 ff ff ff    	lea    -0x9b(%ebp),%eax
 804958e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        if (type & LEFT)
 8049591:	8b 45 24             	mov    0x24(%ebp),%eax
 8049594:	83 e0 10             	and    $0x10,%eax
 8049597:	85 c0                	test   %eax,%eax
 8049599:	74 04                	je     804959f <number+0x10b>
                type &= ~ZEROPAD;
 804959b:	83 65 24 fe          	andl   $0xfffffffe,0x24(%ebp)
        if (base < 2 || base > 36)
 804959f:	83 7d 18 01          	cmpl   $0x1,0x18(%ebp)
 80495a3:	7e 06                	jle    80495ab <number+0x117>
 80495a5:	83 7d 18 24          	cmpl   $0x24,0x18(%ebp)
 80495a9:	7e 08                	jle    80495b3 <number+0x11f>
                return buf;
 80495ab:	8b 45 08             	mov    0x8(%ebp),%eax
 80495ae:	e9 99 02 00 00       	jmp    804984c <number+0x3b8>
        c = (type & ZEROPAD) ? '0' : ' ';
 80495b3:	8b 45 24             	mov    0x24(%ebp),%eax
 80495b6:	83 e0 01             	and    $0x1,%eax
 80495b9:	84 c0                	test   %al,%al
 80495bb:	74 07                	je     80495c4 <number+0x130>
 80495bd:	b8 30 00 00 00       	mov    $0x30,%eax
 80495c2:	eb 05                	jmp    80495c9 <number+0x135>
 80495c4:	b8 20 00 00 00       	mov    $0x20,%eax
 80495c9:	88 45 d3             	mov    %al,-0x2d(%ebp)
        sign = 0;
 80495cc:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
        if (type & SIGN) {
 80495d0:	8b 45 24             	mov    0x24(%ebp),%eax
 80495d3:	83 e0 02             	and    $0x2,%eax
 80495d6:	85 c0                	test   %eax,%eax
 80495d8:	74 4c                	je     8049626 <number+0x192>
                if (num < 0) {
 80495da:	83 bd 34 ff ff ff 00 	cmpl   $0x0,-0xcc(%ebp)
 80495e1:	79 1d                	jns    8049600 <number+0x16c>
                        sign = '-';
 80495e3:	c6 45 e7 2d          	movb   $0x2d,-0x19(%ebp)
                        num = -num;
 80495e7:	f7 9d 30 ff ff ff    	negl   -0xd0(%ebp)
 80495ed:	83 95 34 ff ff ff 00 	adcl   $0x0,-0xcc(%ebp)
 80495f4:	f7 9d 34 ff ff ff    	negl   -0xcc(%ebp)
                        size--;
 80495fa:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
 80495fe:	eb 26                	jmp    8049626 <number+0x192>
                } else if (type & PLUS) {
 8049600:	8b 45 24             	mov    0x24(%ebp),%eax
 8049603:	83 e0 04             	and    $0x4,%eax
 8049606:	85 c0                	test   %eax,%eax
 8049608:	74 0a                	je     8049614 <number+0x180>
                        sign = '+';
 804960a:	c6 45 e7 2b          	movb   $0x2b,-0x19(%ebp)
                        size--;
 804960e:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
 8049612:	eb 12                	jmp    8049626 <number+0x192>
                } else if (type & SPACE) {
 8049614:	8b 45 24             	mov    0x24(%ebp),%eax
 8049617:	83 e0 08             	and    $0x8,%eax
 804961a:	85 c0                	test   %eax,%eax
 804961c:	74 08                	je     8049626 <number+0x192>
                        sign = ' ';
 804961e:	c6 45 e7 20          	movb   $0x20,-0x19(%ebp)
                        size--;
 8049622:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
                }
        }
        if (type & SPECIAL) {
 8049626:	8b 45 24             	mov    0x24(%ebp),%eax
 8049629:	83 e0 20             	and    $0x20,%eax
 804962c:	85 c0                	test   %eax,%eax
 804962e:	74 16                	je     8049646 <number+0x1b2>
                if (base == 16)
 8049630:	83 7d 18 10          	cmpl   $0x10,0x18(%ebp)
 8049634:	75 06                	jne    804963c <number+0x1a8>
                        size -= 2;
 8049636:	83 6d 1c 02          	subl   $0x2,0x1c(%ebp)
 804963a:	eb 0a                	jmp    8049646 <number+0x1b2>
                else if (base == 8)
 804963c:	83 7d 18 08          	cmpl   $0x8,0x18(%ebp)
 8049640:	75 04                	jne    8049646 <number+0x1b2>
                        size--;
 8049642:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
        }
        i = 0;
 8049646:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
        if (num == 0) {
 804964d:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
 8049653:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
 8049659:	09 d0                	or     %edx,%eax
 804965b:	85 c0                	test   %eax,%eax
 804965d:	75 12                	jne    8049671 <number+0x1dd>
                tmp[i++] = '0';
 804965f:	8d 45 8a             	lea    -0x76(%ebp),%eax
 8049662:	03 45 e0             	add    -0x20(%ebp),%eax
 8049665:	c6 00 30             	movb   $0x30,(%eax)
 8049668:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
 804966c:	e9 82 00 00 00       	jmp    80496f3 <number+0x25f>
        } else {
                /* XXX KAF: force unsigned mod and div. */
                /* XXX kernel does not support long long division */
                unsigned long long num2 = (unsigned long long)num;
 8049671:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
 8049677:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
 804967d:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8049680:	89 55 dc             	mov    %edx,-0x24(%ebp)
                unsigned int base2 = (unsigned int)base;
 8049683:	8b 45 18             	mov    0x18(%ebp),%eax
 8049686:	89 45 cc             	mov    %eax,-0x34(%ebp)
                while (num2 != 0) {
 8049689:	eb 5c                	jmp    80496e7 <number+0x253>
                        tmp[i++] = digits[num2 % base2];
 804968b:	8b 75 cc             	mov    -0x34(%ebp),%esi
 804968e:	bf 00 00 00 00       	mov    $0x0,%edi
 8049693:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049696:	8b 55 dc             	mov    -0x24(%ebp),%edx
 8049699:	89 74 24 08          	mov    %esi,0x8(%esp)
 804969d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
 80496a1:	89 04 24             	mov    %eax,(%esp)
 80496a4:	89 54 24 04          	mov    %edx,0x4(%esp)
 80496a8:	e8 1d 33 00 00       	call   804c9ca <__umoddi3>
 80496ad:	03 45 d4             	add    -0x2c(%ebp),%eax
 80496b0:	0f b6 10             	movzbl (%eax),%edx
 80496b3:	8d 45 8a             	lea    -0x76(%ebp),%eax
 80496b6:	03 45 e0             	add    -0x20(%ebp),%eax
 80496b9:	88 10                	mov    %dl,(%eax)
 80496bb:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
                        num2 /= base2;
 80496bf:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80496c2:	ba 00 00 00 00       	mov    $0x0,%edx
 80496c7:	89 44 24 08          	mov    %eax,0x8(%esp)
 80496cb:	89 54 24 0c          	mov    %edx,0xc(%esp)
 80496cf:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80496d2:	8b 55 dc             	mov    -0x24(%ebp),%edx
 80496d5:	89 04 24             	mov    %eax,(%esp)
 80496d8:	89 54 24 04          	mov    %edx,0x4(%esp)
 80496dc:	e8 91 32 00 00       	call   804c972 <__udivdi3>
 80496e1:	89 45 d8             	mov    %eax,-0x28(%ebp)
 80496e4:	89 55 dc             	mov    %edx,-0x24(%ebp)
        } else {
                /* XXX KAF: force unsigned mod and div. */
                /* XXX kernel does not support long long division */
                unsigned long long num2 = (unsigned long long)num;
                unsigned int base2 = (unsigned int)base;
                while (num2 != 0) {
 80496e7:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80496ea:	8b 55 dc             	mov    -0x24(%ebp),%edx
 80496ed:	09 d0                	or     %edx,%eax
 80496ef:	85 c0                	test   %eax,%eax
 80496f1:	75 98                	jne    804968b <number+0x1f7>
                        tmp[i++] = digits[num2 % base2];
                        num2 /= base2;
                }
        }
        if (i > precision)
 80496f3:	8b 45 e0             	mov    -0x20(%ebp),%eax
 80496f6:	3b 45 20             	cmp    0x20(%ebp),%eax
 80496f9:	7e 06                	jle    8049701 <number+0x26d>
                precision = i;
 80496fb:	8b 45 e0             	mov    -0x20(%ebp),%eax
 80496fe:	89 45 20             	mov    %eax,0x20(%ebp)
        size -= precision;
 8049701:	8b 45 20             	mov    0x20(%ebp),%eax
 8049704:	29 45 1c             	sub    %eax,0x1c(%ebp)
        if (!(type & (ZEROPAD + LEFT))) {
 8049707:	8b 45 24             	mov    0x24(%ebp),%eax
 804970a:	83 e0 11             	and    $0x11,%eax
 804970d:	85 c0                	test   %eax,%eax
 804970f:	75 23                	jne    8049734 <number+0x2a0>
                while (size-- > 0) {
 8049711:	eb 12                	jmp    8049725 <number+0x291>
                        if (buf <= end)
 8049713:	8b 45 08             	mov    0x8(%ebp),%eax
 8049716:	3b 45 0c             	cmp    0xc(%ebp),%eax
 8049719:	77 06                	ja     8049721 <number+0x28d>
                                *buf = ' ';
 804971b:	8b 45 08             	mov    0x8(%ebp),%eax
 804971e:	c6 00 20             	movb   $0x20,(%eax)
                        ++buf;
 8049721:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        }
        if (i > precision)
                precision = i;
        size -= precision;
        if (!(type & (ZEROPAD + LEFT))) {
                while (size-- > 0) {
 8049725:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
 8049729:	0f 9f c0             	setg   %al
 804972c:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
 8049730:	84 c0                	test   %al,%al
 8049732:	75 df                	jne    8049713 <number+0x27f>
                        if (buf <= end)
                                *buf = ' ';
                        ++buf;
                }
        }
        if (sign) {
 8049734:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
 8049738:	74 15                	je     804974f <number+0x2bb>
                if (buf <= end)
 804973a:	8b 45 08             	mov    0x8(%ebp),%eax
 804973d:	3b 45 0c             	cmp    0xc(%ebp),%eax
 8049740:	77 09                	ja     804974b <number+0x2b7>
                        *buf = sign;
 8049742:	8b 45 08             	mov    0x8(%ebp),%eax
 8049745:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
 8049749:	88 10                	mov    %dl,(%eax)
                ++buf;
 804974b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        }
        if (type & SPECIAL) {
 804974f:	8b 45 24             	mov    0x24(%ebp),%eax
 8049752:	83 e0 20             	and    $0x20,%eax
 8049755:	85 c0                	test   %eax,%eax
 8049757:	74 4a                	je     80497a3 <number+0x30f>
                if (base == 8) {
 8049759:	83 7d 18 08          	cmpl   $0x8,0x18(%ebp)
 804975d:	75 14                	jne    8049773 <number+0x2df>
                        if (buf <= end)
 804975f:	8b 45 08             	mov    0x8(%ebp),%eax
 8049762:	3b 45 0c             	cmp    0xc(%ebp),%eax
 8049765:	77 06                	ja     804976d <number+0x2d9>
                                *buf = '0';
 8049767:	8b 45 08             	mov    0x8(%ebp),%eax
 804976a:	c6 00 30             	movb   $0x30,(%eax)
                        ++buf;
 804976d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 8049771:	eb 30                	jmp    80497a3 <number+0x30f>
                } else if (base == 16) {
 8049773:	83 7d 18 10          	cmpl   $0x10,0x18(%ebp)
 8049777:	75 2a                	jne    80497a3 <number+0x30f>
                        if (buf <= end)
 8049779:	8b 45 08             	mov    0x8(%ebp),%eax
 804977c:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804977f:	77 06                	ja     8049787 <number+0x2f3>
                                *buf = '0';
 8049781:	8b 45 08             	mov    0x8(%ebp),%eax
 8049784:	c6 00 30             	movb   $0x30,(%eax)
                        ++buf;
 8049787:	83 45 08 01          	addl   $0x1,0x8(%ebp)
                        if (buf <= end)
 804978b:	8b 45 08             	mov    0x8(%ebp),%eax
 804978e:	3b 45 0c             	cmp    0xc(%ebp),%eax
 8049791:	77 0c                	ja     804979f <number+0x30b>
                                *buf = digits[33];
 8049793:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049796:	0f b6 50 21          	movzbl 0x21(%eax),%edx
 804979a:	8b 45 08             	mov    0x8(%ebp),%eax
 804979d:	88 10                	mov    %dl,(%eax)
                        ++buf;
 804979f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
                }
        }
        if (!(type & LEFT)) {
 80497a3:	8b 45 24             	mov    0x24(%ebp),%eax
 80497a6:	83 e0 10             	and    $0x10,%eax
 80497a9:	85 c0                	test   %eax,%eax
 80497ab:	75 3c                	jne    80497e9 <number+0x355>
                while (size-- > 0) {
 80497ad:	eb 15                	jmp    80497c4 <number+0x330>
                        if (buf <= end)
 80497af:	8b 45 08             	mov    0x8(%ebp),%eax
 80497b2:	3b 45 0c             	cmp    0xc(%ebp),%eax
 80497b5:	77 09                	ja     80497c0 <number+0x32c>
                                *buf = c;
 80497b7:	8b 45 08             	mov    0x8(%ebp),%eax
 80497ba:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
 80497be:	88 10                	mov    %dl,(%eax)
                        ++buf;
 80497c0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
                                *buf = digits[33];
                        ++buf;
                }
        }
        if (!(type & LEFT)) {
                while (size-- > 0) {
 80497c4:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
 80497c8:	0f 9f c0             	setg   %al
 80497cb:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
 80497cf:	84 c0                	test   %al,%al
 80497d1:	75 dc                	jne    80497af <number+0x31b>
                        if (buf <= end)
                                *buf = c;
                        ++buf;
                }
        }
        while (i < precision--) {
 80497d3:	eb 14                	jmp    80497e9 <number+0x355>
                if (buf <= end)
 80497d5:	8b 45 08             	mov    0x8(%ebp),%eax
 80497d8:	3b 45 0c             	cmp    0xc(%ebp),%eax
 80497db:	77 06                	ja     80497e3 <number+0x34f>
                        *buf = '0';
 80497dd:	8b 45 08             	mov    0x8(%ebp),%eax
 80497e0:	c6 00 30             	movb   $0x30,(%eax)
                ++buf;
 80497e3:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 80497e7:	eb 01                	jmp    80497ea <number+0x356>
                        if (buf <= end)
                                *buf = c;
                        ++buf;
                }
        }
        while (i < precision--) {
 80497e9:	90                   	nop
 80497ea:	8b 45 20             	mov    0x20(%ebp),%eax
 80497ed:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 80497f0:	0f 9f c0             	setg   %al
 80497f3:	83 6d 20 01          	subl   $0x1,0x20(%ebp)
 80497f7:	84 c0                	test   %al,%al
 80497f9:	75 da                	jne    80497d5 <number+0x341>
                if (buf <= end)
                        *buf = '0';
                ++buf;
        }
        while (i-- > 0) {
 80497fb:	eb 1a                	jmp    8049817 <number+0x383>
                if (buf <= end)
 80497fd:	8b 45 08             	mov    0x8(%ebp),%eax
 8049800:	3b 45 0c             	cmp    0xc(%ebp),%eax
 8049803:	77 0e                	ja     8049813 <number+0x37f>
                        *buf = tmp[i];
 8049805:	8d 45 8a             	lea    -0x76(%ebp),%eax
 8049808:	03 45 e0             	add    -0x20(%ebp),%eax
 804980b:	0f b6 10             	movzbl (%eax),%edx
 804980e:	8b 45 08             	mov    0x8(%ebp),%eax
 8049811:	88 10                	mov    %dl,(%eax)
                ++buf;
 8049813:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        while (i < precision--) {
                if (buf <= end)
                        *buf = '0';
                ++buf;
        }
        while (i-- > 0) {
 8049817:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
 804981b:	0f 9f c0             	setg   %al
 804981e:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
 8049822:	84 c0                	test   %al,%al
 8049824:	75 d7                	jne    80497fd <number+0x369>
                if (buf <= end)
                        *buf = tmp[i];
                ++buf;
        }
        while (size-- > 0) {
 8049826:	eb 12                	jmp    804983a <number+0x3a6>
                if (buf <= end)
 8049828:	8b 45 08             	mov    0x8(%ebp),%eax
 804982b:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804982e:	77 06                	ja     8049836 <number+0x3a2>
                        *buf = ' ';
 8049830:	8b 45 08             	mov    0x8(%ebp),%eax
 8049833:	c6 00 20             	movb   $0x20,(%eax)
                ++buf;
 8049836:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        while (i-- > 0) {
                if (buf <= end)
                        *buf = tmp[i];
                ++buf;
        }
        while (size-- > 0) {
 804983a:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
 804983e:	0f 9f c0             	setg   %al
 8049841:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
 8049845:	84 c0                	test   %al,%al
 8049847:	75 df                	jne    8049828 <number+0x394>
                if (buf <= end)
                        *buf = ' ';
                ++buf;
        }
        return buf;
 8049849:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804984c:	81 c4 dc 00 00 00    	add    $0xdc,%esp
 8049852:	5b                   	pop    %ebx
 8049853:	5e                   	pop    %esi
 8049854:	5f                   	pop    %edi
 8049855:	5d                   	pop    %ebp
 8049856:	c3                   	ret    

08049857 <vsnprintf>:
*
* Call this function if you are already dealing with a va_list.
* You probably want snprintf instead.
 */
int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
{
 8049857:	55                   	push   %ebp
 8049858:	89 e5                	mov    %esp,%ebp
 804985a:	53                   	push   %ebx
 804985b:	83 ec 64             	sub    $0x64,%esp
 804985e:	e8 02 ec ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 8049863:	81 c3 49 69 00 00    	add    $0x6949,%ebx
                                   number of chars for from string */
        int qualifier;              /* 'h', 'l', or 'L' for integer fields */
        /* 'z' support added 23/7/1999 S.H.    */
        /* 'z' changed to 'Z' --davidm 1/25/99 */

        str = buf;
 8049869:	8b 45 08             	mov    0x8(%ebp),%eax
 804986c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        end = buf + size - 1;
 804986f:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049872:	83 e8 01             	sub    $0x1,%eax
 8049875:	03 45 08             	add    0x8(%ebp),%eax
 8049878:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if (end < buf - 1) {
 804987b:	8b 45 08             	mov    0x8(%ebp),%eax
 804987e:	83 e8 01             	sub    $0x1,%eax
 8049881:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8049884:	0f 86 65 07 00 00    	jbe    8049fef <vsnprintf+0x798>
                end = ((void *) - 1);
 804988a:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
                size = end - buf + 1;
 8049891:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8049894:	8b 45 08             	mov    0x8(%ebp),%eax
 8049897:	89 d1                	mov    %edx,%ecx
 8049899:	29 c1                	sub    %eax,%ecx
 804989b:	89 c8                	mov    %ecx,%eax
 804989d:	83 c0 01             	add    $0x1,%eax
 80498a0:	89 45 0c             	mov    %eax,0xc(%ebp)
        }

        for (; *fmt ; ++fmt) {
 80498a3:	e9 47 07 00 00       	jmp    8049fef <vsnprintf+0x798>
                if (*fmt != '%') {
 80498a8:	8b 45 10             	mov    0x10(%ebp),%eax
 80498ab:	0f b6 00             	movzbl (%eax),%eax
 80498ae:	3c 25                	cmp    $0x25,%al
 80498b0:	74 1c                	je     80498ce <vsnprintf+0x77>
                        if (str <= end)
 80498b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80498b5:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 80498b8:	77 0b                	ja     80498c5 <vsnprintf+0x6e>
                                *str = *fmt;
 80498ba:	8b 45 10             	mov    0x10(%ebp),%eax
 80498bd:	0f b6 10             	movzbl (%eax),%edx
 80498c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80498c3:	88 10                	mov    %dl,(%eax)
                        ++str;
 80498c5:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                        continue;
 80498c9:	e9 16 07 00 00       	jmp    8049fe4 <vsnprintf+0x78d>
                }

                /* process flags */
                flags = 0;
 80498ce:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
repeat:
                ++fmt;          /* this also skips first '%' */
 80498d5:	8b 45 10             	mov    0x10(%ebp),%eax
 80498d8:	83 c0 01             	add    $0x1,%eax
 80498db:	89 45 10             	mov    %eax,0x10(%ebp)
                switch (*fmt) {
 80498de:	8b 45 10             	mov    0x10(%ebp),%eax
 80498e1:	0f b6 00             	movzbl (%eax),%eax
 80498e4:	0f be c0             	movsbl %al,%eax
 80498e7:	83 e8 20             	sub    $0x20,%eax
 80498ea:	83 f8 10             	cmp    $0x10,%eax
 80498ed:	0f 87 83 00 00 00    	ja     8049976 <vsnprintf+0x11f>
 80498f3:	c1 e0 02             	shl    $0x2,%eax
 80498f6:	8b 84 18 5c 97 ff ff 	mov    -0x68a4(%eax,%ebx,1),%eax
 80498fd:	89 da                	mov    %ebx,%edx
 80498ff:	29 c2                	sub    %eax,%edx
 8049901:	89 d0                	mov    %edx,%eax
 8049903:	ff e0                	jmp    *%eax
 8049905:	8d 76 00             	lea    0x0(%esi),%esi
 8049908:	51                   	push   %ecx
 8049909:	68 00 00 36 68       	push   $0x68360000
 804990e:	00 00                	add    %al,(%eax)
 8049910:	36                   	ss
 8049911:	68 00 00 48 68       	push   $0x68480000
 8049916:	00 00                	add    %al,(%eax)
 8049918:	36                   	ss
 8049919:	68 00 00 36 68       	push   $0x68360000
 804991e:	00 00                	add    %al,(%eax)
 8049920:	36                   	ss
 8049921:	68 00 00 36 68       	push   $0x68360000
 8049926:	00 00                	add    %al,(%eax)
 8049928:	36                   	ss
 8049929:	68 00 00 36 68       	push   $0x68360000
 804992e:	00 00                	add    %al,(%eax)
 8049930:	36                   	ss
 8049931:	68 00 00 5a 68       	push   $0x685a0000
 8049936:	00 00                	add    %al,(%eax)
 8049938:	36                   	ss
 8049939:	68 00 00 60 68       	push   $0x68600000
 804993e:	00 00                	add    %al,(%eax)
 8049940:	36                   	ss
 8049941:	68 00 00 36 68       	push   $0x68360000
 8049946:	00 00                	add    %al,(%eax)
 8049948:	3f                   	aas    
 8049949:	68 00 00 83 4d       	push   $0x4d830000
                        case '-': flags |= LEFT; goto repeat;
 804994e:	d8 10                	fcoms  (%eax)
 8049950:	eb 83                	jmp    80498d5 <vsnprintf+0x7e>
                        case '+': flags |= PLUS; goto repeat;
 8049952:	83 4d d8 04          	orl    $0x4,-0x28(%ebp)
 8049956:	e9 7a ff ff ff       	jmp    80498d5 <vsnprintf+0x7e>
                        case ' ': flags |= SPACE; goto repeat;
 804995b:	83 4d d8 08          	orl    $0x8,-0x28(%ebp)
 804995f:	e9 71 ff ff ff       	jmp    80498d5 <vsnprintf+0x7e>
                        case '#': flags |= SPECIAL; goto repeat;
 8049964:	83 4d d8 20          	orl    $0x20,-0x28(%ebp)
 8049968:	e9 68 ff ff ff       	jmp    80498d5 <vsnprintf+0x7e>
                        case '0': flags |= ZEROPAD; goto repeat;
 804996d:	83 4d d8 01          	orl    $0x1,-0x28(%ebp)
 8049971:	e9 5f ff ff ff       	jmp    80498d5 <vsnprintf+0x7e>
                }

                /* get field width */
                field_width = -1;
 8049976:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%ebp)
                if (isdigit(*fmt))
 804997d:	8b 45 10             	mov    0x10(%ebp),%eax
 8049980:	0f b6 00             	movzbl (%eax),%eax
 8049983:	0f b6 c0             	movzbl %al,%eax
 8049986:	0f b6 84 03 34 00 00 	movzbl 0x34(%ebx,%eax,1),%eax
 804998d:	00 
 804998e:	0f b6 c0             	movzbl %al,%eax
 8049991:	83 e0 04             	and    $0x4,%eax
 8049994:	85 c0                	test   %eax,%eax
 8049996:	74 10                	je     80499a8 <vsnprintf+0x151>
                        field_width = skip_atoi(&fmt);
 8049998:	8d 45 10             	lea    0x10(%ebp),%eax
 804999b:	89 04 24             	mov    %eax,(%esp)
 804999e:	e8 87 fa ff ff       	call   804942a <skip_atoi>
 80499a3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 80499a6:	eb 2e                	jmp    80499d6 <vsnprintf+0x17f>
                else if (*fmt == '*') {
 80499a8:	8b 45 10             	mov    0x10(%ebp),%eax
 80499ab:	0f b6 00             	movzbl (%eax),%eax
 80499ae:	3c 2a                	cmp    $0x2a,%al
 80499b0:	75 24                	jne    80499d6 <vsnprintf+0x17f>
                        ++fmt;
 80499b2:	8b 45 10             	mov    0x10(%ebp),%eax
 80499b5:	83 c0 01             	add    $0x1,%eax
 80499b8:	89 45 10             	mov    %eax,0x10(%ebp)
                        /* it's the next argument */
                        field_width = va_arg(args, int);
 80499bb:	8b 45 14             	mov    0x14(%ebp),%eax
 80499be:	8d 50 04             	lea    0x4(%eax),%edx
 80499c1:	89 55 14             	mov    %edx,0x14(%ebp)
 80499c4:	8b 00                	mov    (%eax),%eax
 80499c6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
                        if (field_width < 0) {
 80499c9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 80499cd:	79 07                	jns    80499d6 <vsnprintf+0x17f>
                                field_width = -field_width;
 80499cf:	f7 5d d4             	negl   -0x2c(%ebp)
                                flags |= LEFT;
 80499d2:	83 4d d8 10          	orl    $0x10,-0x28(%ebp)
                        }
                }

                /* get the precision */
                precision = -1;
 80499d6:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
                if (*fmt == '.') {
 80499dd:	8b 45 10             	mov    0x10(%ebp),%eax
 80499e0:	0f b6 00             	movzbl (%eax),%eax
 80499e3:	3c 2e                	cmp    $0x2e,%al
 80499e5:	75 62                	jne    8049a49 <vsnprintf+0x1f2>
                        ++fmt;
 80499e7:	8b 45 10             	mov    0x10(%ebp),%eax
 80499ea:	83 c0 01             	add    $0x1,%eax
 80499ed:	89 45 10             	mov    %eax,0x10(%ebp)
                        if (isdigit(*fmt))
 80499f0:	8b 45 10             	mov    0x10(%ebp),%eax
 80499f3:	0f b6 00             	movzbl (%eax),%eax
 80499f6:	0f b6 c0             	movzbl %al,%eax
 80499f9:	0f b6 84 03 34 00 00 	movzbl 0x34(%ebx,%eax,1),%eax
 8049a00:	00 
 8049a01:	0f b6 c0             	movzbl %al,%eax
 8049a04:	83 e0 04             	and    $0x4,%eax
 8049a07:	85 c0                	test   %eax,%eax
 8049a09:	74 10                	je     8049a1b <vsnprintf+0x1c4>
                                precision = skip_atoi(&fmt);
 8049a0b:	8d 45 10             	lea    0x10(%ebp),%eax
 8049a0e:	89 04 24             	mov    %eax,(%esp)
 8049a11:	e8 14 fa ff ff       	call   804942a <skip_atoi>
 8049a16:	89 45 d0             	mov    %eax,-0x30(%ebp)
 8049a19:	eb 21                	jmp    8049a3c <vsnprintf+0x1e5>
                        else if (*fmt == '*') {
 8049a1b:	8b 45 10             	mov    0x10(%ebp),%eax
 8049a1e:	0f b6 00             	movzbl (%eax),%eax
 8049a21:	3c 2a                	cmp    $0x2a,%al
 8049a23:	75 17                	jne    8049a3c <vsnprintf+0x1e5>
                                ++fmt;
 8049a25:	8b 45 10             	mov    0x10(%ebp),%eax
 8049a28:	83 c0 01             	add    $0x1,%eax
 8049a2b:	89 45 10             	mov    %eax,0x10(%ebp)
                                /* it's the next argument */
                                precision = va_arg(args, int);
 8049a2e:	8b 45 14             	mov    0x14(%ebp),%eax
 8049a31:	8d 50 04             	lea    0x4(%eax),%edx
 8049a34:	89 55 14             	mov    %edx,0x14(%ebp)
 8049a37:	8b 00                	mov    (%eax),%eax
 8049a39:	89 45 d0             	mov    %eax,-0x30(%ebp)
                        }
                        if (precision < 0)
 8049a3c:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 8049a40:	79 07                	jns    8049a49 <vsnprintf+0x1f2>
                                precision = 0;
 8049a42:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
                }

                /* get the conversion qualifier */
                qualifier = -1;
 8049a49:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,-0x34(%ebp)
                if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt == 'Z') {
 8049a50:	8b 45 10             	mov    0x10(%ebp),%eax
 8049a53:	0f b6 00             	movzbl (%eax),%eax
 8049a56:	3c 68                	cmp    $0x68,%al
 8049a58:	74 1e                	je     8049a78 <vsnprintf+0x221>
 8049a5a:	8b 45 10             	mov    0x10(%ebp),%eax
 8049a5d:	0f b6 00             	movzbl (%eax),%eax
 8049a60:	3c 6c                	cmp    $0x6c,%al
 8049a62:	74 14                	je     8049a78 <vsnprintf+0x221>
 8049a64:	8b 45 10             	mov    0x10(%ebp),%eax
 8049a67:	0f b6 00             	movzbl (%eax),%eax
 8049a6a:	3c 4c                	cmp    $0x4c,%al
 8049a6c:	74 0a                	je     8049a78 <vsnprintf+0x221>
 8049a6e:	8b 45 10             	mov    0x10(%ebp),%eax
 8049a71:	0f b6 00             	movzbl (%eax),%eax
 8049a74:	3c 5a                	cmp    $0x5a,%al
 8049a76:	75 35                	jne    8049aad <vsnprintf+0x256>
                        qualifier = *fmt;
 8049a78:	8b 45 10             	mov    0x10(%ebp),%eax
 8049a7b:	0f b6 00             	movzbl (%eax),%eax
 8049a7e:	0f be c0             	movsbl %al,%eax
 8049a81:	89 45 cc             	mov    %eax,-0x34(%ebp)
                        ++fmt;
 8049a84:	8b 45 10             	mov    0x10(%ebp),%eax
 8049a87:	83 c0 01             	add    $0x1,%eax
 8049a8a:	89 45 10             	mov    %eax,0x10(%ebp)
                        if (qualifier == 'l' && *fmt == 'l') {
 8049a8d:	83 7d cc 6c          	cmpl   $0x6c,-0x34(%ebp)
 8049a91:	75 1a                	jne    8049aad <vsnprintf+0x256>
 8049a93:	8b 45 10             	mov    0x10(%ebp),%eax
 8049a96:	0f b6 00             	movzbl (%eax),%eax
 8049a99:	3c 6c                	cmp    $0x6c,%al
 8049a9b:	75 10                	jne    8049aad <vsnprintf+0x256>
                                qualifier = 'L';
 8049a9d:	c7 45 cc 4c 00 00 00 	movl   $0x4c,-0x34(%ebp)
                                ++fmt;
 8049aa4:	8b 45 10             	mov    0x10(%ebp),%eax
 8049aa7:	83 c0 01             	add    $0x1,%eax
 8049aaa:	89 45 10             	mov    %eax,0x10(%ebp)
                        }
                }
                if (*fmt == 'q') {
 8049aad:	8b 45 10             	mov    0x10(%ebp),%eax
 8049ab0:	0f b6 00             	movzbl (%eax),%eax
 8049ab3:	3c 71                	cmp    $0x71,%al
 8049ab5:	75 10                	jne    8049ac7 <vsnprintf+0x270>
                        qualifier = 'L';
 8049ab7:	c7 45 cc 4c 00 00 00 	movl   $0x4c,-0x34(%ebp)
                        ++fmt;
 8049abe:	8b 45 10             	mov    0x10(%ebp),%eax
 8049ac1:	83 c0 01             	add    $0x1,%eax
 8049ac4:	89 45 10             	mov    %eax,0x10(%ebp)
                }

                /* default base */
                base = 10;
 8049ac7:	c7 45 e8 0a 00 00 00 	movl   $0xa,-0x18(%ebp)

                switch (*fmt) {
 8049ace:	8b 45 10             	mov    0x10(%ebp),%eax
 8049ad1:	0f b6 00             	movzbl (%eax),%eax
 8049ad4:	0f be c0             	movsbl %al,%eax
 8049ad7:	83 e8 25             	sub    $0x25,%eax
 8049ada:	83 f8 53             	cmp    $0x53,%eax
 8049add:	0f 87 9d 03 00 00    	ja     8049e80 <vsnprintf+0x629>
 8049ae3:	c1 e0 02             	shl    $0x2,%eax
 8049ae6:	8b 84 18 4c 99 ff ff 	mov    -0x66b4(%eax,%ebx,1),%eax
 8049aed:	89 d9                	mov    %ebx,%ecx
 8049aef:	29 c1                	sub    %eax,%ecx
 8049af1:	89 c8                	mov    %ecx,%eax
 8049af3:	ff e0                	jmp    *%eax
 8049af5:	8d 76 00             	lea    0x0(%esi),%esi
 8049af8:	69 63 00 00 2c 63 00 	imul   $0x632c00,0x0(%ebx),%esp
 8049aff:	00 2c 63             	add    %ch,(%ebx,%eiz,2)
 8049b02:	00 00                	add    %al,(%eax)
 8049b04:	2c 63                	sub    $0x63,%al
 8049b06:	00 00                	add    %al,(%eax)
 8049b08:	2c 63                	sub    $0x63,%al
 8049b0a:	00 00                	add    %al,(%eax)
 8049b0c:	2c 63                	sub    $0x63,%al
 8049b0e:	00 00                	add    %al,(%eax)
 8049b10:	2c 63                	sub    $0x63,%al
 8049b12:	00 00                	add    %al,(%eax)
 8049b14:	2c 63                	sub    $0x63,%al
 8049b16:	00 00                	add    %al,(%eax)
 8049b18:	2c 63                	sub    $0x63,%al
 8049b1a:	00 00                	add    %al,(%eax)
 8049b1c:	2c 63                	sub    $0x63,%al
 8049b1e:	00 00                	add    %al,(%eax)
 8049b20:	2c 63                	sub    $0x63,%al
 8049b22:	00 00                	add    %al,(%eax)
 8049b24:	2c 63                	sub    $0x63,%al
 8049b26:	00 00                	add    %al,(%eax)
 8049b28:	2c 63                	sub    $0x63,%al
 8049b2a:	00 00                	add    %al,(%eax)
 8049b2c:	2c 63                	sub    $0x63,%al
 8049b2e:	00 00                	add    %al,(%eax)
 8049b30:	2c 63                	sub    $0x63,%al
 8049b32:	00 00                	add    %al,(%eax)
 8049b34:	2c 63                	sub    $0x63,%al
 8049b36:	00 00                	add    %al,(%eax)
 8049b38:	2c 63                	sub    $0x63,%al
 8049b3a:	00 00                	add    %al,(%eax)
 8049b3c:	2c 63                	sub    $0x63,%al
 8049b3e:	00 00                	add    %al,(%eax)
 8049b40:	2c 63                	sub    $0x63,%al
 8049b42:	00 00                	add    %al,(%eax)
 8049b44:	2c 63                	sub    $0x63,%al
 8049b46:	00 00                	add    %al,(%eax)
 8049b48:	2c 63                	sub    $0x63,%al
 8049b4a:	00 00                	add    %al,(%eax)
 8049b4c:	2c 63                	sub    $0x63,%al
 8049b4e:	00 00                	add    %al,(%eax)
 8049b50:	2c 63                	sub    $0x63,%al
 8049b52:	00 00                	add    %al,(%eax)
 8049b54:	2c 63                	sub    $0x63,%al
 8049b56:	00 00                	add    %al,(%eax)
 8049b58:	2c 63                	sub    $0x63,%al
 8049b5a:	00 00                	add    %al,(%eax)
 8049b5c:	2c 63                	sub    $0x63,%al
 8049b5e:	00 00                	add    %al,(%eax)
 8049b60:	2c 63                	sub    $0x63,%al
 8049b62:	00 00                	add    %al,(%eax)
 8049b64:	2c 63                	sub    $0x63,%al
 8049b66:	00 00                	add    %al,(%eax)
 8049b68:	2c 63                	sub    $0x63,%al
 8049b6a:	00 00                	add    %al,(%eax)
 8049b6c:	2c 63                	sub    $0x63,%al
 8049b6e:	00 00                	add    %al,(%eax)
 8049b70:	2c 63                	sub    $0x63,%al
 8049b72:	00 00                	add    %al,(%eax)
 8049b74:	2c 63                	sub    $0x63,%al
 8049b76:	00 00                	add    %al,(%eax)
 8049b78:	2c 63                	sub    $0x63,%al
 8049b7a:	00 00                	add    %al,(%eax)
 8049b7c:	36 63 00             	arpl   %ax,%ss:(%eax)
 8049b7f:	00 36                	add    %dh,(%esi)
 8049b81:	63 00                	arpl   %ax,(%eax)
 8049b83:	00 2c 63             	add    %ch,(%ebx,%eiz,2)
 8049b86:	00 00                	add    %al,(%eax)
 8049b88:	2c 63                	sub    $0x63,%al
 8049b8a:	00 00                	add    %al,(%eax)
 8049b8c:	2c 63                	sub    $0x63,%al
 8049b8e:	00 00                	add    %al,(%eax)
 8049b90:	2c 63                	sub    $0x63,%al
 8049b92:	00 00                	add    %al,(%eax)
 8049b94:	2c 63                	sub    $0x63,%al
 8049b96:	00 00                	add    %al,(%eax)
 8049b98:	2c 63                	sub    $0x63,%al
 8049b9a:	00 00                	add    %al,(%eax)
 8049b9c:	2c 63                	sub    $0x63,%al
 8049b9e:	00 00                	add    %al,(%eax)
 8049ba0:	2c 63                	sub    $0x63,%al
 8049ba2:	00 00                	add    %al,(%eax)
 8049ba4:	2c 63                	sub    $0x63,%al
 8049ba6:	00 00                	add    %al,(%eax)
 8049ba8:	2c 63                	sub    $0x63,%al
 8049baa:	00 00                	add    %al,(%eax)
 8049bac:	2c 63                	sub    $0x63,%al
 8049bae:	00 00                	add    %al,(%eax)
 8049bb0:	2c 63                	sub    $0x63,%al
 8049bb2:	00 00                	add    %al,(%eax)
 8049bb4:	2c 63                	sub    $0x63,%al
 8049bb6:	00 00                	add    %al,(%eax)
 8049bb8:	2c 63                	sub    $0x63,%al
 8049bba:	00 00                	add    %al,(%eax)
 8049bbc:	2c 63                	sub    $0x63,%al
 8049bbe:	00 00                	add    %al,(%eax)
 8049bc0:	2c 63                	sub    $0x63,%al
 8049bc2:	00 00                	add    %al,(%eax)
 8049bc4:	49                   	dec    %ecx
 8049bc5:	63 00                	arpl   %ax,(%eax)
 8049bc7:	00 2c 63             	add    %ch,(%ebx,%eiz,2)
 8049bca:	00 00                	add    %al,(%eax)
 8049bcc:	2c 63                	sub    $0x63,%al
 8049bce:	00 00                	add    %al,(%eax)
 8049bd0:	2c 63                	sub    $0x63,%al
 8049bd2:	00 00                	add    %al,(%eax)
 8049bd4:	2c 63                	sub    $0x63,%al
 8049bd6:	00 00                	add    %al,(%eax)
 8049bd8:	2c 63                	sub    $0x63,%al
 8049bda:	00 00                	add    %al,(%eax)
 8049bdc:	2c 63                	sub    $0x63,%al
 8049bde:	00 00                	add    %al,(%eax)
 8049be0:	2c 63                	sub    $0x63,%al
 8049be2:	00 00                	add    %al,(%eax)
 8049be4:	2c 63                	sub    $0x63,%al
 8049be6:	00 00                	add    %al,(%eax)
 8049be8:	2c 63                	sub    $0x63,%al
 8049bea:	00 00                	add    %al,(%eax)
 8049bec:	2c 63                	sub    $0x63,%al
 8049bee:	00 00                	add    %al,(%eax)
 8049bf0:	64 65 00 00          	fs add %al,%fs:%gs:(%eax)
 8049bf4:	3c 63                	cmp    $0x63,%al
 8049bf6:	00 00                	add    %al,(%eax)
 8049bf8:	2c 63                	sub    $0x63,%al
 8049bfa:	00 00                	add    %al,(%eax)
 8049bfc:	36 63 00             	arpl   %ax,%ss:(%eax)
 8049bff:	00 36                	add    %dh,(%esi)
 8049c01:	63 00                	arpl   %ax,(%eax)
 8049c03:	00 2c 63             	add    %ch,(%ebx,%eiz,2)
 8049c06:	00 00                	add    %al,(%eax)
 8049c08:	3c 63                	cmp    $0x63,%al
 8049c0a:	00 00                	add    %al,(%eax)
 8049c0c:	2c 63                	sub    $0x63,%al
 8049c0e:	00 00                	add    %al,(%eax)
 8049c10:	2c 63                	sub    $0x63,%al
 8049c12:	00 00                	add    %al,(%eax)
 8049c14:	2c 63                	sub    $0x63,%al
 8049c16:	00 00                	add    %al,(%eax)
 8049c18:	2c 63                	sub    $0x63,%al
 8049c1a:	00 00                	add    %al,(%eax)
 8049c1c:	db 63 00             	(bad)  0x0(%ebx)
 8049c1f:	00 52 63             	add    %dl,0x63(%edx)
 8049c22:	00 00                	add    %al,(%eax)
 8049c24:	3b 64 00 00          	cmp    0x0(%eax,%eax,1),%esp
 8049c28:	2c 63                	sub    $0x63,%al
 8049c2a:	00 00                	add    %al,(%eax)
 8049c2c:	2c 63                	sub    $0x63,%al
 8049c2e:	00 00                	add    %al,(%eax)
 8049c30:	f6 64 00 00          	mulb   0x0(%eax,%eax,1)
 8049c34:	2c 63                	sub    $0x63,%al
 8049c36:	00 00                	add    %al,(%eax)
 8049c38:	e6 62                	out    %al,$0x62
 8049c3a:	00 00                	add    %al,(%eax)
 8049c3c:	2c 63                	sub    $0x63,%al
 8049c3e:	00 00                	add    %al,(%eax)
 8049c40:	2c 63                	sub    $0x63,%al
 8049c42:	00 00                	add    %al,(%eax)
 8049c44:	45                   	inc    %ebp
 8049c45:	63 00                	arpl   %ax,(%eax)
 8049c47:	00 8b 45 d8 83 e0    	add    %cl,-0x1f7c27bb(%ebx)
                        case 'c':
                                if (!(flags & LEFT)) {
 8049c4d:	10 85 c0 75 1e eb    	adc    %al,-0x14e18a40(%ebp)
                                        while (--field_width > 0) {
 8049c53:	12 8b 45 e4 3b 45    	adc    0x453be445(%ebx),%cl
                                                if (str <= end)
 8049c59:	e0 77                	loopne 8049cd2 <vsnprintf+0x47b>
 8049c5b:	06                   	push   %es
                                                        *str = ' ';
 8049c5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049c5f:	c6 00 20             	movb   $0x20,(%eax)
                                                ++str;
 8049c62:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                base = 10;

                switch (*fmt) {
                        case 'c':
                                if (!(flags & LEFT)) {
                                        while (--field_width > 0) {
 8049c66:	83 6d d4 01          	subl   $0x1,-0x2c(%ebp)
 8049c6a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 8049c6e:	7f e4                	jg     8049c54 <vsnprintf+0x3fd>
                                                if (str <= end)
                                                        *str = ' ';
                                                ++str;
                                        }
                                }
                                c = (unsigned char) va_arg(args, int);
 8049c70:	8b 45 14             	mov    0x14(%ebp),%eax
 8049c73:	8d 50 04             	lea    0x4(%eax),%edx
 8049c76:	89 55 14             	mov    %edx,0x14(%ebp)
 8049c79:	8b 00                	mov    (%eax),%eax
 8049c7b:	88 45 cb             	mov    %al,-0x35(%ebp)
                                if (str <= end)
 8049c7e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049c81:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8049c84:	77 09                	ja     8049c8f <vsnprintf+0x438>
                                        *str = c;
 8049c86:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049c89:	0f b6 55 cb          	movzbl -0x35(%ebp),%edx
 8049c8d:	88 10                	mov    %dl,(%eax)
                                ++str;
 8049c8f:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                                while (--field_width > 0) {
 8049c93:	eb 12                	jmp    8049ca7 <vsnprintf+0x450>
                                        if (str <= end)
 8049c95:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049c98:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8049c9b:	77 06                	ja     8049ca3 <vsnprintf+0x44c>
                                                *str = ' ';
 8049c9d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049ca0:	c6 00 20             	movb   $0x20,(%eax)
                                        ++str;
 8049ca3:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                                }
                                c = (unsigned char) va_arg(args, int);
                                if (str <= end)
                                        *str = c;
                                ++str;
                                while (--field_width > 0) {
 8049ca7:	83 6d d4 01          	subl   $0x1,-0x2c(%ebp)
 8049cab:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 8049caf:	7f e4                	jg     8049c95 <vsnprintf+0x43e>
                                        if (str <= end)
                                                *str = ' ';
                                        ++str;
                                }
                                continue;
 8049cb1:	e9 2e 03 00 00       	jmp    8049fe4 <vsnprintf+0x78d>

                        case 's':
                                s = va_arg(args, char *);
 8049cb6:	8b 45 14             	mov    0x14(%ebp),%eax
 8049cb9:	8d 50 04             	lea    0x4(%eax),%edx
 8049cbc:	89 55 14             	mov    %edx,0x14(%ebp)
 8049cbf:	8b 00                	mov    (%eax),%eax
 8049cc1:	89 45 dc             	mov    %eax,-0x24(%ebp)
                                if (!s)
 8049cc4:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 8049cc8:	75 09                	jne    8049cd3 <vsnprintf+0x47c>
                                        s = "<NULL>";
 8049cca:	8d 83 d8 d5 ff ff    	lea    -0x2a28(%ebx),%eax
 8049cd0:	89 45 dc             	mov    %eax,-0x24(%ebp)

                                len = strnlen(s, precision);
 8049cd3:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8049cd6:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049cda:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8049cdd:	89 04 24             	mov    %eax,(%esp)
 8049ce0:	e8 0f 2f 00 00       	call   804cbf4 <strnlen>
 8049ce5:	89 45 c4             	mov    %eax,-0x3c(%ebp)

                                if (!(flags & LEFT)) {
 8049ce8:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049ceb:	83 e0 10             	and    $0x10,%eax
 8049cee:	85 c0                	test   %eax,%eax
 8049cf0:	75 25                	jne    8049d17 <vsnprintf+0x4c0>
                                        while (len < field_width--) {
 8049cf2:	eb 12                	jmp    8049d06 <vsnprintf+0x4af>
                                                if (str <= end)
 8049cf4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049cf7:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8049cfa:	77 06                	ja     8049d02 <vsnprintf+0x4ab>
                                                        *str = ' ';
 8049cfc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049cff:	c6 00 20             	movb   $0x20,(%eax)
                                                ++str;
 8049d02:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                                        s = "<NULL>";

                                len = strnlen(s, precision);

                                if (!(flags & LEFT)) {
                                        while (len < field_width--) {
 8049d06:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049d09:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
 8049d0c:	0f 9f c0             	setg   %al
 8049d0f:	83 6d d4 01          	subl   $0x1,-0x2c(%ebp)
 8049d13:	84 c0                	test   %al,%al
 8049d15:	75 dd                	jne    8049cf4 <vsnprintf+0x49d>
                                                if (str <= end)
                                                        *str = ' ';
                                                ++str;
                                        }
                                }
                                for (i = 0; i < len; ++i) {
 8049d17:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 8049d1e:	eb 1f                	jmp    8049d3f <vsnprintf+0x4e8>
                                        if (str <= end)
 8049d20:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049d23:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8049d26:	77 0b                	ja     8049d33 <vsnprintf+0x4dc>
                                                *str = *s;
 8049d28:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8049d2b:	0f b6 10             	movzbl (%eax),%edx
 8049d2e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049d31:	88 10                	mov    %dl,(%eax)
                                        ++str; ++s;
 8049d33:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
 8049d37:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
                                                if (str <= end)
                                                        *str = ' ';
                                                ++str;
                                        }
                                }
                                for (i = 0; i < len; ++i) {
 8049d3b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
 8049d3f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049d42:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
 8049d45:	7c d9                	jl     8049d20 <vsnprintf+0x4c9>
                                        if (str <= end)
                                                *str = *s;
                                        ++str; ++s;
                                }
                                while (len < field_width--) {
 8049d47:	eb 12                	jmp    8049d5b <vsnprintf+0x504>
                                        if (str <= end)
 8049d49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049d4c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8049d4f:	77 06                	ja     8049d57 <vsnprintf+0x500>
                                                *str = ' ';
 8049d51:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049d54:	c6 00 20             	movb   $0x20,(%eax)
                                        ++str;
 8049d57:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                                for (i = 0; i < len; ++i) {
                                        if (str <= end)
                                                *str = *s;
                                        ++str; ++s;
                                }
                                while (len < field_width--) {
 8049d5b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049d5e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
 8049d61:	0f 9f c0             	setg   %al
 8049d64:	83 6d d4 01          	subl   $0x1,-0x2c(%ebp)
 8049d68:	84 c0                	test   %al,%al
 8049d6a:	75 dd                	jne    8049d49 <vsnprintf+0x4f2>
                                        if (str <= end)
                                                *str = ' ';
                                        ++str;
                                }
                                continue;
 8049d6c:	e9 73 02 00 00       	jmp    8049fe4 <vsnprintf+0x78d>

                        case 'p':
                                if (field_width == -1) {
 8049d71:	83 7d d4 ff          	cmpl   $0xffffffff,-0x2c(%ebp)
 8049d75:	75 0b                	jne    8049d82 <vsnprintf+0x52b>
                                        field_width = 2 * sizeof(void *);
 8049d77:	c7 45 d4 08 00 00 00 	movl   $0x8,-0x2c(%ebp)
                                        flags |= ZEROPAD;
 8049d7e:	83 4d d8 01          	orl    $0x1,-0x28(%ebp)
                                }
                                str = number(str, end,
                                             (unsigned long) va_arg(args, void *),
 8049d82:	8b 45 14             	mov    0x14(%ebp),%eax
 8049d85:	8d 50 04             	lea    0x4(%eax),%edx
 8049d88:	89 55 14             	mov    %edx,0x14(%ebp)
 8049d8b:	8b 00                	mov    (%eax),%eax
                        case 'p':
                                if (field_width == -1) {
                                        field_width = 2 * sizeof(void *);
                                        flags |= ZEROPAD;
                                }
                                str = number(str, end,
 8049d8d:	ba 00 00 00 00       	mov    $0x0,%edx
 8049d92:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 8049d95:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
 8049d99:	8b 4d d0             	mov    -0x30(%ebp),%ecx
 8049d9c:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 8049da0:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 8049da3:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 8049da7:	c7 44 24 10 10 00 00 	movl   $0x10,0x10(%esp)
 8049dae:	00 
 8049daf:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049db3:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8049db7:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049dba:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049dbe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049dc1:	89 04 24             	mov    %eax,(%esp)
 8049dc4:	e8 cb f6 ff ff       	call   8049494 <number>
 8049dc9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                                             (unsigned long) va_arg(args, void *),
                                             16, field_width, precision, flags);
                                continue;
 8049dcc:	e9 13 02 00 00       	jmp    8049fe4 <vsnprintf+0x78d>


                        case 'n':
                                /* FIXME:
                                 * What does C99 say about the overflow case here? */
                                if (qualifier == 'l') {
 8049dd1:	83 7d cc 6c          	cmpl   $0x6c,-0x34(%ebp)
 8049dd5:	75 20                	jne    8049df7 <vsnprintf+0x5a0>
                                        long *ip = va_arg(args, long *);
 8049dd7:	8b 45 14             	mov    0x14(%ebp),%eax
 8049dda:	8d 50 04             	lea    0x4(%eax),%edx
 8049ddd:	89 55 14             	mov    %edx,0x14(%ebp)
 8049de0:	8b 00                	mov    (%eax),%eax
 8049de2:	89 45 c0             	mov    %eax,-0x40(%ebp)
                                        *ip = (str - buf);
 8049de5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8049de8:	8b 45 08             	mov    0x8(%ebp),%eax
 8049deb:	29 c2                	sub    %eax,%edx
 8049ded:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049df0:	89 10                	mov    %edx,(%eax)
                                        *ip = (str - buf);
                                } else {
                                        int *ip = va_arg(args, int *);
                                        *ip = (str - buf);
                                }
                                continue;
 8049df2:	e9 ed 01 00 00       	jmp    8049fe4 <vsnprintf+0x78d>
                                /* FIXME:
                                 * What does C99 say about the overflow case here? */
                                if (qualifier == 'l') {
                                        long *ip = va_arg(args, long *);
                                        *ip = (str - buf);
                                } else if (qualifier == 'Z') {
 8049df7:	83 7d cc 5a          	cmpl   $0x5a,-0x34(%ebp)
 8049dfb:	75 26                	jne    8049e23 <vsnprintf+0x5cc>
                                        size_t *ip = va_arg(args, size_t *);
 8049dfd:	8b 45 14             	mov    0x14(%ebp),%eax
 8049e00:	8d 50 04             	lea    0x4(%eax),%edx
 8049e03:	89 55 14             	mov    %edx,0x14(%ebp)
 8049e06:	8b 00                	mov    (%eax),%eax
 8049e08:	89 45 bc             	mov    %eax,-0x44(%ebp)
                                        *ip = (str - buf);
 8049e0b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8049e0e:	8b 45 08             	mov    0x8(%ebp),%eax
 8049e11:	89 d1                	mov    %edx,%ecx
 8049e13:	29 c1                	sub    %eax,%ecx
 8049e15:	89 c8                	mov    %ecx,%eax
 8049e17:	89 c2                	mov    %eax,%edx
 8049e19:	8b 45 bc             	mov    -0x44(%ebp),%eax
 8049e1c:	89 10                	mov    %edx,(%eax)
                                } else {
                                        int *ip = va_arg(args, int *);
                                        *ip = (str - buf);
                                }
                                continue;
 8049e1e:	e9 c1 01 00 00       	jmp    8049fe4 <vsnprintf+0x78d>
                                        *ip = (str - buf);
                                } else if (qualifier == 'Z') {
                                        size_t *ip = va_arg(args, size_t *);
                                        *ip = (str - buf);
                                } else {
                                        int *ip = va_arg(args, int *);
 8049e23:	8b 45 14             	mov    0x14(%ebp),%eax
 8049e26:	8d 50 04             	lea    0x4(%eax),%edx
 8049e29:	89 55 14             	mov    %edx,0x14(%ebp)
 8049e2c:	8b 00                	mov    (%eax),%eax
 8049e2e:	89 45 b8             	mov    %eax,-0x48(%ebp)
                                        *ip = (str - buf);
 8049e31:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8049e34:	8b 45 08             	mov    0x8(%ebp),%eax
 8049e37:	29 c2                	sub    %eax,%edx
 8049e39:	8b 45 b8             	mov    -0x48(%ebp),%eax
 8049e3c:	89 10                	mov    %edx,(%eax)
                                }
                                continue;
 8049e3e:	e9 a1 01 00 00       	jmp    8049fe4 <vsnprintf+0x78d>

                        case '%':
                                if (str <= end)
 8049e43:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049e46:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8049e49:	77 06                	ja     8049e51 <vsnprintf+0x5fa>
                                        *str = '%';
 8049e4b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049e4e:	c6 00 25             	movb   $0x25,(%eax)
                                ++str;
 8049e51:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                                continue;
 8049e55:	e9 8a 01 00 00       	jmp    8049fe4 <vsnprintf+0x78d>

                                /* integer number formats - set up the flags and "break" */
                        case 'o':
                                base = 8;
 8049e5a:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
                                break;
 8049e61:	eb 64                	jmp    8049ec7 <vsnprintf+0x670>

                        case 'X':
                                flags |= LARGE;
 8049e63:	83 4d d8 40          	orl    $0x40,-0x28(%ebp)
                        case 'x':
                                base = 16;
 8049e67:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%ebp)
                                break;
 8049e6e:	eb 57                	jmp    8049ec7 <vsnprintf+0x670>

                        case 'd':
                        case 'i':
                                flags |= SIGN;
 8049e70:	83 4d d8 02          	orl    $0x2,-0x28(%ebp)
                        case 'u':
                                break;
 8049e74:	eb 50                	jmp    8049ec6 <vsnprintf+0x66f>
                                /* Added - TODO - alvin */
                        case 'f':
                        case 'F':
                        case 'g':
                        case 'G':
                                return -1;
 8049e76:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8049e7b:	e9 a6 01 00 00       	jmp    804a026 <vsnprintf+0x7cf>


                        default:
                                if (str <= end)
 8049e80:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049e83:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8049e86:	77 06                	ja     8049e8e <vsnprintf+0x637>
                                        *str = '%';
 8049e88:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049e8b:	c6 00 25             	movb   $0x25,(%eax)
                                ++str;
 8049e8e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                                if (*fmt) {
 8049e92:	8b 45 10             	mov    0x10(%ebp),%eax
 8049e95:	0f b6 00             	movzbl (%eax),%eax
 8049e98:	84 c0                	test   %al,%al
 8049e9a:	74 1c                	je     8049eb8 <vsnprintf+0x661>
                                        if (str <= end)
 8049e9c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049e9f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8049ea2:	77 0b                	ja     8049eaf <vsnprintf+0x658>
                                                *str = *fmt;
 8049ea4:	8b 45 10             	mov    0x10(%ebp),%eax
 8049ea7:	0f b6 10             	movzbl (%eax),%edx
 8049eaa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049ead:	88 10                	mov    %dl,(%eax)
                                        ++str;
 8049eaf:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                                } else {
                                        --fmt;
                                }
                                continue;
 8049eb3:	e9 2c 01 00 00       	jmp    8049fe4 <vsnprintf+0x78d>
                                if (*fmt) {
                                        if (str <= end)
                                                *str = *fmt;
                                        ++str;
                                } else {
                                        --fmt;
 8049eb8:	8b 45 10             	mov    0x10(%ebp),%eax
 8049ebb:	83 e8 01             	sub    $0x1,%eax
 8049ebe:	89 45 10             	mov    %eax,0x10(%ebp)
                                }
                                continue;
 8049ec1:	e9 1e 01 00 00       	jmp    8049fe4 <vsnprintf+0x78d>

                        case 'd':
                        case 'i':
                                flags |= SIGN;
                        case 'u':
                                break;
 8049ec6:	90                   	nop
                                } else {
                                        --fmt;
                                }
                                continue;
                }
                if (qualifier == 'L')
 8049ec7:	83 7d cc 4c          	cmpl   $0x4c,-0x34(%ebp)
 8049ecb:	75 19                	jne    8049ee6 <vsnprintf+0x68f>
                        num = va_arg(args, long long);
 8049ecd:	8b 45 14             	mov    0x14(%ebp),%eax
 8049ed0:	8d 50 08             	lea    0x8(%eax),%edx
 8049ed3:	89 55 14             	mov    %edx,0x14(%ebp)
 8049ed6:	8b 50 04             	mov    0x4(%eax),%edx
 8049ed9:	8b 00                	mov    (%eax),%eax
 8049edb:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8049ede:	89 55 f4             	mov    %edx,-0xc(%ebp)
 8049ee1:	e9 bf 00 00 00       	jmp    8049fa5 <vsnprintf+0x74e>
                else if (qualifier == 'l') {
 8049ee6:	83 7d cc 6c          	cmpl   $0x6c,-0x34(%ebp)
 8049eea:	75 36                	jne    8049f22 <vsnprintf+0x6cb>
                        num = va_arg(args, unsigned long);
 8049eec:	8b 45 14             	mov    0x14(%ebp),%eax
 8049eef:	8d 50 04             	lea    0x4(%eax),%edx
 8049ef2:	89 55 14             	mov    %edx,0x14(%ebp)
 8049ef5:	8b 00                	mov    (%eax),%eax
 8049ef7:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8049efa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        if (flags & SIGN)
 8049f01:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049f04:	83 e0 02             	and    $0x2,%eax
 8049f07:	85 c0                	test   %eax,%eax
 8049f09:	0f 84 96 00 00 00    	je     8049fa5 <vsnprintf+0x74e>
                                num = (signed long) num;
 8049f0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049f12:	89 c2                	mov    %eax,%edx
 8049f14:	c1 fa 1f             	sar    $0x1f,%edx
 8049f17:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8049f1a:	89 55 f4             	mov    %edx,-0xc(%ebp)
 8049f1d:	e9 83 00 00 00       	jmp    8049fa5 <vsnprintf+0x74e>
                } else if (qualifier == 'Z') {
 8049f22:	83 7d cc 5a          	cmpl   $0x5a,-0x34(%ebp)
 8049f26:	75 17                	jne    8049f3f <vsnprintf+0x6e8>
                        num = va_arg(args, size_t);
 8049f28:	8b 45 14             	mov    0x14(%ebp),%eax
 8049f2b:	8d 50 04             	lea    0x4(%eax),%edx
 8049f2e:	89 55 14             	mov    %edx,0x14(%ebp)
 8049f31:	8b 00                	mov    (%eax),%eax
 8049f33:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8049f36:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8049f3d:	eb 66                	jmp    8049fa5 <vsnprintf+0x74e>
                } else if (qualifier == 'h') {
 8049f3f:	83 7d cc 68          	cmpl   $0x68,-0x34(%ebp)
 8049f43:	75 33                	jne    8049f78 <vsnprintf+0x721>
                        num = (unsigned short) va_arg(args, int);
 8049f45:	8b 45 14             	mov    0x14(%ebp),%eax
 8049f48:	8d 50 04             	lea    0x4(%eax),%edx
 8049f4b:	89 55 14             	mov    %edx,0x14(%ebp)
 8049f4e:	8b 00                	mov    (%eax),%eax
 8049f50:	0f b7 c0             	movzwl %ax,%eax
 8049f53:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8049f56:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        if (flags & SIGN)
 8049f5d:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049f60:	83 e0 02             	and    $0x2,%eax
 8049f63:	85 c0                	test   %eax,%eax
 8049f65:	74 3e                	je     8049fa5 <vsnprintf+0x74e>
                                num = (signed short) num;
 8049f67:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049f6a:	98                   	cwtl   
 8049f6b:	89 c2                	mov    %eax,%edx
 8049f6d:	c1 fa 1f             	sar    $0x1f,%edx
 8049f70:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8049f73:	89 55 f4             	mov    %edx,-0xc(%ebp)
 8049f76:	eb 2d                	jmp    8049fa5 <vsnprintf+0x74e>
                } else {
                        num = va_arg(args, unsigned int);
 8049f78:	8b 45 14             	mov    0x14(%ebp),%eax
 8049f7b:	8d 50 04             	lea    0x4(%eax),%edx
 8049f7e:	89 55 14             	mov    %edx,0x14(%ebp)
 8049f81:	8b 00                	mov    (%eax),%eax
 8049f83:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8049f86:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        if (flags & SIGN)
 8049f8d:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049f90:	83 e0 02             	and    $0x2,%eax
 8049f93:	85 c0                	test   %eax,%eax
 8049f95:	74 0e                	je     8049fa5 <vsnprintf+0x74e>
                                num = (signed int) num;
 8049f97:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049f9a:	89 c2                	mov    %eax,%edx
 8049f9c:	c1 fa 1f             	sar    $0x1f,%edx
 8049f9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8049fa2:	89 55 f4             	mov    %edx,-0xc(%ebp)
                }

                str = number(str, end, num, base,
 8049fa5:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049fa8:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049fab:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 8049fae:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
 8049fb2:	8b 4d d0             	mov    -0x30(%ebp),%ecx
 8049fb5:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 8049fb9:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 8049fbc:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 8049fc0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
 8049fc3:	89 4c 24 10          	mov    %ecx,0x10(%esp)
 8049fc7:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049fcb:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8049fcf:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049fd2:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049fd6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049fd9:	89 04 24             	mov    %eax,(%esp)
 8049fdc:	e8 b3 f4 ff ff       	call   8049494 <number>
 8049fe1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (end < buf - 1) {
                end = ((void *) - 1);
                size = end - buf + 1;
        }

        for (; *fmt ; ++fmt) {
 8049fe4:	8b 45 10             	mov    0x10(%ebp),%eax
 8049fe7:	83 c0 01             	add    $0x1,%eax
 8049fea:	89 45 10             	mov    %eax,0x10(%ebp)
 8049fed:	eb 01                	jmp    8049ff0 <vsnprintf+0x799>
 8049fef:	90                   	nop
 8049ff0:	8b 45 10             	mov    0x10(%ebp),%eax
 8049ff3:	0f b6 00             	movzbl (%eax),%eax
 8049ff6:	84 c0                	test   %al,%al
 8049ff8:	0f 85 aa f8 ff ff    	jne    80498a8 <vsnprintf+0x51>
                }

                str = number(str, end, num, base,
                             field_width, precision, flags);
        }
        if (str <= end)
 8049ffe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a001:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804a004:	77 08                	ja     804a00e <vsnprintf+0x7b7>
                *str = '\0';
 804a006:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a009:	c6 00 00             	movb   $0x0,(%eax)
 804a00c:	eb 0c                	jmp    804a01a <vsnprintf+0x7c3>
        else if (size > 0)
 804a00e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804a012:	74 06                	je     804a01a <vsnprintf+0x7c3>
                /* don't write out a null byte if the buf size is zero */
                *end = '\0';
 804a014:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a017:	c6 00 00             	movb   $0x0,(%eax)
        /* the trailing null byte doesn't count towards the total
         * ++str;
         */
        return str - buf;
 804a01a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804a01d:	8b 45 08             	mov    0x8(%ebp),%eax
 804a020:	89 d1                	mov    %edx,%ecx
 804a022:	29 c1                	sub    %eax,%ecx
 804a024:	89 c8                	mov    %ecx,%eax
}
 804a026:	83 c4 64             	add    $0x64,%esp
 804a029:	5b                   	pop    %ebx
 804a02a:	5d                   	pop    %ebp
 804a02b:	c3                   	ret    

0804a02c <wrterror>:
#define abort() exit(1)
#endif

static void
wrterror(char *p)
{
 804a02c:	55                   	push   %ebp
 804a02d:	89 e5                	mov    %esp,%ebp
 804a02f:	53                   	push   %ebx
 804a030:	83 ec 24             	sub    $0x24,%esp
 804a033:	e8 2d e4 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804a038:	81 c3 74 61 00 00    	add    $0x6174,%ebx
        char *q = " error: ";
 804a03e:	8d 83 e1 d5 ff ff    	lea    -0x2a1f(%ebx),%eax
 804a044:	89 45 f4             	mov    %eax,-0xc(%ebp)
        _write(STDERR_FILENO, __progname, strlen(__progname));
 804a047:	8b 83 38 01 00 00    	mov    0x138(%ebx),%eax
 804a04d:	89 04 24             	mov    %eax,(%esp)
 804a050:	e8 1c 2c 00 00       	call   804cc71 <strlen>
 804a055:	8b 93 38 01 00 00    	mov    0x138(%ebx),%edx
 804a05b:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a05f:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a063:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804a06a:	e8 0f eb ff ff       	call   8048b7e <write>
        _write(STDERR_FILENO, malloc_func, strlen(malloc_func));
 804a06f:	8b 83 d0 04 00 00    	mov    0x4d0(%ebx),%eax
 804a075:	89 04 24             	mov    %eax,(%esp)
 804a078:	e8 f4 2b 00 00       	call   804cc71 <strlen>
 804a07d:	8b 93 d0 04 00 00    	mov    0x4d0(%ebx),%edx
 804a083:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a087:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a08b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804a092:	e8 e7 ea ff ff       	call   8048b7e <write>
        _write(STDERR_FILENO, q, strlen(q));
 804a097:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a09a:	89 04 24             	mov    %eax,(%esp)
 804a09d:	e8 cf 2b 00 00       	call   804cc71 <strlen>
 804a0a2:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a0a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a0a9:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a0ad:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804a0b4:	e8 c5 ea ff ff       	call   8048b7e <write>
        _write(STDERR_FILENO, p, strlen(p));
 804a0b9:	8b 45 08             	mov    0x8(%ebp),%eax
 804a0bc:	89 04 24             	mov    %eax,(%esp)
 804a0bf:	e8 ad 2b 00 00       	call   804cc71 <strlen>
 804a0c4:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a0c8:	8b 45 08             	mov    0x8(%ebp),%eax
 804a0cb:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a0cf:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804a0d6:	e8 a3 ea ff ff       	call   8048b7e <write>
        suicide = 1;
 804a0db:	c7 83 ac 04 00 00 01 	movl   $0x1,0x4ac(%ebx)
 804a0e2:	00 00 00 
        abort();
 804a0e5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804a0ec:	e8 e7 e5 ff ff       	call   80486d8 <exit>
}
 804a0f1:	83 c4 24             	add    $0x24,%esp
 804a0f4:	5b                   	pop    %ebx
 804a0f5:	5d                   	pop    %ebp
 804a0f6:	c3                   	ret    

0804a0f7 <wrtwarning>:

static void
wrtwarning(char *p)
{
 804a0f7:	55                   	push   %ebp
 804a0f8:	89 e5                	mov    %esp,%ebp
 804a0fa:	53                   	push   %ebx
 804a0fb:	83 ec 24             	sub    $0x24,%esp
 804a0fe:	e8 62 e3 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804a103:	81 c3 a9 60 00 00    	add    $0x60a9,%ebx
        char *q = " warning: ";
 804a109:	8d 83 ea d5 ff ff    	lea    -0x2a16(%ebx),%eax
 804a10f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (malloc_abort)
 804a112:	8b 83 a8 04 00 00    	mov    0x4a8(%ebx),%eax
 804a118:	85 c0                	test   %eax,%eax
 804a11a:	74 0b                	je     804a127 <wrtwarning+0x30>
                wrterror(p);
 804a11c:	8b 45 08             	mov    0x8(%ebp),%eax
 804a11f:	89 04 24             	mov    %eax,(%esp)
 804a122:	e8 05 ff ff ff       	call   804a02c <wrterror>
        _write(STDERR_FILENO, __progname, strlen(__progname));
 804a127:	8b 83 38 01 00 00    	mov    0x138(%ebx),%eax
 804a12d:	89 04 24             	mov    %eax,(%esp)
 804a130:	e8 3c 2b 00 00       	call   804cc71 <strlen>
 804a135:	8b 93 38 01 00 00    	mov    0x138(%ebx),%edx
 804a13b:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a13f:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a143:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804a14a:	e8 2f ea ff ff       	call   8048b7e <write>
        _write(STDERR_FILENO, malloc_func, strlen(malloc_func));
 804a14f:	8b 83 d0 04 00 00    	mov    0x4d0(%ebx),%eax
 804a155:	89 04 24             	mov    %eax,(%esp)
 804a158:	e8 14 2b 00 00       	call   804cc71 <strlen>
 804a15d:	8b 93 d0 04 00 00    	mov    0x4d0(%ebx),%edx
 804a163:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a167:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a16b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804a172:	e8 07 ea ff ff       	call   8048b7e <write>
        _write(STDERR_FILENO, q, strlen(q));
 804a177:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a17a:	89 04 24             	mov    %eax,(%esp)
 804a17d:	e8 ef 2a 00 00       	call   804cc71 <strlen>
 804a182:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a186:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a189:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a18d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804a194:	e8 e5 e9 ff ff       	call   8048b7e <write>
        _write(STDERR_FILENO, p, strlen(p));
 804a199:	8b 45 08             	mov    0x8(%ebp),%eax
 804a19c:	89 04 24             	mov    %eax,(%esp)
 804a19f:	e8 cd 2a 00 00       	call   804cc71 <strlen>
 804a1a4:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a1a8:	8b 45 08             	mov    0x8(%ebp),%eax
 804a1ab:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a1af:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804a1b6:	e8 c3 e9 ff ff       	call   8048b7e <write>
}
 804a1bb:	83 c4 24             	add    $0x24,%esp
 804a1be:	5b                   	pop    %ebx
 804a1bf:	5d                   	pop    %ebp
 804a1c0:	c3                   	ret    

0804a1c1 <map_pages>:
/*
 * Allocate a number of pages from the OS
 */
static void *
map_pages(int pages)
{
 804a1c1:	55                   	push   %ebp
 804a1c2:	89 e5                	mov    %esp,%ebp
 804a1c4:	53                   	push   %ebx
 804a1c5:	83 ec 24             	sub    $0x24,%esp
 804a1c8:	e8 98 e2 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804a1cd:	81 c3 df 5f 00 00    	add    $0x5fdf,%ebx
        caddr_t result, tail;

        result = (caddr_t)pageround((u_long)sbrk(0));
 804a1d3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a1da:	e8 d1 e2 ff ff       	call   80484b0 <sbrk>
 804a1df:	05 ff 0f 00 00       	add    $0xfff,%eax
 804a1e4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 804a1e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
        tail = result + (pages << malloc_pageshift);
 804a1ec:	8b 45 08             	mov    0x8(%ebp),%eax
 804a1ef:	c1 e0 0c             	shl    $0xc,%eax
 804a1f2:	03 45 f4             	add    -0xc(%ebp),%eax
 804a1f5:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (brk(tail)) {
 804a1f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a1fb:	89 04 24             	mov    %eax,(%esp)
 804a1fe:	e8 7d e3 ff ff       	call   8048580 <brk>
 804a203:	85 c0                	test   %eax,%eax
 804a205:	74 07                	je     804a20e <map_pages+0x4d>
#ifdef EXTRA_SANITY
                wrterror("(ES): map_pages fails\n");
#endif /* EXTRA_SANITY */
                return 0;
 804a207:	b8 00 00 00 00       	mov    $0x0,%eax
 804a20c:	eb 55                	jmp    804a263 <map_pages+0xa2>
        }

        last_index = ptr2index(tail) - 1;
 804a20e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a211:	89 c2                	mov    %eax,%edx
 804a213:	c1 ea 0c             	shr    $0xc,%edx
 804a216:	8b 83 84 04 00 00    	mov    0x484(%ebx),%eax
 804a21c:	89 d1                	mov    %edx,%ecx
 804a21e:	29 c1                	sub    %eax,%ecx
 804a220:	89 c8                	mov    %ecx,%eax
 804a222:	83 e8 01             	sub    $0x1,%eax
 804a225:	89 83 88 04 00 00    	mov    %eax,0x488(%ebx)
        malloc_brk = tail;
 804a22b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a22e:	89 83 c8 04 00 00    	mov    %eax,0x4c8(%ebx)

        if ((last_index + 1) >= malloc_ninfo && !extend_pgdir(last_index))
 804a234:	8b 83 88 04 00 00    	mov    0x488(%ebx),%eax
 804a23a:	8d 50 01             	lea    0x1(%eax),%edx
 804a23d:	8b 83 90 04 00 00    	mov    0x490(%ebx),%eax
 804a243:	39 c2                	cmp    %eax,%edx
 804a245:	72 19                	jb     804a260 <map_pages+0x9f>
 804a247:	8b 83 88 04 00 00    	mov    0x488(%ebx),%eax
 804a24d:	89 04 24             	mov    %eax,(%esp)
 804a250:	e8 14 00 00 00       	call   804a269 <extend_pgdir>
 804a255:	85 c0                	test   %eax,%eax
 804a257:	75 07                	jne    804a260 <map_pages+0x9f>
                return 0;;
 804a259:	b8 00 00 00 00       	mov    $0x0,%eax
 804a25e:	eb 03                	jmp    804a263 <map_pages+0xa2>

        return result;
 804a260:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804a263:	83 c4 24             	add    $0x24,%esp
 804a266:	5b                   	pop    %ebx
 804a267:	5d                   	pop    %ebp
 804a268:	c3                   	ret    

0804a269 <extend_pgdir>:
/*
 * Extend page directory
 */
static int
extend_pgdir(u_long index)
{
 804a269:	55                   	push   %ebp
 804a26a:	89 e5                	mov    %esp,%ebp
 804a26c:	53                   	push   %ebx
 804a26d:	83 ec 34             	sub    $0x34,%esp
 804a270:	e8 f0 e1 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804a275:	81 c3 37 5f 00 00    	add    $0x5f37,%ebx
        struct  pginfo **new, **old;
        int i, oldlen;

        /* Make it this many pages */
        i = index * sizeof * page_dir;
 804a27b:	8b 45 08             	mov    0x8(%ebp),%eax
 804a27e:	c1 e0 02             	shl    $0x2,%eax
 804a281:	89 45 f4             	mov    %eax,-0xc(%ebp)
        i /= malloc_pagesize;
 804a284:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a287:	c1 e8 0c             	shr    $0xc,%eax
 804a28a:	89 45 f4             	mov    %eax,-0xc(%ebp)
        i += 2;
 804a28d:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)

        /* remember the old mapping size */
        oldlen = malloc_ninfo * sizeof * page_dir;
 804a291:	8b 83 90 04 00 00    	mov    0x490(%ebx),%eax
 804a297:	c1 e0 02             	shl    $0x2,%eax
 804a29a:	89 45 f0             	mov    %eax,-0x10(%ebp)
         * address, the old pages will be "magically" remapped..  But this means
         * keeping open a "secret" file descriptor.....
         */

        /* Get new pages */
        new = (struct pginfo **) MMAP(i * malloc_pagesize);
 804a29d:	8b 83 78 04 00 00    	mov    0x478(%ebx),%eax
 804a2a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804a2a6:	c1 e2 0c             	shl    $0xc,%edx
 804a2a9:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804a2b0:	00 
 804a2b1:	89 44 24 10          	mov    %eax,0x10(%esp)
 804a2b5:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
 804a2bc:	00 
 804a2bd:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 804a2c4:	00 
 804a2c5:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a2c9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a2d0:	e8 4f e6 ff ff       	call   8048924 <mmap>
 804a2d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (new == (struct pginfo **) - 1)
 804a2d8:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
 804a2dc:	75 07                	jne    804a2e5 <extend_pgdir+0x7c>
                return 0;
 804a2de:	b8 00 00 00 00       	mov    $0x0,%eax
 804a2e3:	eb 5e                	jmp    804a343 <extend_pgdir+0xda>

        /* Copy the old stuff */
        memcpy(new, page_dir,
 804a2e5:	8b 83 90 04 00 00    	mov    0x490(%ebx),%eax
 804a2eb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804a2f2:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804a2f8:	89 54 24 08          	mov    %edx,0x8(%esp)
 804a2fc:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a300:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a303:	89 04 24             	mov    %eax,(%esp)
 804a306:	e8 6b 27 00 00       	call   804ca76 <memcpy>
               malloc_ninfo * sizeof * page_dir);

        /* register the new size */
        malloc_ninfo = i * malloc_pagesize / sizeof * page_dir;
 804a30b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a30e:	c1 e0 0c             	shl    $0xc,%eax
 804a311:	c1 e8 02             	shr    $0x2,%eax
 804a314:	89 83 90 04 00 00    	mov    %eax,0x490(%ebx)

        /* swap the pointers */
        old = page_dir;
 804a31a:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804a320:	89 45 e8             	mov    %eax,-0x18(%ebp)
        page_dir = new;
 804a323:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a326:	89 83 8c 04 00 00    	mov    %eax,0x48c(%ebx)

        /* Now free the old stuff */
        munmap((char *)old, oldlen);
 804a32c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a32f:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a333:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a336:	89 04 24             	mov    %eax,(%esp)
 804a339:	e8 5b e6 ff ff       	call   8048999 <munmap>
        return 1;
 804a33e:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804a343:	83 c4 34             	add    $0x34,%esp
 804a346:	5b                   	pop    %ebx
 804a347:	5d                   	pop    %ebp
 804a348:	c3                   	ret    

0804a349 <malloc_init>:
/*
 * Initialize the world
 */
static void
malloc_init()
{
 804a349:	55                   	push   %ebp
 804a34a:	89 e5                	mov    %esp,%ebp
 804a34c:	53                   	push   %ebx
 804a34d:	83 ec 34             	sub    $0x34,%esp
 804a350:	e8 10 e1 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804a355:	81 c3 57 5e 00 00    	add    $0x5e57,%ebx
        char *p;
        int i, j;

        INIT_MMAP();
 804a35b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804a362:	00 
 804a363:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
 804a36a:	00 
 804a36b:	8d 83 f5 d5 ff ff    	lea    -0x2a0b(%ebx),%eax
 804a371:	89 04 24             	mov    %eax,(%esp)
 804a374:	e8 cc e6 ff ff       	call   8048a45 <open>
 804a379:	89 83 78 04 00 00    	mov    %eax,0x478(%ebx)
 804a37f:	8b 83 78 04 00 00    	mov    0x478(%ebx),%eax
 804a385:	83 f8 ff             	cmp    $0xffffffff,%eax
 804a388:	75 0e                	jne    804a398 <malloc_init+0x4f>
 804a38a:	8d 83 ff d5 ff ff    	lea    -0x2a01(%ebx),%eax
 804a390:	89 04 24             	mov    %eax,(%esp)
 804a393:	e8 94 fc ff ff       	call   804a02c <wrterror>

#ifdef EXTRA_SANITY
        malloc_junk = 1;
#endif /* EXTRA_SANITY */

        for (i = 0; i < 3; i++) {
 804a398:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 804a39f:	e9 7f 02 00 00       	jmp    804a623 <malloc_init+0x2da>
                if (i == 0) {
 804a3a4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804a3a8:	75 0c                	jne    804a3b6 <malloc_init+0x6d>
                        if (j <= 0)
                                continue;
                        b[j] = '\0';
                        p = b;
#else
                        p = NULL;
 804a3aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        p = NULL;
#endif
                } else {
                        p = malloc_options;
                }
                for (; p && *p; p++) {
 804a3b1:	e9 55 02 00 00       	jmp    804a60b <malloc_init+0x2c2>
                        b[j] = '\0';
                        p = b;
#else
                        p = NULL;
#endif
                } else if (i == 1) {
 804a3b6:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
 804a3ba:	75 0c                	jne    804a3c8 <malloc_init+0x7f>
#ifdef HAS_GETENV
                        p = getenv("MALLOC_OPTIONS");
#else
                        p = NULL;
 804a3bc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
#endif
                } else {
                        p = malloc_options;
                }
                for (; p && *p; p++) {
 804a3c3:	e9 43 02 00 00       	jmp    804a60b <malloc_init+0x2c2>
                        p = getenv("MALLOC_OPTIONS");
#else
                        p = NULL;
#endif
                } else {
                        p = malloc_options;
 804a3c8:	8b 83 f8 ff ff ff    	mov    -0x8(%ebx),%eax
 804a3ce:	8b 00                	mov    (%eax),%eax
 804a3d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
                }
                for (; p && *p; p++) {
 804a3d3:	e9 33 02 00 00       	jmp    804a60b <malloc_init+0x2c2>
                        switch (*p) {
 804a3d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a3db:	0f b6 00             	movzbl (%eax),%eax
 804a3de:	0f be c0             	movsbl %al,%eax
 804a3e1:	83 e8 3c             	sub    $0x3c,%eax
 804a3e4:	83 f8 3e             	cmp    $0x3e,%eax
 804a3e7:	0f 87 ef 01 00 00    	ja     804a5dc <malloc_init+0x293>
 804a3ed:	c1 e0 02             	shl    $0x2,%eax
 804a3f0:	8b 84 18 54 a2 ff ff 	mov    -0x5dac(%eax,%ebx,1),%eax
 804a3f7:	89 da                	mov    %ebx,%edx
 804a3f9:	29 c2                	sub    %eax,%edx
 804a3fb:	89 d0                	mov    %edx,%eax
 804a3fd:	ff e0                	jmp    *%eax
 804a3ff:	90                   	nop
 804a400:	9d                   	popf   
 804a401:	5c                   	pop    %esp
 804a402:	00 00                	add    %al,(%eax)
 804a404:	d0 5b 00             	rcrb   0x0(%ebx)
 804a407:	00 b0 5c 00 00 d0    	add    %dh,-0x2fffffa4(%eax)
 804a40d:	5b                   	pop    %ebx
 804a40e:	00 00                	add    %al,(%eax)
 804a410:	d0 5b 00             	rcrb   0x0(%ebx)
 804a413:	00 7b 5c             	add    %bh,0x5c(%ebx)
 804a416:	00 00                	add    %al,(%eax)
 804a418:	d0 5b 00             	rcrb   0x0(%ebx)
 804a41b:	00 d0                	add    %dl,%al
 804a41d:	5b                   	pop    %ebx
 804a41e:	00 00                	add    %al,(%eax)
 804a420:	d0 5b 00             	rcrb   0x0(%ebx)
 804a423:	00 d0                	add    %dl,%al
 804a425:	5b                   	pop    %ebx
 804a426:	00 00                	add    %al,(%eax)
 804a428:	d0 5b 00             	rcrb   0x0(%ebx)
 804a42b:	00 d0                	add    %dl,%al
 804a42d:	5b                   	pop    %ebx
 804a42e:	00 00                	add    %al,(%eax)
 804a430:	5d                   	pop    %ebp
 804a431:	5c                   	pop    %esp
 804a432:	00 00                	add    %al,(%eax)
 804a434:	d0 5b 00             	rcrb   0x0(%ebx)
 804a437:	00 24 5c             	add    %ah,(%esp,%ebx,2)
 804a43a:	00 00                	add    %al,(%eax)
 804a43c:	d0 5b 00             	rcrb   0x0(%ebx)
 804a43f:	00 d0                	add    %dl,%al
 804a441:	5b                   	pop    %ebx
 804a442:	00 00                	add    %al,(%eax)
 804a444:	d0 5b 00             	rcrb   0x0(%ebx)
 804a447:	00 d0                	add    %dl,%al
 804a449:	5b                   	pop    %ebx
 804a44a:	00 00                	add    %al,(%eax)
 804a44c:	d0 5b 00             	rcrb   0x0(%ebx)
 804a44f:	00 d0                	add    %dl,%al
 804a451:	5b                   	pop    %ebx
 804a452:	00 00                	add    %al,(%eax)
 804a454:	d0 5b 00             	rcrb   0x0(%ebx)
 804a457:	00 3f                	add    %bh,(%edi)
 804a459:	5c                   	pop    %esp
 804a45a:	00 00                	add    %al,(%eax)
 804a45c:	d0 5b 00             	rcrb   0x0(%ebx)
 804a45f:	00 d0                	add    %dl,%al
 804a461:	5b                   	pop    %ebx
 804a462:	00 00                	add    %al,(%eax)
 804a464:	d0 5b 00             	rcrb   0x0(%ebx)
 804a467:	00 0c 5c             	add    %cl,(%esp,%ebx,2)
 804a46a:	00 00                	add    %al,(%eax)
 804a46c:	d0 5b 00             	rcrb   0x0(%ebx)
 804a46f:	00 f4                	add    %dh,%ah
 804a471:	5b                   	pop    %ebx
 804a472:	00 00                	add    %al,(%eax)
 804a474:	d0 5b 00             	rcrb   0x0(%ebx)
 804a477:	00 dc                	add    %bl,%ah
 804a479:	5b                   	pop    %ebx
 804a47a:	00 00                	add    %al,(%eax)
 804a47c:	d0 5b 00             	rcrb   0x0(%ebx)
 804a47f:	00 d0                	add    %dl,%al
 804a481:	5b                   	pop    %ebx
 804a482:	00 00                	add    %al,(%eax)
 804a484:	d0 5b 00             	rcrb   0x0(%ebx)
 804a487:	00 d0                	add    %dl,%al
 804a489:	5b                   	pop    %ebx
 804a48a:	00 00                	add    %al,(%eax)
 804a48c:	d0 5b 00             	rcrb   0x0(%ebx)
 804a48f:	00 d0                	add    %dl,%al
 804a491:	5b                   	pop    %ebx
 804a492:	00 00                	add    %al,(%eax)
 804a494:	8a 5c 00 00          	mov    0x0(%eax,%eax,1),%bl
 804a498:	d0 5b 00             	rcrb   0x0(%ebx)
 804a49b:	00 d0                	add    %dl,%al
 804a49d:	5b                   	pop    %ebx
 804a49e:	00 00                	add    %al,(%eax)
 804a4a0:	d0 5b 00             	rcrb   0x0(%ebx)
 804a4a3:	00 d0                	add    %dl,%al
 804a4a5:	5b                   	pop    %ebx
 804a4a6:	00 00                	add    %al,(%eax)
 804a4a8:	d0 5b 00             	rcrb   0x0(%ebx)
 804a4ab:	00 d0                	add    %dl,%al
 804a4ad:	5b                   	pop    %ebx
 804a4ae:	00 00                	add    %al,(%eax)
 804a4b0:	6c                   	insb   (%dx),%es:(%edi)
 804a4b1:	5c                   	pop    %esp
 804a4b2:	00 00                	add    %al,(%eax)
 804a4b4:	d0 5b 00             	rcrb   0x0(%ebx)
 804a4b7:	00 30                	add    %dh,(%eax)
 804a4b9:	5c                   	pop    %esp
 804a4ba:	00 00                	add    %al,(%eax)
 804a4bc:	d0 5b 00             	rcrb   0x0(%ebx)
 804a4bf:	00 d0                	add    %dl,%al
 804a4c1:	5b                   	pop    %ebx
 804a4c2:	00 00                	add    %al,(%eax)
 804a4c4:	d0 5b 00             	rcrb   0x0(%ebx)
 804a4c7:	00 d0                	add    %dl,%al
 804a4c9:	5b                   	pop    %ebx
 804a4ca:	00 00                	add    %al,(%eax)
 804a4cc:	d0 5b 00             	rcrb   0x0(%ebx)
 804a4cf:	00 d0                	add    %dl,%al
 804a4d1:	5b                   	pop    %ebx
 804a4d2:	00 00                	add    %al,(%eax)
 804a4d4:	d0 5b 00             	rcrb   0x0(%ebx)
 804a4d7:	00 4e 5c             	add    %cl,0x5c(%esi)
 804a4da:	00 00                	add    %al,(%eax)
 804a4dc:	d0 5b 00             	rcrb   0x0(%ebx)
 804a4df:	00 d0                	add    %dl,%al
 804a4e1:	5b                   	pop    %ebx
 804a4e2:	00 00                	add    %al,(%eax)
 804a4e4:	d0 5b 00             	rcrb   0x0(%ebx)
 804a4e7:	00 18                	add    %bl,(%eax)
 804a4e9:	5c                   	pop    %esp
 804a4ea:	00 00                	add    %al,(%eax)
 804a4ec:	d0 5b 00             	rcrb   0x0(%ebx)
 804a4ef:	00 00                	add    %al,(%eax)
 804a4f1:	5c                   	pop    %esp
 804a4f2:	00 00                	add    %al,(%eax)
 804a4f4:	d0 5b 00             	rcrb   0x0(%ebx)
 804a4f7:	00 e8                	add    %ch,%al
 804a4f9:	5b                   	pop    %ebx
 804a4fa:	00 00                	add    %al,(%eax)
                                case '>': malloc_cache   <<= 1; break;
 804a4fc:	8b 83 34 01 00 00    	mov    0x134(%ebx),%eax
 804a502:	01 c0                	add    %eax,%eax
 804a504:	89 83 34 01 00 00    	mov    %eax,0x134(%ebx)
 804a50a:	e9 f8 00 00 00       	jmp    804a607 <malloc_init+0x2be>
                                case '<': malloc_cache   >>= 1; break;
 804a50f:	8b 83 34 01 00 00    	mov    0x134(%ebx),%eax
 804a515:	d1 e8                	shr    %eax
 804a517:	89 83 34 01 00 00    	mov    %eax,0x134(%ebx)
 804a51d:	e9 e5 00 00 00       	jmp    804a607 <malloc_init+0x2be>
                                case 'a': malloc_abort   = 0; break;
 804a522:	c7 83 a8 04 00 00 00 	movl   $0x0,0x4a8(%ebx)
 804a529:	00 00 00 
 804a52c:	e9 d6 00 00 00       	jmp    804a607 <malloc_init+0x2be>
                                case 'A': malloc_abort   = 1; break;
 804a531:	c7 83 a8 04 00 00 01 	movl   $0x1,0x4a8(%ebx)
 804a538:	00 00 00 
 804a53b:	e9 c7 00 00 00       	jmp    804a607 <malloc_init+0x2be>
                                case 'h': malloc_hint    = 0; break;
 804a540:	c7 83 b4 04 00 00 00 	movl   $0x0,0x4b4(%ebx)
 804a547:	00 00 00 
 804a54a:	e9 b8 00 00 00       	jmp    804a607 <malloc_init+0x2be>
                                case 'H': malloc_hint    = 1; break;
 804a54f:	c7 83 b4 04 00 00 01 	movl   $0x1,0x4b4(%ebx)
 804a556:	00 00 00 
 804a559:	e9 a9 00 00 00       	jmp    804a607 <malloc_init+0x2be>
                                case 'r': malloc_realloc = 0; break;
 804a55e:	c7 83 b0 04 00 00 00 	movl   $0x0,0x4b0(%ebx)
 804a565:	00 00 00 
 804a568:	e9 9a 00 00 00       	jmp    804a607 <malloc_init+0x2be>
                                case 'R': malloc_realloc = 1; break;
 804a56d:	c7 83 b0 04 00 00 01 	movl   $0x1,0x4b0(%ebx)
 804a574:	00 00 00 
 804a577:	e9 8b 00 00 00       	jmp    804a607 <malloc_init+0x2be>
                                case 'j': malloc_junk    = 0; break;
 804a57c:	c7 83 c4 04 00 00 00 	movl   $0x0,0x4c4(%ebx)
 804a583:	00 00 00 
 804a586:	eb 7f                	jmp    804a607 <malloc_init+0x2be>
                                case 'J': malloc_junk    = 1; break;
 804a588:	c7 83 c4 04 00 00 01 	movl   $0x1,0x4c4(%ebx)
 804a58f:	00 00 00 
 804a592:	eb 73                	jmp    804a607 <malloc_init+0x2be>
#ifdef HAS_UTRACE
                                case 'u': malloc_utrace  = 0; break;
                                case 'U': malloc_utrace  = 1; break;
#endif
                                case 'v': malloc_sysv    = 0; break;
 804a594:	c7 83 bc 04 00 00 00 	movl   $0x0,0x4bc(%ebx)
 804a59b:	00 00 00 
 804a59e:	eb 67                	jmp    804a607 <malloc_init+0x2be>
                                case 'V': malloc_sysv    = 1; break;
 804a5a0:	c7 83 bc 04 00 00 01 	movl   $0x1,0x4bc(%ebx)
 804a5a7:	00 00 00 
 804a5aa:	eb 5b                	jmp    804a607 <malloc_init+0x2be>
                                case 'x': malloc_xmalloc = 0; break;
 804a5ac:	c7 83 b8 04 00 00 00 	movl   $0x0,0x4b8(%ebx)
 804a5b3:	00 00 00 
 804a5b6:	eb 4f                	jmp    804a607 <malloc_init+0x2be>
                                case 'X': malloc_xmalloc = 1; break;
 804a5b8:	c7 83 b8 04 00 00 01 	movl   $0x1,0x4b8(%ebx)
 804a5bf:	00 00 00 
 804a5c2:	eb 43                	jmp    804a607 <malloc_init+0x2be>
                                case 'z': malloc_zero    = 0; break;
 804a5c4:	c7 83 c0 04 00 00 00 	movl   $0x0,0x4c0(%ebx)
 804a5cb:	00 00 00 
 804a5ce:	eb 37                	jmp    804a607 <malloc_init+0x2be>
                                case 'Z': malloc_zero    = 1; break;
 804a5d0:	c7 83 c0 04 00 00 01 	movl   $0x1,0x4c0(%ebx)
 804a5d7:	00 00 00 
 804a5da:	eb 2b                	jmp    804a607 <malloc_init+0x2be>
                                default:
                                        j = malloc_abort;
 804a5dc:	8b 83 a8 04 00 00    	mov    0x4a8(%ebx),%eax
 804a5e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
                                        malloc_abort = 0;
 804a5e5:	c7 83 a8 04 00 00 00 	movl   $0x0,0x4a8(%ebx)
 804a5ec:	00 00 00 
                                        wrtwarning("unknown char in MALLOC_OPTIONS\n");
 804a5ef:	8d 83 14 d6 ff ff    	lea    -0x29ec(%ebx),%eax
 804a5f5:	89 04 24             	mov    %eax,(%esp)
 804a5f8:	e8 fa fa ff ff       	call   804a0f7 <wrtwarning>
                                        malloc_abort = j;
 804a5fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a600:	89 83 a8 04 00 00    	mov    %eax,0x4a8(%ebx)
                                        break;
 804a606:	90                   	nop
                        p = NULL;
#endif
                } else {
                        p = malloc_options;
                }
                for (; p && *p; p++) {
 804a607:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 804a60b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804a60f:	74 0e                	je     804a61f <malloc_init+0x2d6>
 804a611:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a614:	0f b6 00             	movzbl (%eax),%eax
 804a617:	84 c0                	test   %al,%al
 804a619:	0f 85 b9 fd ff ff    	jne    804a3d8 <malloc_init+0x8f>

#ifdef EXTRA_SANITY
        malloc_junk = 1;
#endif /* EXTRA_SANITY */

        for (i = 0; i < 3; i++) {
 804a61f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
 804a623:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
 804a627:	0f 8e 77 fd ff ff    	jle    804a3a4 <malloc_init+0x5b>

        /*
         * We want junk in the entire allocation, and zero only in the part
         * the user asked for.
         */
        if (malloc_zero)
 804a62d:	8b 83 c0 04 00 00    	mov    0x4c0(%ebx),%eax
 804a633:	85 c0                	test   %eax,%eax
 804a635:	74 0a                	je     804a641 <malloc_init+0x2f8>
                malloc_junk = 1;
 804a637:	c7 83 c4 04 00 00 01 	movl   $0x1,0x4c4(%ebx)
 804a63e:	00 00 00 

        /*
         * If we run with junk (or implicitly from above: zero), we want to
         * force realloc() to get new storage, so we can DTRT with it.
         */
        if (malloc_junk)
 804a641:	8b 83 c4 04 00 00    	mov    0x4c4(%ebx),%eax
 804a647:	85 c0                	test   %eax,%eax
 804a649:	74 0a                	je     804a655 <malloc_init+0x30c>
                malloc_realloc = 1;
 804a64b:	c7 83 b0 04 00 00 01 	movl   $0x1,0x4b0(%ebx)
 804a652:	00 00 00 

        /* Allocate one page for the page directory */
        page_dir = (struct pginfo **) MMAP(malloc_pagesize);
 804a655:	8b 83 78 04 00 00    	mov    0x478(%ebx),%eax
 804a65b:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804a662:	00 
 804a663:	89 44 24 10          	mov    %eax,0x10(%esp)
 804a667:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
 804a66e:	00 
 804a66f:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 804a676:	00 
 804a677:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 804a67e:	00 
 804a67f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a686:	e8 99 e2 ff ff       	call   8048924 <mmap>
 804a68b:	89 83 8c 04 00 00    	mov    %eax,0x48c(%ebx)

        if (page_dir == (struct pginfo **) - 1)
 804a691:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804a697:	83 f8 ff             	cmp    $0xffffffff,%eax
 804a69a:	75 0e                	jne    804a6aa <malloc_init+0x361>
                wrterror("mmap(2) failed, check limits\n");
 804a69c:	8d 83 34 d6 ff ff    	lea    -0x29cc(%ebx),%eax
 804a6a2:	89 04 24             	mov    %eax,(%esp)
 804a6a5:	e8 82 f9 ff ff       	call   804a02c <wrterror>

        /*
         * We need a maximum of malloc_pageshift buckets, steal these from the
         * front of the page_directory;
         */
        malloc_origo = ((u_long)pageround((u_long)sbrk(0))) >> malloc_pageshift;
 804a6aa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a6b1:	e8 fa dd ff ff       	call   80484b0 <sbrk>
 804a6b6:	05 ff 0f 00 00       	add    $0xfff,%eax
 804a6bb:	c1 e8 0c             	shr    $0xc,%eax
 804a6be:	89 83 84 04 00 00    	mov    %eax,0x484(%ebx)
        malloc_origo -= malloc_pageshift;
 804a6c4:	8b 83 84 04 00 00    	mov    0x484(%ebx),%eax
 804a6ca:	83 e8 0c             	sub    $0xc,%eax
 804a6cd:	89 83 84 04 00 00    	mov    %eax,0x484(%ebx)

        malloc_ninfo = malloc_pagesize / sizeof * page_dir;
 804a6d3:	c7 83 90 04 00 00 00 	movl   $0x400,0x490(%ebx)
 804a6da:	04 00 00 

        /* Recalculate the cache size in bytes, and make sure it's nonzero */

        if (!malloc_cache)
 804a6dd:	8b 83 34 01 00 00    	mov    0x134(%ebx),%eax
 804a6e3:	85 c0                	test   %eax,%eax
 804a6e5:	75 0f                	jne    804a6f6 <malloc_init+0x3ad>
                malloc_cache++;
 804a6e7:	8b 83 34 01 00 00    	mov    0x134(%ebx),%eax
 804a6ed:	83 c0 01             	add    $0x1,%eax
 804a6f0:	89 83 34 01 00 00    	mov    %eax,0x134(%ebx)

        malloc_cache <<= malloc_pageshift;
 804a6f6:	8b 83 34 01 00 00    	mov    0x134(%ebx),%eax
 804a6fc:	c1 e0 0c             	shl    $0xc,%eax
 804a6ff:	89 83 34 01 00 00    	mov    %eax,0x134(%ebx)

        /*
         * This is a nice hack from Kaleb Keithly (kaleb@x.org).
         * We can sbrk(2) further back when we keep this on a low address.
         */
        px = (struct pgfree *) imalloc(sizeof * px);
 804a705:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 804a70c:	e8 b9 07 00 00       	call   804aeca <imalloc>
 804a711:	89 83 cc 04 00 00    	mov    %eax,0x4cc(%ebx)

        /* Been here, done that */
        malloc_started++;
 804a717:	8b 83 7c 04 00 00    	mov    0x47c(%ebx),%eax
 804a71d:	83 c0 01             	add    $0x1,%eax
 804a720:	89 83 7c 04 00 00    	mov    %eax,0x47c(%ebx)
}
 804a726:	83 c4 34             	add    $0x34,%esp
 804a729:	5b                   	pop    %ebx
 804a72a:	5d                   	pop    %ebp
 804a72b:	c3                   	ret    

0804a72c <malloc_pages>:
/*
 * Allocate a number of complete pages
 */
static void *
malloc_pages(size_t size)
{
 804a72c:	55                   	push   %ebp
 804a72d:	89 e5                	mov    %esp,%ebp
 804a72f:	53                   	push   %ebx
 804a730:	83 ec 34             	sub    $0x34,%esp
 804a733:	e8 2d dd ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804a738:	81 c3 74 5a 00 00    	add    $0x5a74,%ebx
        void *p, *delay_free = 0;
 804a73e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
        unsigned int i;
        struct pgfree *pf;
        u_long index;

        size = pageround(size);
 804a745:	8b 45 08             	mov    0x8(%ebp),%eax
 804a748:	05 ff 0f 00 00       	add    $0xfff,%eax
 804a74d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 804a752:	89 45 08             	mov    %eax,0x8(%ebp)

        p = 0;
 804a755:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804a75c:	8b 83 94 04 00 00    	mov    0x494(%ebx),%eax
 804a762:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804a765:	e9 82 00 00 00       	jmp    804a7ec <malloc_pages+0xc0>
                        wrterror("(ES): non-free first page on free-list\n");
                if (page_dir[ptr2index(pf->end) - 1] != MALLOC_FREE)
                        wrterror("(ES): non-free last page on free-list\n");
#endif /* EXTRA_SANITY */

                if (pf->size < size)
 804a76a:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a76d:	8b 40 10             	mov    0x10(%eax),%eax
 804a770:	3b 45 08             	cmp    0x8(%ebp),%eax
 804a773:	73 0a                	jae    804a77f <malloc_pages+0x53>
        size = pageround(size);

        p = 0;

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804a775:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a778:	8b 00                	mov    (%eax),%eax
 804a77a:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804a77d:	eb 6d                	jmp    804a7ec <malloc_pages+0xc0>
#endif /* EXTRA_SANITY */

                if (pf->size < size)
                        continue;

                if (pf->size == size) {
 804a77f:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a782:	8b 40 10             	mov    0x10(%eax),%eax
 804a785:	3b 45 08             	cmp    0x8(%ebp),%eax
 804a788:	75 35                	jne    804a7bf <malloc_pages+0x93>
                        p = pf->page;
 804a78a:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a78d:	8b 40 08             	mov    0x8(%eax),%eax
 804a790:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        if (pf->next)
 804a793:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a796:	8b 00                	mov    (%eax),%eax
 804a798:	85 c0                	test   %eax,%eax
 804a79a:	74 0e                	je     804a7aa <malloc_pages+0x7e>
                                pf->next->prev = pf->prev;
 804a79c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a79f:	8b 00                	mov    (%eax),%eax
 804a7a1:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804a7a4:	8b 52 04             	mov    0x4(%edx),%edx
 804a7a7:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev->next = pf->next;
 804a7aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a7ad:	8b 40 04             	mov    0x4(%eax),%eax
 804a7b0:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804a7b3:	8b 12                	mov    (%edx),%edx
 804a7b5:	89 10                	mov    %edx,(%eax)
                        delay_free = pf;
 804a7b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a7ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        break;
 804a7bd:	eb 37                	jmp    804a7f6 <malloc_pages+0xca>
                }

                p = pf->page;
 804a7bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a7c2:	8b 40 08             	mov    0x8(%eax),%eax
 804a7c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                pf->page = (char *)pf->page + size;
 804a7c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a7cb:	8b 40 08             	mov    0x8(%eax),%eax
 804a7ce:	89 c2                	mov    %eax,%edx
 804a7d0:	03 55 08             	add    0x8(%ebp),%edx
 804a7d3:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a7d6:	89 50 08             	mov    %edx,0x8(%eax)
                pf->size -= size;
 804a7d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a7dc:	8b 40 10             	mov    0x10(%eax),%eax
 804a7df:	89 c2                	mov    %eax,%edx
 804a7e1:	2b 55 08             	sub    0x8(%ebp),%edx
 804a7e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a7e7:	89 50 10             	mov    %edx,0x10(%eax)
                break;
 804a7ea:	eb 0a                	jmp    804a7f6 <malloc_pages+0xca>
        size = pageround(size);

        p = 0;

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804a7ec:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804a7f0:	0f 85 74 ff ff ff    	jne    804a76a <malloc_pages+0x3e>
#ifdef EXTRA_SANITY
        if (p && page_dir[ptr2index(p)] != MALLOC_FREE)
                wrterror("(ES): allocated non-free page on free-list\n");
#endif /* EXTRA_SANITY */

        size >>= malloc_pageshift;
 804a7f6:	c1 6d 08 0c          	shrl   $0xc,0x8(%ebp)

        /* Map new pages */
        if (!p)
 804a7fa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804a7fe:	75 0e                	jne    804a80e <malloc_pages+0xe2>
                p = map_pages(size);
 804a800:	8b 45 08             	mov    0x8(%ebp),%eax
 804a803:	89 04 24             	mov    %eax,(%esp)
 804a806:	e8 b6 f9 ff ff       	call   804a1c1 <map_pages>
 804a80b:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (p) {
 804a80e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804a812:	0f 84 80 00 00 00    	je     804a898 <malloc_pages+0x16c>

                index = ptr2index(p);
 804a818:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a81b:	89 c2                	mov    %eax,%edx
 804a81d:	c1 ea 0c             	shr    $0xc,%edx
 804a820:	8b 83 84 04 00 00    	mov    0x484(%ebx),%eax
 804a826:	89 d1                	mov    %edx,%ecx
 804a828:	29 c1                	sub    %eax,%ecx
 804a82a:	89 c8                	mov    %ecx,%eax
 804a82c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                page_dir[index] = MALLOC_FIRST;
 804a82f:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804a835:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804a838:	c1 e2 02             	shl    $0x2,%edx
 804a83b:	01 d0                	add    %edx,%eax
 804a83d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
                for (i = 1; i < size; i++)
 804a843:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
 804a84a:	eb 1d                	jmp    804a869 <malloc_pages+0x13d>
                        page_dir[index + i] = MALLOC_FOLLOW;
 804a84c:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804a852:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804a855:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 804a858:	01 ca                	add    %ecx,%edx
 804a85a:	c1 e2 02             	shl    $0x2,%edx
 804a85d:	01 d0                	add    %edx,%eax
 804a85f:	c7 00 03 00 00 00    	movl   $0x3,(%eax)

        if (p) {

                index = ptr2index(p);
                page_dir[index] = MALLOC_FIRST;
                for (i = 1; i < size; i++)
 804a865:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
 804a869:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a86c:	3b 45 08             	cmp    0x8(%ebp),%eax
 804a86f:	72 db                	jb     804a84c <malloc_pages+0x120>
                        page_dir[index + i] = MALLOC_FOLLOW;

                if (malloc_junk)
 804a871:	8b 83 c4 04 00 00    	mov    0x4c4(%ebx),%eax
 804a877:	85 c0                	test   %eax,%eax
 804a879:	74 1d                	je     804a898 <malloc_pages+0x16c>
                        memset(p, SOME_JUNK, size << malloc_pageshift);
 804a87b:	8b 45 08             	mov    0x8(%ebp),%eax
 804a87e:	c1 e0 0c             	shl    $0xc,%eax
 804a881:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a885:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804a88c:	00 
 804a88d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a890:	89 04 24             	mov    %eax,(%esp)
 804a893:	e8 2c 23 00 00       	call   804cbc4 <memset>
        }

        if (delay_free) {
 804a898:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804a89c:	74 20                	je     804a8be <malloc_pages+0x192>
                if (!px)
 804a89e:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804a8a4:	85 c0                	test   %eax,%eax
 804a8a6:	75 0b                	jne    804a8b3 <malloc_pages+0x187>
                        px = delay_free;
 804a8a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a8ab:	89 83 cc 04 00 00    	mov    %eax,0x4cc(%ebx)
 804a8b1:	eb 0b                	jmp    804a8be <malloc_pages+0x192>
                else
                        ifree(delay_free);
 804a8b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a8b6:	89 04 24             	mov    %eax,(%esp)
 804a8b9:	e8 60 0f 00 00       	call   804b81e <ifree>
        }

        return p;
 804a8be:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804a8c1:	83 c4 34             	add    $0x34,%esp
 804a8c4:	5b                   	pop    %ebx
 804a8c5:	5d                   	pop    %ebp
 804a8c6:	c3                   	ret    

0804a8c7 <malloc_make_chunks>:
 * Allocate a page of fragments
 */

static __inline__ int
malloc_make_chunks(int bits)
{
 804a8c7:	55                   	push   %ebp
 804a8c8:	89 e5                	mov    %esp,%ebp
 804a8ca:	57                   	push   %edi
 804a8cb:	56                   	push   %esi
 804a8cc:	53                   	push   %ebx
 804a8cd:	83 ec 4c             	sub    $0x4c,%esp
 804a8d0:	e8 90 db ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804a8d5:	81 c3 d7 58 00 00    	add    $0x58d7,%ebx
        struct  pginfo *bp;
        void *pp;
        unsigned int i, k, l;

        /* Allocate a new bucket */
        pp = malloc_pages(malloc_pagesize);
 804a8db:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
 804a8e2:	e8 45 fe ff ff       	call   804a72c <malloc_pages>
 804a8e7:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if (!pp)
 804a8ea:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
 804a8ee:	75 0a                	jne    804a8fa <malloc_make_chunks+0x33>
                return 0;
 804a8f0:	b8 00 00 00 00       	mov    $0x0,%eax
 804a8f5:	e9 16 02 00 00       	jmp    804ab10 <malloc_make_chunks+0x249>

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
 804a8fa:	c7 45 dc 10 00 00 00 	movl   $0x10,-0x24(%ebp)
        l += sizeof bp->bits[0] *
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);
 804a901:	8b 45 08             	mov    0x8(%ebp),%eax
 804a904:	ba 00 10 00 00       	mov    $0x1000,%edx
 804a909:	89 d6                	mov    %edx,%esi
 804a90b:	89 c1                	mov    %eax,%ecx
 804a90d:	d3 ee                	shr    %cl,%esi
 804a90f:	89 f0                	mov    %esi,%eax
 804a911:	83 c0 1f             	add    $0x1f,%eax
 804a914:	c1 e8 05             	shr    $0x5,%eax
        if (!pp)
                return 0;

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
        l += sizeof bp->bits[0] *
 804a917:	c1 e0 02             	shl    $0x2,%eax
 804a91a:	01 45 dc             	add    %eax,-0x24(%ebp)
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);

        /* Don't waste more than two chunks on this */
        if ((1U << (bits)) <= l + l) {
 804a91d:	8b 45 08             	mov    0x8(%ebp),%eax
 804a920:	ba 01 00 00 00       	mov    $0x1,%edx
 804a925:	89 c1                	mov    %eax,%ecx
 804a927:	d3 e2                	shl    %cl,%edx
 804a929:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a92c:	01 c0                	add    %eax,%eax
 804a92e:	39 c2                	cmp    %eax,%edx
 804a930:	77 08                	ja     804a93a <malloc_make_chunks+0x73>
                bp = (struct  pginfo *)pp;
 804a932:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a935:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804a938:	eb 29                	jmp    804a963 <malloc_make_chunks+0x9c>
        } else {
                bp = (struct  pginfo *)imalloc(l);
 804a93a:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a93d:	89 04 24             	mov    %eax,(%esp)
 804a940:	e8 85 05 00 00       	call   804aeca <imalloc>
 804a945:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (!bp) {
 804a948:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804a94c:	75 15                	jne    804a963 <malloc_make_chunks+0x9c>
                        ifree(pp);
 804a94e:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a951:	89 04 24             	mov    %eax,(%esp)
 804a954:	e8 c5 0e 00 00       	call   804b81e <ifree>
                        return 0;
 804a959:	b8 00 00 00 00       	mov    $0x0,%eax
 804a95e:	e9 ad 01 00 00       	jmp    804ab10 <malloc_make_chunks+0x249>
                }
        }

        bp->size = (1 << bits);
 804a963:	8b 45 08             	mov    0x8(%ebp),%eax
 804a966:	ba 01 00 00 00       	mov    $0x1,%edx
 804a96b:	89 d6                	mov    %edx,%esi
 804a96d:	89 c1                	mov    %eax,%ecx
 804a96f:	d3 e6                	shl    %cl,%esi
 804a971:	89 f0                	mov    %esi,%eax
 804a973:	89 c2                	mov    %eax,%edx
 804a975:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a978:	66 89 50 08          	mov    %dx,0x8(%eax)
        bp->shift = bits;
 804a97c:	8b 45 08             	mov    0x8(%ebp),%eax
 804a97f:	89 c2                	mov    %eax,%edx
 804a981:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a984:	66 89 50 0a          	mov    %dx,0xa(%eax)
        bp->total = bp->free = malloc_pagesize >> bits;
 804a988:	8b 45 08             	mov    0x8(%ebp),%eax
 804a98b:	ba 00 10 00 00       	mov    $0x1000,%edx
 804a990:	89 d6                	mov    %edx,%esi
 804a992:	89 c1                	mov    %eax,%ecx
 804a994:	d3 ee                	shr    %cl,%esi
 804a996:	89 f0                	mov    %esi,%eax
 804a998:	89 c2                	mov    %eax,%edx
 804a99a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a99d:	66 89 50 0c          	mov    %dx,0xc(%eax)
 804a9a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a9a4:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804a9a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a9ab:	66 89 50 0e          	mov    %dx,0xe(%eax)
        bp->page = pp;
 804a9af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a9b2:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804a9b5:	89 50 04             	mov    %edx,0x4(%eax)

        /* set all valid bits in the bitmap */
        k = bp->total;
 804a9b8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a9bb:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804a9bf:	0f b7 c0             	movzwl %ax,%eax
 804a9c2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        i = 0;
 804a9c5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 804a9cc:	eb 19                	jmp    804a9e7 <malloc_make_chunks+0x120>
                bp->bits[i / MALLOC_BITS] = ~0;
 804a9ce:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a9d1:	89 c2                	mov    %eax,%edx
 804a9d3:	c1 ea 05             	shr    $0x5,%edx
 804a9d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a9d9:	83 c2 04             	add    $0x4,%edx
 804a9dc:	c7 04 90 ff ff ff ff 	movl   $0xffffffff,(%eax,%edx,4)
        /* set all valid bits in the bitmap */
        k = bp->total;
        i = 0;

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 804a9e3:	83 45 e0 20          	addl   $0x20,-0x20(%ebp)
 804a9e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a9ea:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804a9ed:	89 d7                	mov    %edx,%edi
 804a9ef:	29 c7                	sub    %eax,%edi
 804a9f1:	89 f8                	mov    %edi,%eax
 804a9f3:	83 f8 1f             	cmp    $0x1f,%eax
 804a9f6:	77 d6                	ja     804a9ce <malloc_make_chunks+0x107>
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 804a9f8:	eb 36                	jmp    804aa30 <malloc_make_chunks+0x169>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804a9fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a9fd:	c1 e8 05             	shr    $0x5,%eax
 804aa00:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804aa03:	8d 48 04             	lea    0x4(%eax),%ecx
 804aa06:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 804aa09:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804aa0c:	83 e2 1f             	and    $0x1f,%edx
 804aa0f:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
 804aa16:	8b 7d c4             	mov    -0x3c(%ebp),%edi
 804aa19:	89 d1                	mov    %edx,%ecx
 804aa1b:	d3 e7                	shl    %cl,%edi
 804aa1d:	89 fa                	mov    %edi,%edx
 804aa1f:	89 f1                	mov    %esi,%ecx
 804aa21:	09 d1                	or     %edx,%ecx
 804aa23:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804aa26:	83 c0 04             	add    $0x4,%eax
 804aa29:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 804aa2c:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
 804aa30:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804aa33:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
 804aa36:	72 c2                	jb     804a9fa <malloc_make_chunks+0x133>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
 804aa38:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804aa3b:	8b 40 04             	mov    0x4(%eax),%eax
 804aa3e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804aa41:	75 7c                	jne    804aabf <malloc_make_chunks+0x1f8>
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804aa43:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
 804aa4a:	eb 6d                	jmp    804aab9 <malloc_make_chunks+0x1f2>
                        bp->bits[i / MALLOC_BITS] &= ~(1 << (i % MALLOC_BITS));
 804aa4c:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804aa4f:	c1 e8 05             	shr    $0x5,%eax
 804aa52:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804aa55:	8d 48 04             	lea    0x4(%eax),%ecx
 804aa58:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 804aa5b:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804aa5e:	83 e2 1f             	and    $0x1f,%edx
 804aa61:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
 804aa68:	8b 7d c4             	mov    -0x3c(%ebp),%edi
 804aa6b:	89 d1                	mov    %edx,%ecx
 804aa6d:	d3 e7                	shl    %cl,%edi
 804aa6f:	89 fa                	mov    %edi,%edx
 804aa71:	f7 d2                	not    %edx
 804aa73:	89 f1                	mov    %esi,%ecx
 804aa75:	21 d1                	and    %edx,%ecx
 804aa77:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804aa7a:	83 c0 04             	add    $0x4,%eax
 804aa7d:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
                        bp->free--;
 804aa80:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804aa83:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804aa87:	8d 50 ff             	lea    -0x1(%eax),%edx
 804aa8a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804aa8d:	66 89 50 0c          	mov    %dx,0xc(%eax)
                        bp->total--;
 804aa91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804aa94:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804aa98:	8d 50 ff             	lea    -0x1(%eax),%edx
 804aa9b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804aa9e:	66 89 50 0e          	mov    %dx,0xe(%eax)
                        l -= (1 << bits);
 804aaa2:	8b 45 08             	mov    0x8(%ebp),%eax
 804aaa5:	ba 01 00 00 00       	mov    $0x1,%edx
 804aaaa:	89 d6                	mov    %edx,%esi
 804aaac:	89 c1                	mov    %eax,%ecx
 804aaae:	d3 e6                	shl    %cl,%esi
 804aab0:	89 f0                	mov    %esi,%eax
 804aab2:	29 45 dc             	sub    %eax,-0x24(%ebp)
        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804aab5:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
 804aab9:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 804aabd:	75 8d                	jne    804aa4c <malloc_make_chunks+0x185>
                }
        }

        /* MALLOC_LOCK */

        page_dir[ptr2index(pp)] = bp;
 804aabf:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804aac5:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804aac8:	89 d1                	mov    %edx,%ecx
 804aaca:	c1 e9 0c             	shr    $0xc,%ecx
 804aacd:	8b 93 84 04 00 00    	mov    0x484(%ebx),%edx
 804aad3:	89 cf                	mov    %ecx,%edi
 804aad5:	29 d7                	sub    %edx,%edi
 804aad7:	89 fa                	mov    %edi,%edx
 804aad9:	c1 e2 02             	shl    $0x2,%edx
 804aadc:	01 c2                	add    %eax,%edx
 804aade:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804aae1:	89 02                	mov    %eax,(%edx)

        bp->next = page_dir[bits];
 804aae3:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804aae9:	8b 55 08             	mov    0x8(%ebp),%edx
 804aaec:	c1 e2 02             	shl    $0x2,%edx
 804aaef:	01 d0                	add    %edx,%eax
 804aaf1:	8b 10                	mov    (%eax),%edx
 804aaf3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804aaf6:	89 10                	mov    %edx,(%eax)
        page_dir[bits] = bp;
 804aaf8:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804aafe:	8b 55 08             	mov    0x8(%ebp),%edx
 804ab01:	c1 e2 02             	shl    $0x2,%edx
 804ab04:	01 c2                	add    %eax,%edx
 804ab06:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804ab09:	89 02                	mov    %eax,(%edx)

        /* MALLOC_UNLOCK */

        return 1;
 804ab0b:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804ab10:	83 c4 4c             	add    $0x4c,%esp
 804ab13:	5b                   	pop    %ebx
 804ab14:	5e                   	pop    %esi
 804ab15:	5f                   	pop    %edi
 804ab16:	5d                   	pop    %ebp
 804ab17:	c3                   	ret    

0804ab18 <malloc_bytes>:
/*
 * Allocate a fragment
 */
static void *
malloc_bytes(size_t size)
{
 804ab18:	55                   	push   %ebp
 804ab19:	89 e5                	mov    %esp,%ebp
 804ab1b:	57                   	push   %edi
 804ab1c:	56                   	push   %esi
 804ab1d:	53                   	push   %ebx
 804ab1e:	83 ec 5c             	sub    $0x5c,%esp
 804ab21:	e8 3f d9 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804ab26:	81 c3 86 56 00 00    	add    $0x5686,%ebx
        struct  pginfo *bp;
        int k;
        u_int *lp;

        /* Don't bother with anything less than this */
        if (size < malloc_minsize)
 804ab2c:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
 804ab30:	77 07                	ja     804ab39 <malloc_bytes+0x21>
                size = malloc_minsize;
 804ab32:	c7 45 08 10 00 00 00 	movl   $0x10,0x8(%ebp)

        /* Find the right bucket */
        j = 1;
 804ab39:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        i = size - 1;
 804ab40:	8b 45 08             	mov    0x8(%ebp),%eax
 804ab43:	83 e8 01             	sub    $0x1,%eax
 804ab46:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        while (i >>= 1)
 804ab49:	eb 04                	jmp    804ab4f <malloc_bytes+0x37>
                j++;
 804ab4b:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
                size = malloc_minsize;

        /* Find the right bucket */
        j = 1;
        i = size - 1;
        while (i >>= 1)
 804ab4f:	d1 7d e4             	sarl   -0x1c(%ebp)
 804ab52:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804ab56:	75 f3                	jne    804ab4b <malloc_bytes+0x33>
                j++;

        /* If it's empty, make a page more of that size chunks */
        if (!page_dir[j] && !malloc_make_chunks(j))
 804ab58:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804ab5e:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804ab61:	c1 e2 02             	shl    $0x2,%edx
 804ab64:	01 d0                	add    %edx,%eax
 804ab66:	8b 00                	mov    (%eax),%eax
 804ab68:	85 c0                	test   %eax,%eax
 804ab6a:	0f 85 49 02 00 00    	jne    804adb9 <malloc_bytes+0x2a1>
 804ab70:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804ab73:	89 45 cc             	mov    %eax,-0x34(%ebp)
        struct  pginfo *bp;
        void *pp;
        unsigned int i, k, l;

        /* Allocate a new bucket */
        pp = malloc_pages(malloc_pagesize);
 804ab76:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
 804ab7d:	e8 aa fb ff ff       	call   804a72c <malloc_pages>
 804ab82:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if (!pp)
 804ab85:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804ab89:	75 0a                	jne    804ab95 <malloc_bytes+0x7d>
                return 0;
 804ab8b:	b8 00 00 00 00       	mov    $0x0,%eax
 804ab90:	e9 16 02 00 00       	jmp    804adab <malloc_bytes+0x293>

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
 804ab95:	c7 45 c4 10 00 00 00 	movl   $0x10,-0x3c(%ebp)
        l += sizeof bp->bits[0] *
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);
 804ab9c:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804ab9f:	ba 00 10 00 00       	mov    $0x1000,%edx
 804aba4:	89 d6                	mov    %edx,%esi
 804aba6:	89 c1                	mov    %eax,%ecx
 804aba8:	d3 ee                	shr    %cl,%esi
 804abaa:	89 f0                	mov    %esi,%eax
 804abac:	83 c0 1f             	add    $0x1f,%eax
 804abaf:	c1 e8 05             	shr    $0x5,%eax
        if (!pp)
                return 0;

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
        l += sizeof bp->bits[0] *
 804abb2:	c1 e0 02             	shl    $0x2,%eax
 804abb5:	01 45 c4             	add    %eax,-0x3c(%ebp)
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);

        /* Don't waste more than two chunks on this */
        if ((1U << (bits)) <= l + l) {
 804abb8:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804abbb:	ba 01 00 00 00       	mov    $0x1,%edx
 804abc0:	89 c1                	mov    %eax,%ecx
 804abc2:	d3 e2                	shl    %cl,%edx
 804abc4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804abc7:	01 c0                	add    %eax,%eax
 804abc9:	39 c2                	cmp    %eax,%edx
 804abcb:	77 08                	ja     804abd5 <malloc_bytes+0xbd>
                bp = (struct  pginfo *)pp;
 804abcd:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804abd0:	89 45 c0             	mov    %eax,-0x40(%ebp)
 804abd3:	eb 29                	jmp    804abfe <malloc_bytes+0xe6>
        } else {
                bp = (struct  pginfo *)imalloc(l);
 804abd5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804abd8:	89 04 24             	mov    %eax,(%esp)
 804abdb:	e8 ea 02 00 00       	call   804aeca <imalloc>
 804abe0:	89 45 c0             	mov    %eax,-0x40(%ebp)
                if (!bp) {
 804abe3:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
 804abe7:	75 15                	jne    804abfe <malloc_bytes+0xe6>
                        ifree(pp);
 804abe9:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804abec:	89 04 24             	mov    %eax,(%esp)
 804abef:	e8 2a 0c 00 00       	call   804b81e <ifree>
                        return 0;
 804abf4:	b8 00 00 00 00       	mov    $0x0,%eax
 804abf9:	e9 ad 01 00 00       	jmp    804adab <malloc_bytes+0x293>
                }
        }

        bp->size = (1 << bits);
 804abfe:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804ac01:	ba 01 00 00 00       	mov    $0x1,%edx
 804ac06:	89 d6                	mov    %edx,%esi
 804ac08:	89 c1                	mov    %eax,%ecx
 804ac0a:	d3 e6                	shl    %cl,%esi
 804ac0c:	89 f0                	mov    %esi,%eax
 804ac0e:	89 c2                	mov    %eax,%edx
 804ac10:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ac13:	66 89 50 08          	mov    %dx,0x8(%eax)
        bp->shift = bits;
 804ac17:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804ac1a:	89 c2                	mov    %eax,%edx
 804ac1c:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ac1f:	66 89 50 0a          	mov    %dx,0xa(%eax)
        bp->total = bp->free = malloc_pagesize >> bits;
 804ac23:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804ac26:	ba 00 10 00 00       	mov    $0x1000,%edx
 804ac2b:	89 d6                	mov    %edx,%esi
 804ac2d:	89 c1                	mov    %eax,%ecx
 804ac2f:	d3 ee                	shr    %cl,%esi
 804ac31:	89 f0                	mov    %esi,%eax
 804ac33:	89 c2                	mov    %eax,%edx
 804ac35:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ac38:	66 89 50 0c          	mov    %dx,0xc(%eax)
 804ac3c:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ac3f:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804ac43:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ac46:	66 89 50 0e          	mov    %dx,0xe(%eax)
        bp->page = pp;
 804ac4a:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ac4d:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804ac50:	89 50 04             	mov    %edx,0x4(%eax)

        /* set all valid bits in the bitmap */
        k = bp->total;
 804ac53:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ac56:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804ac5a:	0f b7 c0             	movzwl %ax,%eax
 804ac5d:	89 45 bc             	mov    %eax,-0x44(%ebp)
        i = 0;
 804ac60:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 804ac67:	eb 19                	jmp    804ac82 <malloc_bytes+0x16a>

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;
 804ac69:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ac6c:	89 c2                	mov    %eax,%edx
 804ac6e:	c1 ea 05             	shr    $0x5,%edx
 804ac71:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ac74:	83 c2 04             	add    $0x4,%edx
 804ac77:	c7 04 90 ff ff ff ff 	movl   $0xffffffff,(%eax,%edx,4)
        /* set all valid bits in the bitmap */
        k = bp->total;
        i = 0;

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 804ac7e:	83 45 b8 20          	addl   $0x20,-0x48(%ebp)
 804ac82:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ac85:	8b 55 bc             	mov    -0x44(%ebp),%edx
 804ac88:	89 d7                	mov    %edx,%edi
 804ac8a:	29 c7                	sub    %eax,%edi
 804ac8c:	89 f8                	mov    %edi,%eax
 804ac8e:	83 f8 1f             	cmp    $0x1f,%eax
 804ac91:	77 d6                	ja     804ac69 <malloc_bytes+0x151>
 804ac93:	eb 36                	jmp    804accb <malloc_bytes+0x1b3>
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804ac95:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804ac98:	c1 e8 05             	shr    $0x5,%eax
 804ac9b:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804ac9e:	8d 48 04             	lea    0x4(%eax),%ecx
 804aca1:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 804aca4:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804aca7:	83 e2 1f             	and    $0x1f,%edx
 804acaa:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
 804acb1:	8b 7d b4             	mov    -0x4c(%ebp),%edi
 804acb4:	89 d1                	mov    %edx,%ecx
 804acb6:	d3 e7                	shl    %cl,%edi
 804acb8:	89 fa                	mov    %edi,%edx
 804acba:	89 f1                	mov    %esi,%ecx
 804acbc:	09 d1                	or     %edx,%ecx
 804acbe:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804acc1:	83 c0 04             	add    $0x4,%eax
 804acc4:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 804acc7:	83 45 b8 01          	addl   $0x1,-0x48(%ebp)
 804accb:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804acce:	3b 45 b8             	cmp    -0x48(%ebp),%eax
 804acd1:	77 c2                	ja     804ac95 <malloc_bytes+0x17d>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
 804acd3:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804acd6:	8b 40 04             	mov    0x4(%eax),%eax
 804acd9:	39 45 c0             	cmp    %eax,-0x40(%ebp)
 804acdc:	75 7c                	jne    804ad5a <malloc_bytes+0x242>
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804acde:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 804ace5:	eb 6d                	jmp    804ad54 <malloc_bytes+0x23c>
                        bp->bits[i / MALLOC_BITS] &= ~(1 << (i % MALLOC_BITS));
 804ace7:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804acea:	c1 e8 05             	shr    $0x5,%eax
 804aced:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804acf0:	8d 48 04             	lea    0x4(%eax),%ecx
 804acf3:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 804acf6:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804acf9:	83 e2 1f             	and    $0x1f,%edx
 804acfc:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
 804ad03:	8b 7d b4             	mov    -0x4c(%ebp),%edi
 804ad06:	89 d1                	mov    %edx,%ecx
 804ad08:	d3 e7                	shl    %cl,%edi
 804ad0a:	89 fa                	mov    %edi,%edx
 804ad0c:	f7 d2                	not    %edx
 804ad0e:	89 f1                	mov    %esi,%ecx
 804ad10:	21 d1                	and    %edx,%ecx
 804ad12:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804ad15:	83 c0 04             	add    $0x4,%eax
 804ad18:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
                        bp->free--;
 804ad1b:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ad1e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804ad22:	8d 50 ff             	lea    -0x1(%eax),%edx
 804ad25:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ad28:	66 89 50 0c          	mov    %dx,0xc(%eax)
                        bp->total--;
 804ad2c:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ad2f:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804ad33:	8d 50 ff             	lea    -0x1(%eax),%edx
 804ad36:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ad39:	66 89 50 0e          	mov    %dx,0xe(%eax)
                        l -= (1 << bits);
 804ad3d:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804ad40:	ba 01 00 00 00       	mov    $0x1,%edx
 804ad45:	89 d6                	mov    %edx,%esi
 804ad47:	89 c1                	mov    %eax,%ecx
 804ad49:	d3 e6                	shl    %cl,%esi
 804ad4b:	89 f0                	mov    %esi,%eax
 804ad4d:	29 45 c4             	sub    %eax,-0x3c(%ebp)
        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804ad50:	83 45 b8 01          	addl   $0x1,-0x48(%ebp)
 804ad54:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
 804ad58:	75 8d                	jne    804ace7 <malloc_bytes+0x1cf>
                }
        }

        /* MALLOC_LOCK */

        page_dir[ptr2index(pp)] = bp;
 804ad5a:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804ad60:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804ad63:	89 d1                	mov    %edx,%ecx
 804ad65:	c1 e9 0c             	shr    $0xc,%ecx
 804ad68:	8b 93 84 04 00 00    	mov    0x484(%ebx),%edx
 804ad6e:	89 cf                	mov    %ecx,%edi
 804ad70:	29 d7                	sub    %edx,%edi
 804ad72:	89 fa                	mov    %edi,%edx
 804ad74:	c1 e2 02             	shl    $0x2,%edx
 804ad77:	01 c2                	add    %eax,%edx
 804ad79:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ad7c:	89 02                	mov    %eax,(%edx)

        bp->next = page_dir[bits];
 804ad7e:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804ad84:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804ad87:	c1 e2 02             	shl    $0x2,%edx
 804ad8a:	01 d0                	add    %edx,%eax
 804ad8c:	8b 10                	mov    (%eax),%edx
 804ad8e:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ad91:	89 10                	mov    %edx,(%eax)
        page_dir[bits] = bp;
 804ad93:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804ad99:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804ad9c:	c1 e2 02             	shl    $0x2,%edx
 804ad9f:	01 c2                	add    %eax,%edx
 804ada1:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ada4:	89 02                	mov    %eax,(%edx)

        /* MALLOC_UNLOCK */

        return 1;
 804ada6:	b8 01 00 00 00       	mov    $0x1,%eax
        i = size - 1;
        while (i >>= 1)
                j++;

        /* If it's empty, make a page more of that size chunks */
        if (!page_dir[j] && !malloc_make_chunks(j))
 804adab:	85 c0                	test   %eax,%eax
 804adad:	75 0a                	jne    804adb9 <malloc_bytes+0x2a1>
                return 0;
 804adaf:	b8 00 00 00 00       	mov    $0x0,%eax
 804adb4:	e9 09 01 00 00       	jmp    804aec2 <malloc_bytes+0x3aa>

        bp = page_dir[j];
 804adb9:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804adbf:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804adc2:	c1 e2 02             	shl    $0x2,%edx
 804adc5:	01 d0                	add    %edx,%eax
 804adc7:	8b 00                	mov    (%eax),%eax
 804adc9:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /* Find first word of bitmap which isn't empty */
        for (lp = bp->bits; !*lp; lp++)
 804adcc:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804adcf:	83 c0 10             	add    $0x10,%eax
 804add2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804add5:	eb 04                	jmp    804addb <malloc_bytes+0x2c3>
 804add7:	83 45 d4 04          	addl   $0x4,-0x2c(%ebp)
 804addb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804adde:	8b 00                	mov    (%eax),%eax
 804ade0:	85 c0                	test   %eax,%eax
 804ade2:	74 f3                	je     804add7 <malloc_bytes+0x2bf>
                ;

        /* Find that bit, and tweak it */
        u = 1;
 804ade4:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        k = 0;
 804adeb:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
        while (!(*lp & u)) {
 804adf2:	eb 0c                	jmp    804ae00 <malloc_bytes+0x2e8>
                u += u;
 804adf4:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804adf7:	01 c0                	add    %eax,%eax
 804adf9:	89 45 dc             	mov    %eax,-0x24(%ebp)
                k++;
 804adfc:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
                ;

        /* Find that bit, and tweak it */
        u = 1;
        k = 0;
        while (!(*lp & u)) {
 804ae00:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804ae03:	8b 00                	mov    (%eax),%eax
 804ae05:	23 45 dc             	and    -0x24(%ebp),%eax
 804ae08:	85 c0                	test   %eax,%eax
 804ae0a:	74 e8                	je     804adf4 <malloc_bytes+0x2dc>
                u += u;
                k++;
        }
        *lp ^= u;
 804ae0c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804ae0f:	8b 00                	mov    (%eax),%eax
 804ae11:	89 c2                	mov    %eax,%edx
 804ae13:	33 55 dc             	xor    -0x24(%ebp),%edx
 804ae16:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804ae19:	89 10                	mov    %edx,(%eax)

        /* If there are no more free, remove from free-list */
        if (!--bp->free) {
 804ae1b:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804ae1e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804ae22:	8d 50 ff             	lea    -0x1(%eax),%edx
 804ae25:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804ae28:	66 89 50 0c          	mov    %dx,0xc(%eax)
 804ae2c:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804ae2f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804ae33:	66 85 c0             	test   %ax,%ax
 804ae36:	75 1e                	jne    804ae56 <malloc_bytes+0x33e>
                page_dir[j] = bp->next;
 804ae38:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804ae3e:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804ae41:	c1 e2 02             	shl    $0x2,%edx
 804ae44:	01 c2                	add    %eax,%edx
 804ae46:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804ae49:	8b 00                	mov    (%eax),%eax
 804ae4b:	89 02                	mov    %eax,(%edx)
                bp->next = 0;
 804ae4d:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804ae50:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        }

        /* Adjust to the real offset of that chunk */
        k += (lp - bp->bits) * MALLOC_BITS;
 804ae56:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804ae59:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804ae5c:	83 c0 10             	add    $0x10,%eax
 804ae5f:	89 d1                	mov    %edx,%ecx
 804ae61:	29 c1                	sub    %eax,%ecx
 804ae63:	89 c8                	mov    %ecx,%eax
 804ae65:	c1 f8 02             	sar    $0x2,%eax
 804ae68:	89 c2                	mov    %eax,%edx
 804ae6a:	c1 e2 05             	shl    $0x5,%edx
 804ae6d:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804ae70:	01 d0                	add    %edx,%eax
 804ae72:	89 45 d8             	mov    %eax,-0x28(%ebp)
        k <<= bp->shift;
 804ae75:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804ae78:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804ae7c:	0f b7 c0             	movzwl %ax,%eax
 804ae7f:	89 c1                	mov    %eax,%ecx
 804ae81:	d3 65 d8             	shll   %cl,-0x28(%ebp)

        if (malloc_junk)
 804ae84:	8b 83 c4 04 00 00    	mov    0x4c4(%ebx),%eax
 804ae8a:	85 c0                	test   %eax,%eax
 804ae8c:	74 29                	je     804aeb7 <malloc_bytes+0x39f>
                memset((u_char *)bp->page + k, SOME_JUNK, bp->size);
 804ae8e:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804ae91:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804ae95:	0f b7 c0             	movzwl %ax,%eax
 804ae98:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804ae9b:	8b 4a 04             	mov    0x4(%edx),%ecx
 804ae9e:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804aea1:	01 ca                	add    %ecx,%edx
 804aea3:	89 44 24 08          	mov    %eax,0x8(%esp)
 804aea7:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804aeae:	00 
 804aeaf:	89 14 24             	mov    %edx,(%esp)
 804aeb2:	e8 0d 1d 00 00       	call   804cbc4 <memset>

        return (u_char *)bp->page + k;
 804aeb7:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804aeba:	8b 50 04             	mov    0x4(%eax),%edx
 804aebd:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804aec0:	01 d0                	add    %edx,%eax
}
 804aec2:	83 c4 5c             	add    $0x5c,%esp
 804aec5:	5b                   	pop    %ebx
 804aec6:	5e                   	pop    %esi
 804aec7:	5f                   	pop    %edi
 804aec8:	5d                   	pop    %ebp
 804aec9:	c3                   	ret    

0804aeca <imalloc>:
/*
 * Allocate a piece of memory
 */
static void *
imalloc(size_t size)
{
 804aeca:	55                   	push   %ebp
 804aecb:	89 e5                	mov    %esp,%ebp
 804aecd:	53                   	push   %ebx
 804aece:	83 ec 24             	sub    $0x24,%esp
 804aed1:	e8 8f d5 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804aed6:	81 c3 d6 52 00 00    	add    $0x52d6,%ebx
        void *result;

        if (suicide)
 804aedc:	8b 83 ac 04 00 00    	mov    0x4ac(%ebx),%eax
 804aee2:	85 c0                	test   %eax,%eax
 804aee4:	74 0c                	je     804aef2 <imalloc+0x28>
                abort();
 804aee6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804aeed:	e8 e6 d7 ff ff       	call   80486d8 <exit>

        if ((size + malloc_pagesize) < size)        /* Check for overflow */
 804aef2:	8b 45 08             	mov    0x8(%ebp),%eax
 804aef5:	05 00 10 00 00       	add    $0x1000,%eax
 804aefa:	3b 45 08             	cmp    0x8(%ebp),%eax
 804aefd:	73 09                	jae    804af08 <imalloc+0x3e>
                result = 0;
 804aeff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804af06:	eb 27                	jmp    804af2f <imalloc+0x65>
        else if (size <= malloc_maxsize)
 804af08:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
 804af0f:	77 10                	ja     804af21 <imalloc+0x57>
                result =  malloc_bytes(size);
 804af11:	8b 45 08             	mov    0x8(%ebp),%eax
 804af14:	89 04 24             	mov    %eax,(%esp)
 804af17:	e8 fc fb ff ff       	call   804ab18 <malloc_bytes>
 804af1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804af1f:	eb 0e                	jmp    804af2f <imalloc+0x65>
        else
                result =  malloc_pages(size);
 804af21:	8b 45 08             	mov    0x8(%ebp),%eax
 804af24:	89 04 24             	mov    %eax,(%esp)
 804af27:	e8 00 f8 ff ff       	call   804a72c <malloc_pages>
 804af2c:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (malloc_abort && !result)
 804af2f:	8b 83 a8 04 00 00    	mov    0x4a8(%ebx),%eax
 804af35:	85 c0                	test   %eax,%eax
 804af37:	74 14                	je     804af4d <imalloc+0x83>
 804af39:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804af3d:	75 0e                	jne    804af4d <imalloc+0x83>
                wrterror("allocation failed.\n");
 804af3f:	8d 83 52 d6 ff ff    	lea    -0x29ae(%ebx),%eax
 804af45:	89 04 24             	mov    %eax,(%esp)
 804af48:	e8 df f0 ff ff       	call   804a02c <wrterror>

        if (malloc_zero && result)
 804af4d:	8b 83 c0 04 00 00    	mov    0x4c0(%ebx),%eax
 804af53:	85 c0                	test   %eax,%eax
 804af55:	74 20                	je     804af77 <imalloc+0xad>
 804af57:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804af5b:	74 1a                	je     804af77 <imalloc+0xad>
                memset(result, 0, size);
 804af5d:	8b 45 08             	mov    0x8(%ebp),%eax
 804af60:	89 44 24 08          	mov    %eax,0x8(%esp)
 804af64:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804af6b:	00 
 804af6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804af6f:	89 04 24             	mov    %eax,(%esp)
 804af72:	e8 4d 1c 00 00       	call   804cbc4 <memset>

        return result;
 804af77:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804af7a:	83 c4 24             	add    $0x24,%esp
 804af7d:	5b                   	pop    %ebx
 804af7e:	5d                   	pop    %ebp
 804af7f:	c3                   	ret    

0804af80 <irealloc>:
/*
 * Change the size of an allocation.
 */
static void *
irealloc(void *ptr, size_t size)
{
 804af80:	55                   	push   %ebp
 804af81:	89 e5                	mov    %esp,%ebp
 804af83:	57                   	push   %edi
 804af84:	56                   	push   %esi
 804af85:	53                   	push   %ebx
 804af86:	83 ec 3c             	sub    $0x3c,%esp
 804af89:	e8 d7 d4 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804af8e:	81 c3 1e 52 00 00    	add    $0x521e,%ebx
        void *p;
        u_long osize, index;
        struct pginfo **mp;
        int i;

        if (suicide)
 804af94:	8b 83 ac 04 00 00    	mov    0x4ac(%ebx),%eax
 804af9a:	85 c0                	test   %eax,%eax
 804af9c:	74 0c                	je     804afaa <irealloc+0x2a>
                abort();
 804af9e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804afa5:	e8 2e d7 ff ff       	call   80486d8 <exit>

        index = ptr2index(ptr);
 804afaa:	8b 45 08             	mov    0x8(%ebp),%eax
 804afad:	89 c2                	mov    %eax,%edx
 804afaf:	c1 ea 0c             	shr    $0xc,%edx
 804afb2:	8b 83 84 04 00 00    	mov    0x484(%ebx),%eax
 804afb8:	89 d1                	mov    %edx,%ecx
 804afba:	29 c1                	sub    %eax,%ecx
 804afbc:	89 c8                	mov    %ecx,%eax
 804afbe:	89 45 dc             	mov    %eax,-0x24(%ebp)

        if (index < malloc_pageshift) {
 804afc1:	83 7d dc 0b          	cmpl   $0xb,-0x24(%ebp)
 804afc5:	77 18                	ja     804afdf <irealloc+0x5f>
                wrtwarning("junk pointer, too low to make sense.\n");
 804afc7:	8d 83 68 d6 ff ff    	lea    -0x2998(%ebx),%eax
 804afcd:	89 04 24             	mov    %eax,(%esp)
 804afd0:	e8 22 f1 ff ff       	call   804a0f7 <wrtwarning>
                return 0;
 804afd5:	b8 00 00 00 00       	mov    $0x0,%eax
 804afda:	e9 0c 02 00 00       	jmp    804b1eb <irealloc+0x26b>
        }

        if (index > last_index) {
 804afdf:	8b 83 88 04 00 00    	mov    0x488(%ebx),%eax
 804afe5:	39 45 dc             	cmp    %eax,-0x24(%ebp)
 804afe8:	76 18                	jbe    804b002 <irealloc+0x82>
                wrtwarning("junk pointer, too high to make sense.\n");
 804afea:	8d 83 90 d6 ff ff    	lea    -0x2970(%ebx),%eax
 804aff0:	89 04 24             	mov    %eax,(%esp)
 804aff3:	e8 ff f0 ff ff       	call   804a0f7 <wrtwarning>
                return 0;
 804aff8:	b8 00 00 00 00       	mov    $0x0,%eax
 804affd:	e9 e9 01 00 00       	jmp    804b1eb <irealloc+0x26b>
        }

        mp = &page_dir[index];
 804b002:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804b008:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804b00b:	c1 e2 02             	shl    $0x2,%edx
 804b00e:	01 d0                	add    %edx,%eax
 804b010:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if (*mp == MALLOC_FIRST) {                  /* Page allocation */
 804b013:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b016:	8b 00                	mov    (%eax),%eax
 804b018:	83 f8 02             	cmp    $0x2,%eax
 804b01b:	75 75                	jne    804b092 <irealloc+0x112>

                /* Check the pointer */
                if ((u_long)ptr & malloc_pagemask) {
 804b01d:	8b 45 08             	mov    0x8(%ebp),%eax
 804b020:	25 ff 0f 00 00       	and    $0xfff,%eax
 804b025:	85 c0                	test   %eax,%eax
 804b027:	74 18                	je     804b041 <irealloc+0xc1>
                        wrtwarning("modified (page-) pointer.\n");
 804b029:	8d 83 b7 d6 ff ff    	lea    -0x2949(%ebx),%eax
 804b02f:	89 04 24             	mov    %eax,(%esp)
 804b032:	e8 c0 f0 ff ff       	call   804a0f7 <wrtwarning>
                        return 0;
 804b037:	b8 00 00 00 00       	mov    $0x0,%eax
 804b03c:	e9 aa 01 00 00       	jmp    804b1eb <irealloc+0x26b>
                }

                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
 804b041:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
 804b048:	eb 07                	jmp    804b051 <irealloc+0xd1>
                        osize += malloc_pagesize;
 804b04a:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
                        wrtwarning("modified (page-) pointer.\n");
                        return 0;
                }

                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
 804b051:	83 45 e0 04          	addl   $0x4,-0x20(%ebp)
 804b055:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b058:	8b 00                	mov    (%eax),%eax
 804b05a:	83 f8 03             	cmp    $0x3,%eax
 804b05d:	74 eb                	je     804b04a <irealloc+0xca>
                        osize += malloc_pagesize;

                if (!malloc_realloc &&                  /* unless we have to, */
 804b05f:	8b 83 b0 04 00 00    	mov    0x4b0(%ebx),%eax
 804b065:	85 c0                	test   %eax,%eax
 804b067:	0f 85 14 01 00 00    	jne    804b181 <irealloc+0x201>
 804b06d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b070:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804b073:	0f 87 08 01 00 00    	ja     804b181 <irealloc+0x201>
                    size <= osize &&                      /* .. or are too small, */
                    size > (osize - malloc_pagesize)) {   /* .. or can free a page, */
 804b079:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b07c:	2d 00 10 00 00       	sub    $0x1000,%eax
                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
                        osize += malloc_pagesize;

                if (!malloc_realloc &&                  /* unless we have to, */
                    size <= osize &&                      /* .. or are too small, */
 804b081:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804b084:	0f 83 f7 00 00 00    	jae    804b181 <irealloc+0x201>
                    size > (osize - malloc_pagesize)) {   /* .. or can free a page, */
                        return ptr;                         /* don't do anything. */
 804b08a:	8b 45 08             	mov    0x8(%ebp),%eax
 804b08d:	e9 59 01 00 00       	jmp    804b1eb <irealloc+0x26b>
                }

        } else if (*mp >= MALLOC_MAGIC) {           /* Chunk allocation */
 804b092:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b095:	8b 00                	mov    (%eax),%eax
 804b097:	83 f8 03             	cmp    $0x3,%eax
 804b09a:	0f 86 cc 00 00 00    	jbe    804b16c <irealloc+0x1ec>

                /* Check the pointer for sane values */
                if (((u_long)ptr & ((*mp)->size - 1))) {
 804b0a0:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b0a3:	8b 00                	mov    (%eax),%eax
 804b0a5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804b0a9:	0f b7 c0             	movzwl %ax,%eax
 804b0ac:	83 e8 01             	sub    $0x1,%eax
 804b0af:	89 c2                	mov    %eax,%edx
 804b0b1:	8b 45 08             	mov    0x8(%ebp),%eax
 804b0b4:	21 d0                	and    %edx,%eax
 804b0b6:	85 c0                	test   %eax,%eax
 804b0b8:	74 18                	je     804b0d2 <irealloc+0x152>
                        wrtwarning("modified (chunk-) pointer.\n");
 804b0ba:	8d 83 d2 d6 ff ff    	lea    -0x292e(%ebx),%eax
 804b0c0:	89 04 24             	mov    %eax,(%esp)
 804b0c3:	e8 2f f0 ff ff       	call   804a0f7 <wrtwarning>
                        return 0;
 804b0c8:	b8 00 00 00 00       	mov    $0x0,%eax
 804b0cd:	e9 19 01 00 00       	jmp    804b1eb <irealloc+0x26b>
                }

                /* Find the chunk index in the page */
                i = ((u_long)ptr & malloc_pagemask) >> (*mp)->shift;
 804b0d2:	8b 45 08             	mov    0x8(%ebp),%eax
 804b0d5:	89 c2                	mov    %eax,%edx
 804b0d7:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
 804b0dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b0e0:	8b 00                	mov    (%eax),%eax
 804b0e2:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804b0e6:	0f b7 c0             	movzwl %ax,%eax
 804b0e9:	89 d6                	mov    %edx,%esi
 804b0eb:	89 c1                	mov    %eax,%ecx
 804b0ed:	d3 ee                	shr    %cl,%esi
 804b0ef:	89 f0                	mov    %esi,%eax
 804b0f1:	89 45 d8             	mov    %eax,-0x28(%ebp)

                /* Verify that it isn't a free chunk already */
                if ((*mp)->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804b0f4:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b0f7:	8b 00                	mov    (%eax),%eax
 804b0f9:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804b0fc:	c1 ea 05             	shr    $0x5,%edx
 804b0ff:	83 c2 04             	add    $0x4,%edx
 804b102:	8b 14 90             	mov    (%eax,%edx,4),%edx
 804b105:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804b108:	83 e0 1f             	and    $0x1f,%eax
 804b10b:	be 01 00 00 00       	mov    $0x1,%esi
 804b110:	89 f7                	mov    %esi,%edi
 804b112:	89 c1                	mov    %eax,%ecx
 804b114:	d3 e7                	shl    %cl,%edi
 804b116:	89 f8                	mov    %edi,%eax
 804b118:	21 d0                	and    %edx,%eax
 804b11a:	85 c0                	test   %eax,%eax
 804b11c:	74 18                	je     804b136 <irealloc+0x1b6>
                        wrtwarning("chunk is already free.\n");
 804b11e:	8d 83 ee d6 ff ff    	lea    -0x2912(%ebx),%eax
 804b124:	89 04 24             	mov    %eax,(%esp)
 804b127:	e8 cb ef ff ff       	call   804a0f7 <wrtwarning>
                        return 0;
 804b12c:	b8 00 00 00 00       	mov    $0x0,%eax
 804b131:	e9 b5 00 00 00       	jmp    804b1eb <irealloc+0x26b>
                }

                osize = (*mp)->size;
 804b136:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b139:	8b 00                	mov    (%eax),%eax
 804b13b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804b13f:	0f b7 c0             	movzwl %ax,%eax
 804b142:	89 45 e4             	mov    %eax,-0x1c(%ebp)

                if (!malloc_realloc &&          /* Unless we have to, */
 804b145:	8b 83 b0 04 00 00    	mov    0x4b0(%ebx),%eax
 804b14b:	85 c0                	test   %eax,%eax
 804b14d:	75 32                	jne    804b181 <irealloc+0x201>
 804b14f:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b152:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804b155:	73 2a                	jae    804b181 <irealloc+0x201>
                    size < osize &&               /* ..or are too small, */
                    (size > osize / 2 ||          /* ..or could use a smaller size, */
 804b157:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b15a:	d1 e8                	shr    %eax
                }

                osize = (*mp)->size;

                if (!malloc_realloc &&          /* Unless we have to, */
                    size < osize &&               /* ..or are too small, */
 804b15c:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804b15f:	72 06                	jb     804b167 <irealloc+0x1e7>
                    (size > osize / 2 ||          /* ..or could use a smaller size, */
 804b161:	83 7d e4 10          	cmpl   $0x10,-0x1c(%ebp)
 804b165:	75 1a                	jne    804b181 <irealloc+0x201>
                     osize == malloc_minsize)) {   /* ..(if there is one) */
                        return ptr;                 /* ..Don't do anything */
 804b167:	8b 45 08             	mov    0x8(%ebp),%eax
 804b16a:	eb 7f                	jmp    804b1eb <irealloc+0x26b>
                }

        } else {
                wrtwarning("pointer to wrong page.\n");
 804b16c:	8d 83 06 d7 ff ff    	lea    -0x28fa(%ebx),%eax
 804b172:	89 04 24             	mov    %eax,(%esp)
 804b175:	e8 7d ef ff ff       	call   804a0f7 <wrtwarning>
                return 0;
 804b17a:	b8 00 00 00 00       	mov    $0x0,%eax
 804b17f:	eb 6a                	jmp    804b1eb <irealloc+0x26b>
        }

        p = imalloc(size);
 804b181:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b184:	89 04 24             	mov    %eax,(%esp)
 804b187:	e8 3e fd ff ff       	call   804aeca <imalloc>
 804b18c:	89 45 d4             	mov    %eax,-0x2c(%ebp)

        if (p) {
 804b18f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804b193:	74 53                	je     804b1e8 <irealloc+0x268>
                /* copy the lesser of the two sizes, and free the old one */
                if (!size || !osize)
 804b195:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b199:	74 42                	je     804b1dd <irealloc+0x25d>
 804b19b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804b19f:	74 3c                	je     804b1dd <irealloc+0x25d>
                        ;
                else if (osize < size)
 804b1a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b1a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804b1a7:	73 1b                	jae    804b1c4 <irealloc+0x244>
                        memcpy(p, ptr, osize);
 804b1a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b1ac:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b1b0:	8b 45 08             	mov    0x8(%ebp),%eax
 804b1b3:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b1b7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b1ba:	89 04 24             	mov    %eax,(%esp)
 804b1bd:	e8 b4 18 00 00       	call   804ca76 <memcpy>
 804b1c2:	eb 19                	jmp    804b1dd <irealloc+0x25d>
                else
                        memcpy(p, ptr, size);
 804b1c4:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b1c7:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b1cb:	8b 45 08             	mov    0x8(%ebp),%eax
 804b1ce:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b1d2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b1d5:	89 04 24             	mov    %eax,(%esp)
 804b1d8:	e8 99 18 00 00       	call   804ca76 <memcpy>
                ifree(ptr);
 804b1dd:	8b 45 08             	mov    0x8(%ebp),%eax
 804b1e0:	89 04 24             	mov    %eax,(%esp)
 804b1e3:	e8 36 06 00 00       	call   804b81e <ifree>
        }
        return p;
 804b1e8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
}
 804b1eb:	83 c4 3c             	add    $0x3c,%esp
 804b1ee:	5b                   	pop    %ebx
 804b1ef:	5e                   	pop    %esi
 804b1f0:	5f                   	pop    %edi
 804b1f1:	5d                   	pop    %ebp
 804b1f2:	c3                   	ret    

0804b1f3 <free_pages>:
 * Free a sequence of pages
 */

static __inline__ void
free_pages(void *ptr, int index, struct pginfo *info)
{
 804b1f3:	55                   	push   %ebp
 804b1f4:	89 e5                	mov    %esp,%ebp
 804b1f6:	53                   	push   %ebx
 804b1f7:	83 ec 34             	sub    $0x34,%esp
 804b1fa:	e8 66 d2 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804b1ff:	81 c3 ad 4f 00 00    	add    $0x4fad,%ebx
        unsigned int i;
        struct pgfree *pf, *pt = 0;
 804b205:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
        u_long l;
        void *tail;

        if (info == MALLOC_FREE) {
 804b20c:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
 804b210:	75 13                	jne    804b225 <free_pages+0x32>
                wrtwarning("page is already free.\n");
 804b212:	8d 83 1e d7 ff ff    	lea    -0x28e2(%ebx),%eax
 804b218:	89 04 24             	mov    %eax,(%esp)
 804b21b:	e8 d7 ee ff ff       	call   804a0f7 <wrtwarning>
                return;
 804b220:	e9 d8 03 00 00       	jmp    804b5fd <free_pages+0x40a>
        }

        if (info != MALLOC_FIRST) {
 804b225:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
 804b229:	74 13                	je     804b23e <free_pages+0x4b>
                wrtwarning("pointer to wrong page.\n");
 804b22b:	8d 83 06 d7 ff ff    	lea    -0x28fa(%ebx),%eax
 804b231:	89 04 24             	mov    %eax,(%esp)
 804b234:	e8 be ee ff ff       	call   804a0f7 <wrtwarning>
                return;
 804b239:	e9 bf 03 00 00       	jmp    804b5fd <free_pages+0x40a>
        }

        if ((u_long)ptr & malloc_pagemask) {
 804b23e:	8b 45 08             	mov    0x8(%ebp),%eax
 804b241:	25 ff 0f 00 00       	and    $0xfff,%eax
 804b246:	85 c0                	test   %eax,%eax
 804b248:	74 13                	je     804b25d <free_pages+0x6a>
                wrtwarning("modified (page-) pointer.\n");
 804b24a:	8d 83 b7 d6 ff ff    	lea    -0x2949(%ebx),%eax
 804b250:	89 04 24             	mov    %eax,(%esp)
 804b253:	e8 9f ee ff ff       	call   804a0f7 <wrtwarning>
                return;
 804b258:	e9 a0 03 00 00       	jmp    804b5fd <free_pages+0x40a>
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
 804b25d:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804b263:	8b 55 0c             	mov    0xc(%ebp),%edx
 804b266:	c1 e2 02             	shl    $0x2,%edx
 804b269:	01 d0                	add    %edx,%eax
 804b26b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804b271:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
 804b278:	eb 1b                	jmp    804b295 <free_pages+0xa2>
                page_dir[index + i] = MALLOC_FREE;
 804b27a:	8b 93 8c 04 00 00    	mov    0x48c(%ebx),%edx
 804b280:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b283:	03 45 f4             	add    -0xc(%ebp),%eax
 804b286:	c1 e0 02             	shl    $0x2,%eax
 804b289:	01 d0                	add    %edx,%eax
 804b28b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804b291:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 804b295:	8b 93 8c 04 00 00    	mov    0x48c(%ebx),%edx
 804b29b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b29e:	03 45 f4             	add    -0xc(%ebp),%eax
 804b2a1:	c1 e0 02             	shl    $0x2,%eax
 804b2a4:	01 d0                	add    %edx,%eax
 804b2a6:	8b 00                	mov    (%eax),%eax
 804b2a8:	83 f8 03             	cmp    $0x3,%eax
 804b2ab:	74 cd                	je     804b27a <free_pages+0x87>
                page_dir[index + i] = MALLOC_FREE;

        l = i << malloc_pageshift;
 804b2ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b2b0:	c1 e0 0c             	shl    $0xc,%eax
 804b2b3:	89 45 e8             	mov    %eax,-0x18(%ebp)

        if (malloc_junk)
 804b2b6:	8b 83 c4 04 00 00    	mov    0x4c4(%ebx),%eax
 804b2bc:	85 c0                	test   %eax,%eax
 804b2be:	74 1a                	je     804b2da <free_pages+0xe7>
                memset(ptr, SOME_JUNK, l);
 804b2c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b2c3:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b2c7:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804b2ce:	00 
 804b2cf:	8b 45 08             	mov    0x8(%ebp),%eax
 804b2d2:	89 04 24             	mov    %eax,(%esp)
 804b2d5:	e8 ea 18 00 00       	call   804cbc4 <memset>
#ifdef HAS_MADVISE
        if (malloc_hint)
                madvise(ptr, l, MADV_FREE);
#endif

        tail = (char *)ptr + l;
 804b2da:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b2dd:	8b 55 08             	mov    0x8(%ebp),%edx
 804b2e0:	01 d0                	add    %edx,%eax
 804b2e2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        /* add to free-list */
        if (!px)
 804b2e5:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b2eb:	85 c0                	test   %eax,%eax
 804b2ed:	75 12                	jne    804b301 <free_pages+0x10e>
                px = imalloc(sizeof * pt);      /* This cannot fail... */
 804b2ef:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 804b2f6:	e8 cf fb ff ff       	call   804aeca <imalloc>
 804b2fb:	89 83 cc 04 00 00    	mov    %eax,0x4cc(%ebx)
        px->page = ptr;
 804b301:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b307:	8b 55 08             	mov    0x8(%ebp),%edx
 804b30a:	89 50 08             	mov    %edx,0x8(%eax)
        px->end =  tail;
 804b30d:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b313:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804b316:	89 50 0c             	mov    %edx,0xc(%eax)
        px->size = l;
 804b319:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b31f:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804b322:	89 50 10             	mov    %edx,0x10(%eax)
        if (!free_list.next) {
 804b325:	8b 83 94 04 00 00    	mov    0x494(%ebx),%eax
 804b32b:	85 c0                	test   %eax,%eax
 804b32d:	75 41                	jne    804b370 <free_pages+0x17d>

                /* Nothing on free list, put this at head */
                px->next = free_list.next;
 804b32f:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b335:	8b 93 94 04 00 00    	mov    0x494(%ebx),%edx
 804b33b:	89 10                	mov    %edx,(%eax)
                px->prev = &free_list;
 804b33d:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b343:	8d 93 94 04 00 00    	lea    0x494(%ebx),%edx
 804b349:	89 50 04             	mov    %edx,0x4(%eax)
                free_list.next = px;
 804b34c:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b352:	89 83 94 04 00 00    	mov    %eax,0x494(%ebx)
                pf = px;
 804b358:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b35e:	89 45 f0             	mov    %eax,-0x10(%ebp)
                px = 0;
 804b361:	c7 83 cc 04 00 00 00 	movl   $0x0,0x4cc(%ebx)
 804b368:	00 00 00 
 804b36b:	e9 a2 01 00 00       	jmp    804b512 <free_pages+0x31f>

        } else {

                /* Find the right spot, leave pf pointing to the modified entry. */
                tail = (char *)ptr + l;
 804b370:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b373:	8b 55 08             	mov    0x8(%ebp),%edx
 804b376:	01 d0                	add    %edx,%eax
 804b378:	89 45 e4             	mov    %eax,-0x1c(%ebp)

                for (pf = free_list.next; pf->end < ptr && pf->next; pf = pf->next)
 804b37b:	8b 83 94 04 00 00    	mov    0x494(%ebx),%eax
 804b381:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804b384:	eb 08                	jmp    804b38e <free_pages+0x19b>
 804b386:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b389:	8b 00                	mov    (%eax),%eax
 804b38b:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804b38e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b391:	8b 40 0c             	mov    0xc(%eax),%eax
 804b394:	3b 45 08             	cmp    0x8(%ebp),%eax
 804b397:	73 09                	jae    804b3a2 <free_pages+0x1af>
 804b399:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b39c:	8b 00                	mov    (%eax),%eax
 804b39e:	85 c0                	test   %eax,%eax
 804b3a0:	75 e4                	jne    804b386 <free_pages+0x193>
                        ; /* Race ahead here */

                if (pf->page > tail) {
 804b3a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b3a5:	8b 40 08             	mov    0x8(%eax),%eax
 804b3a8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804b3ab:	76 4f                	jbe    804b3fc <free_pages+0x209>
                        /* Insert before entry */
                        px->next = pf;
 804b3ad:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b3b3:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804b3b6:	89 10                	mov    %edx,(%eax)
                        px->prev = pf->prev;
 804b3b8:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b3be:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804b3c1:	8b 52 04             	mov    0x4(%edx),%edx
 804b3c4:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev = px;
 804b3c7:	8b 93 cc 04 00 00    	mov    0x4cc(%ebx),%edx
 804b3cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b3d0:	89 50 04             	mov    %edx,0x4(%eax)
                        px->prev->next = px;
 804b3d3:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b3d9:	8b 40 04             	mov    0x4(%eax),%eax
 804b3dc:	8b 93 cc 04 00 00    	mov    0x4cc(%ebx),%edx
 804b3e2:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804b3e4:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b3ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        px = 0;
 804b3ed:	c7 83 cc 04 00 00 00 	movl   $0x0,0x4cc(%ebx)
 804b3f4:	00 00 00 
 804b3f7:	e9 16 01 00 00       	jmp    804b512 <free_pages+0x31f>
                } else if (pf->end == ptr) {
 804b3fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b3ff:	8b 40 0c             	mov    0xc(%eax),%eax
 804b402:	3b 45 08             	cmp    0x8(%ebp),%eax
 804b405:	0f 85 91 00 00 00    	jne    804b49c <free_pages+0x2a9>
                        /* Append to the previous entry */
                        pf->end = (char *)pf->end + l;
 804b40b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b40e:	8b 40 0c             	mov    0xc(%eax),%eax
 804b411:	89 c2                	mov    %eax,%edx
 804b413:	03 55 e8             	add    -0x18(%ebp),%edx
 804b416:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b419:	89 50 0c             	mov    %edx,0xc(%eax)
                        pf->size += l;
 804b41c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b41f:	8b 40 10             	mov    0x10(%eax),%eax
 804b422:	89 c2                	mov    %eax,%edx
 804b424:	03 55 e8             	add    -0x18(%ebp),%edx
 804b427:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b42a:	89 50 10             	mov    %edx,0x10(%eax)
                        if (pf->next && pf->end == pf->next->page) {
 804b42d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b430:	8b 00                	mov    (%eax),%eax
 804b432:	85 c0                	test   %eax,%eax
 804b434:	0f 84 d8 00 00 00    	je     804b512 <free_pages+0x31f>
 804b43a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b43d:	8b 50 0c             	mov    0xc(%eax),%edx
 804b440:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b443:	8b 00                	mov    (%eax),%eax
 804b445:	8b 40 08             	mov    0x8(%eax),%eax
 804b448:	39 c2                	cmp    %eax,%edx
 804b44a:	0f 85 c2 00 00 00    	jne    804b512 <free_pages+0x31f>
                                /* And collapse the next too. */
                                pt = pf->next;
 804b450:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b453:	8b 00                	mov    (%eax),%eax
 804b455:	89 45 ec             	mov    %eax,-0x14(%ebp)
                                pf->end = pt->end;
 804b458:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b45b:	8b 50 0c             	mov    0xc(%eax),%edx
 804b45e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b461:	89 50 0c             	mov    %edx,0xc(%eax)
                                pf->size += pt->size;
 804b464:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b467:	8b 50 10             	mov    0x10(%eax),%edx
 804b46a:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b46d:	8b 40 10             	mov    0x10(%eax),%eax
 804b470:	01 c2                	add    %eax,%edx
 804b472:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b475:	89 50 10             	mov    %edx,0x10(%eax)
                                pf->next = pt->next;
 804b478:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b47b:	8b 10                	mov    (%eax),%edx
 804b47d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b480:	89 10                	mov    %edx,(%eax)
                                if (pf->next)
 804b482:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b485:	8b 00                	mov    (%eax),%eax
 804b487:	85 c0                	test   %eax,%eax
 804b489:	0f 84 83 00 00 00    	je     804b512 <free_pages+0x31f>
                                        pf->next->prev = pf;
 804b48f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b492:	8b 00                	mov    (%eax),%eax
 804b494:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804b497:	89 50 04             	mov    %edx,0x4(%eax)
 804b49a:	eb 76                	jmp    804b512 <free_pages+0x31f>
                        }
                } else if (pf->page == tail) {
 804b49c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b49f:	8b 40 08             	mov    0x8(%eax),%eax
 804b4a2:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804b4a5:	75 1c                	jne    804b4c3 <free_pages+0x2d0>
                        /* Prepend to entry */
                        pf->size += l;
 804b4a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b4aa:	8b 40 10             	mov    0x10(%eax),%eax
 804b4ad:	89 c2                	mov    %eax,%edx
 804b4af:	03 55 e8             	add    -0x18(%ebp),%edx
 804b4b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b4b5:	89 50 10             	mov    %edx,0x10(%eax)
                        pf->page = ptr;
 804b4b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b4bb:	8b 55 08             	mov    0x8(%ebp),%edx
 804b4be:	89 50 08             	mov    %edx,0x8(%eax)
 804b4c1:	eb 4f                	jmp    804b512 <free_pages+0x31f>
                } else if (!pf->next) {
 804b4c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b4c6:	8b 00                	mov    (%eax),%eax
 804b4c8:	85 c0                	test   %eax,%eax
 804b4ca:	75 38                	jne    804b504 <free_pages+0x311>
                        /* Append at tail of chain */
                        px->next = 0;
 804b4cc:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b4d2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                        px->prev = pf;
 804b4d8:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b4de:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804b4e1:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->next = px;
 804b4e4:	8b 93 cc 04 00 00    	mov    0x4cc(%ebx),%edx
 804b4ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b4ed:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804b4ef:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b4f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        px = 0;
 804b4f8:	c7 83 cc 04 00 00 00 	movl   $0x0,0x4cc(%ebx)
 804b4ff:	00 00 00 
 804b502:	eb 0e                	jmp    804b512 <free_pages+0x31f>
                } else {
                        wrterror("freelist is destroyed.\n");
 804b504:	8d 83 35 d7 ff ff    	lea    -0x28cb(%ebx),%eax
 804b50a:	89 04 24             	mov    %eax,(%esp)
 804b50d:	e8 1a eb ff ff       	call   804a02c <wrterror>
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804b512:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b515:	8b 00                	mov    (%eax),%eax
 804b517:	85 c0                	test   %eax,%eax
 804b519:	0f 85 cd 00 00 00    	jne    804b5ec <free_pages+0x3f9>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804b51f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b522:	8b 50 10             	mov    0x10(%eax),%edx
 804b525:	8b 83 34 01 00 00    	mov    0x134(%ebx),%eax
                        wrterror("freelist is destroyed.\n");
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804b52b:	39 c2                	cmp    %eax,%edx
 804b52d:	0f 86 b9 00 00 00    	jbe    804b5ec <free_pages+0x3f9>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804b533:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b536:	8b 50 0c             	mov    0xc(%eax),%edx
 804b539:	8b 83 c8 04 00 00    	mov    0x4c8(%ebx),%eax
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804b53f:	39 c2                	cmp    %eax,%edx
 804b541:	0f 85 a5 00 00 00    	jne    804b5ec <free_pages+0x3f9>
            pf->end == malloc_brk &&                  /* ..and none behind us, */
            malloc_brk == sbrk(0)) {                  /* ..and it's OK to do... */
 804b547:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b54e:	e8 5d cf ff ff       	call   80484b0 <sbrk>
 804b553:	8b 93 c8 04 00 00    	mov    0x4c8(%ebx),%edx
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804b559:	39 d0                	cmp    %edx,%eax
 804b55b:	0f 85 8b 00 00 00    	jne    804b5ec <free_pages+0x3f9>

                /*
                 * Keep the cache intact.  Notice that the '>' above guarantees that
                 * the pf will always have at least one page afterwards.
                 */
                pf->end = (char *)pf->page + malloc_cache;
 804b561:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b564:	8b 50 08             	mov    0x8(%eax),%edx
 804b567:	8b 83 34 01 00 00    	mov    0x134(%ebx),%eax
 804b56d:	01 c2                	add    %eax,%edx
 804b56f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b572:	89 50 0c             	mov    %edx,0xc(%eax)
                pf->size = malloc_cache;
 804b575:	8b 93 34 01 00 00    	mov    0x134(%ebx),%edx
 804b57b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b57e:	89 50 10             	mov    %edx,0x10(%eax)

                brk(pf->end);
 804b581:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b584:	8b 40 0c             	mov    0xc(%eax),%eax
 804b587:	89 04 24             	mov    %eax,(%esp)
 804b58a:	e8 f1 cf ff ff       	call   8048580 <brk>
                malloc_brk = pf->end;
 804b58f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b592:	8b 40 0c             	mov    0xc(%eax),%eax
 804b595:	89 83 c8 04 00 00    	mov    %eax,0x4c8(%ebx)

                index = ptr2index(pf->end);
 804b59b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b59e:	8b 40 0c             	mov    0xc(%eax),%eax
 804b5a1:	89 c2                	mov    %eax,%edx
 804b5a3:	c1 ea 0c             	shr    $0xc,%edx
 804b5a6:	8b 83 84 04 00 00    	mov    0x484(%ebx),%eax
 804b5ac:	89 d1                	mov    %edx,%ecx
 804b5ae:	29 c1                	sub    %eax,%ecx
 804b5b0:	89 c8                	mov    %ecx,%eax
 804b5b2:	89 45 0c             	mov    %eax,0xc(%ebp)
                last_index = index - 1;
 804b5b5:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b5b8:	83 e8 01             	sub    $0x1,%eax
 804b5bb:	89 83 88 04 00 00    	mov    %eax,0x488(%ebx)

                for (i = index; i <= last_index;)
 804b5c1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b5c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b5c7:	eb 18                	jmp    804b5e1 <free_pages+0x3ee>
                        page_dir[i++] = MALLOC_NOT_MINE;
 804b5c9:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804b5cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804b5d2:	c1 e2 02             	shl    $0x2,%edx
 804b5d5:	01 d0                	add    %edx,%eax
 804b5d7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
 804b5dd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                malloc_brk = pf->end;

                index = ptr2index(pf->end);
                last_index = index - 1;

                for (i = index; i <= last_index;)
 804b5e1:	8b 83 88 04 00 00    	mov    0x488(%ebx),%eax
 804b5e7:	39 45 f4             	cmp    %eax,-0xc(%ebp)
 804b5ea:	76 dd                	jbe    804b5c9 <free_pages+0x3d6>
                        page_dir[i++] = MALLOC_NOT_MINE;

                /* XXX: We could realloc/shrink the pagedir here I guess. */
        }
        if (pt)
 804b5ec:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804b5f0:	74 0b                	je     804b5fd <free_pages+0x40a>
                ifree(pt);
 804b5f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b5f5:	89 04 24             	mov    %eax,(%esp)
 804b5f8:	e8 21 02 00 00       	call   804b81e <ifree>
}
 804b5fd:	83 c4 34             	add    $0x34,%esp
 804b600:	5b                   	pop    %ebx
 804b601:	5d                   	pop    %ebp
 804b602:	c3                   	ret    

0804b603 <free_bytes>:
 * Free a chunk, and possibly the page it's on, if the page becomes empty.
 */

static __inline__ void
free_bytes(void *ptr, int index, struct pginfo *info)
{
 804b603:	55                   	push   %ebp
 804b604:	89 e5                	mov    %esp,%ebp
 804b606:	57                   	push   %edi
 804b607:	56                   	push   %esi
 804b608:	53                   	push   %ebx
 804b609:	83 ec 3c             	sub    $0x3c,%esp
 804b60c:	e8 54 ce ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804b611:	81 c3 9b 4b 00 00    	add    $0x4b9b,%ebx
        int i;
        struct pginfo **mp;
        void *vp;

        /* Find the chunk number on the page */
        i = ((u_long)ptr & malloc_pagemask) >> info->shift;
 804b617:	8b 45 08             	mov    0x8(%ebp),%eax
 804b61a:	89 c2                	mov    %eax,%edx
 804b61c:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
 804b622:	8b 45 10             	mov    0x10(%ebp),%eax
 804b625:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804b629:	0f b7 c0             	movzwl %ax,%eax
 804b62c:	89 d6                	mov    %edx,%esi
 804b62e:	89 c1                	mov    %eax,%ecx
 804b630:	d3 ee                	shr    %cl,%esi
 804b632:	89 f0                	mov    %esi,%eax
 804b634:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if (((u_long)ptr & (info->size - 1))) {
 804b637:	8b 45 10             	mov    0x10(%ebp),%eax
 804b63a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804b63e:	0f b7 c0             	movzwl %ax,%eax
 804b641:	83 e8 01             	sub    $0x1,%eax
 804b644:	89 c2                	mov    %eax,%edx
 804b646:	8b 45 08             	mov    0x8(%ebp),%eax
 804b649:	21 d0                	and    %edx,%eax
 804b64b:	85 c0                	test   %eax,%eax
 804b64d:	74 13                	je     804b662 <free_bytes+0x5f>
                wrtwarning("modified (chunk-) pointer.\n");
 804b64f:	8d 83 d2 d6 ff ff    	lea    -0x292e(%ebx),%eax
 804b655:	89 04 24             	mov    %eax,(%esp)
 804b658:	e8 9a ea ff ff       	call   804a0f7 <wrtwarning>
                return;
 804b65d:	e9 b4 01 00 00       	jmp    804b816 <free_bytes+0x213>
        }

        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804b662:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b665:	89 c2                	mov    %eax,%edx
 804b667:	c1 ea 05             	shr    $0x5,%edx
 804b66a:	8b 45 10             	mov    0x10(%ebp),%eax
 804b66d:	83 c2 04             	add    $0x4,%edx
 804b670:	8b 14 90             	mov    (%eax,%edx,4),%edx
 804b673:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b676:	83 e0 1f             	and    $0x1f,%eax
 804b679:	be 01 00 00 00       	mov    $0x1,%esi
 804b67e:	89 f7                	mov    %esi,%edi
 804b680:	89 c1                	mov    %eax,%ecx
 804b682:	d3 e7                	shl    %cl,%edi
 804b684:	89 f8                	mov    %edi,%eax
 804b686:	21 d0                	and    %edx,%eax
 804b688:	85 c0                	test   %eax,%eax
 804b68a:	74 13                	je     804b69f <free_bytes+0x9c>
                wrtwarning("chunk is already free.\n");
 804b68c:	8d 83 ee d6 ff ff    	lea    -0x2912(%ebx),%eax
 804b692:	89 04 24             	mov    %eax,(%esp)
 804b695:	e8 5d ea ff ff       	call   804a0f7 <wrtwarning>
                return;
 804b69a:	e9 77 01 00 00       	jmp    804b816 <free_bytes+0x213>
        }

        if (malloc_junk)
 804b69f:	8b 83 c4 04 00 00    	mov    0x4c4(%ebx),%eax
 804b6a5:	85 c0                	test   %eax,%eax
 804b6a7:	74 21                	je     804b6ca <free_bytes+0xc7>
                memset(ptr, SOME_JUNK, info->size);
 804b6a9:	8b 45 10             	mov    0x10(%ebp),%eax
 804b6ac:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804b6b0:	0f b7 c0             	movzwl %ax,%eax
 804b6b3:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b6b7:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804b6be:	00 
 804b6bf:	8b 45 08             	mov    0x8(%ebp),%eax
 804b6c2:	89 04 24             	mov    %eax,(%esp)
 804b6c5:	e8 fa 14 00 00       	call   804cbc4 <memset>

        info->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804b6ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b6cd:	c1 e8 05             	shr    $0x5,%eax
 804b6d0:	8b 55 10             	mov    0x10(%ebp),%edx
 804b6d3:	8d 48 04             	lea    0x4(%eax),%ecx
 804b6d6:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 804b6d9:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804b6dc:	83 e2 1f             	and    $0x1f,%edx
 804b6df:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
 804b6e6:	8b 7d d4             	mov    -0x2c(%ebp),%edi
 804b6e9:	89 d1                	mov    %edx,%ecx
 804b6eb:	d3 e7                	shl    %cl,%edi
 804b6ed:	89 fa                	mov    %edi,%edx
 804b6ef:	89 f1                	mov    %esi,%ecx
 804b6f1:	09 d1                	or     %edx,%ecx
 804b6f3:	8b 55 10             	mov    0x10(%ebp),%edx
 804b6f6:	83 c0 04             	add    $0x4,%eax
 804b6f9:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
        info->free++;
 804b6fc:	8b 45 10             	mov    0x10(%ebp),%eax
 804b6ff:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804b703:	8d 50 01             	lea    0x1(%eax),%edx
 804b706:	8b 45 10             	mov    0x10(%ebp),%eax
 804b709:	66 89 50 0c          	mov    %dx,0xc(%eax)

        mp = page_dir + info->shift;
 804b70d:	8b 93 8c 04 00 00    	mov    0x48c(%ebx),%edx
 804b713:	8b 45 10             	mov    0x10(%ebp),%eax
 804b716:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804b71a:	0f b7 c0             	movzwl %ax,%eax
 804b71d:	c1 e0 02             	shl    $0x2,%eax
 804b720:	01 d0                	add    %edx,%eax
 804b722:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if (info->free == 1) {
 804b725:	8b 45 10             	mov    0x10(%ebp),%eax
 804b728:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804b72c:	66 83 f8 01          	cmp    $0x1,%ax
 804b730:	75 61                	jne    804b793 <free_bytes+0x190>

                /* Page became non-full */

                mp = page_dir + info->shift;
 804b732:	8b 93 8c 04 00 00    	mov    0x48c(%ebx),%edx
 804b738:	8b 45 10             	mov    0x10(%ebp),%eax
 804b73b:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804b73f:	0f b7 c0             	movzwl %ax,%eax
 804b742:	c1 e0 02             	shl    $0x2,%eax
 804b745:	01 d0                	add    %edx,%eax
 804b747:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804b74a:	eb 08                	jmp    804b754 <free_bytes+0x151>
                        mp = &(*mp)->next;
 804b74c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b74f:	8b 00                	mov    (%eax),%eax
 804b751:	89 45 e4             	mov    %eax,-0x1c(%ebp)

                /* Page became non-full */

                mp = page_dir + info->shift;
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804b754:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b757:	8b 00                	mov    (%eax),%eax
 804b759:	85 c0                	test   %eax,%eax
 804b75b:	74 1f                	je     804b77c <free_bytes+0x179>
 804b75d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b760:	8b 00                	mov    (%eax),%eax
 804b762:	8b 00                	mov    (%eax),%eax
 804b764:	85 c0                	test   %eax,%eax
 804b766:	74 14                	je     804b77c <free_bytes+0x179>
 804b768:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b76b:	8b 00                	mov    (%eax),%eax
 804b76d:	8b 00                	mov    (%eax),%eax
 804b76f:	8b 50 04             	mov    0x4(%eax),%edx
 804b772:	8b 45 10             	mov    0x10(%ebp),%eax
 804b775:	8b 40 04             	mov    0x4(%eax),%eax
 804b778:	39 c2                	cmp    %eax,%edx
 804b77a:	72 d0                	jb     804b74c <free_bytes+0x149>
                        mp = &(*mp)->next;
                info->next = *mp;
 804b77c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b77f:	8b 10                	mov    (%eax),%edx
 804b781:	8b 45 10             	mov    0x10(%ebp),%eax
 804b784:	89 10                	mov    %edx,(%eax)
                *mp = info;
 804b786:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b789:	8b 55 10             	mov    0x10(%ebp),%edx
 804b78c:	89 10                	mov    %edx,(%eax)
                return;
 804b78e:	e9 83 00 00 00       	jmp    804b816 <free_bytes+0x213>
        }

        if (info->free != info->total)
 804b793:	8b 45 10             	mov    0x10(%ebp),%eax
 804b796:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804b79a:	8b 45 10             	mov    0x10(%ebp),%eax
 804b79d:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804b7a1:	66 39 c2             	cmp    %ax,%dx
 804b7a4:	74 0c                	je     804b7b2 <free_bytes+0x1af>
                return;
 804b7a6:	eb 6e                	jmp    804b816 <free_bytes+0x213>

        /* Find & remove this page in the queue */
        while (*mp != info) {
                mp = &((*mp)->next);
 804b7a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b7ab:	8b 00                	mov    (%eax),%eax
 804b7ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804b7b0:	eb 01                	jmp    804b7b3 <free_bytes+0x1b0>

        if (info->free != info->total)
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
 804b7b2:	90                   	nop
 804b7b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b7b6:	8b 00                	mov    (%eax),%eax
 804b7b8:	3b 45 10             	cmp    0x10(%ebp),%eax
 804b7bb:	75 eb                	jne    804b7a8 <free_bytes+0x1a5>
#ifdef EXTRA_SANITY
                if (!*mp)
                        wrterror("(ES): Not on queue\n");
#endif /* EXTRA_SANITY */
        }
        *mp = info->next;
 804b7bd:	8b 45 10             	mov    0x10(%ebp),%eax
 804b7c0:	8b 10                	mov    (%eax),%edx
 804b7c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b7c5:	89 10                	mov    %edx,(%eax)

        /* Free the page & the info structure if need be */
        page_dir[ptr2index(info->page)] = MALLOC_FIRST;
 804b7c7:	8b 93 8c 04 00 00    	mov    0x48c(%ebx),%edx
 804b7cd:	8b 45 10             	mov    0x10(%ebp),%eax
 804b7d0:	8b 40 04             	mov    0x4(%eax),%eax
 804b7d3:	89 c1                	mov    %eax,%ecx
 804b7d5:	c1 e9 0c             	shr    $0xc,%ecx
 804b7d8:	8b 83 84 04 00 00    	mov    0x484(%ebx),%eax
 804b7de:	89 ce                	mov    %ecx,%esi
 804b7e0:	29 c6                	sub    %eax,%esi
 804b7e2:	89 f0                	mov    %esi,%eax
 804b7e4:	c1 e0 02             	shl    $0x2,%eax
 804b7e7:	01 d0                	add    %edx,%eax
 804b7e9:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        vp = info->page;            /* Order is important ! */
 804b7ef:	8b 45 10             	mov    0x10(%ebp),%eax
 804b7f2:	8b 40 04             	mov    0x4(%eax),%eax
 804b7f5:	89 45 dc             	mov    %eax,-0x24(%ebp)
        if (vp != (void *)info)
 804b7f8:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b7fb:	3b 45 10             	cmp    0x10(%ebp),%eax
 804b7fe:	74 0b                	je     804b80b <free_bytes+0x208>
                ifree(info);
 804b800:	8b 45 10             	mov    0x10(%ebp),%eax
 804b803:	89 04 24             	mov    %eax,(%esp)
 804b806:	e8 13 00 00 00       	call   804b81e <ifree>
        ifree(vp);
 804b80b:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b80e:	89 04 24             	mov    %eax,(%esp)
 804b811:	e8 08 00 00 00       	call   804b81e <ifree>
}
 804b816:	83 c4 3c             	add    $0x3c,%esp
 804b819:	5b                   	pop    %ebx
 804b81a:	5e                   	pop    %esi
 804b81b:	5f                   	pop    %edi
 804b81c:	5d                   	pop    %ebp
 804b81d:	c3                   	ret    

0804b81e <ifree>:

static void
ifree(void *ptr)
{
 804b81e:	55                   	push   %ebp
 804b81f:	89 e5                	mov    %esp,%ebp
 804b821:	57                   	push   %edi
 804b822:	56                   	push   %esi
 804b823:	53                   	push   %ebx
 804b824:	83 ec 6c             	sub    $0x6c,%esp
 804b827:	e8 39 cc ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804b82c:	81 c3 80 49 00 00    	add    $0x4980,%ebx
        struct pginfo *info;
        unsigned int index;

        /* This is legal */
        if (!ptr)
 804b832:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804b836:	0f 84 b9 06 00 00    	je     804bef5 <ifree+0x6d7>
                return;

        if (!malloc_started) {
 804b83c:	8b 83 7c 04 00 00    	mov    0x47c(%ebx),%eax
 804b842:	85 c0                	test   %eax,%eax
 804b844:	75 13                	jne    804b859 <ifree+0x3b>
                wrtwarning("malloc() has never been called.\n");
 804b846:	8d 83 50 d7 ff ff    	lea    -0x28b0(%ebx),%eax
 804b84c:	89 04 24             	mov    %eax,(%esp)
 804b84f:	e8 a3 e8 ff ff       	call   804a0f7 <wrtwarning>
                return;
 804b854:	e9 a3 06 00 00       	jmp    804befc <ifree+0x6de>
        }

        /* If we're already sinking, don't make matters any worse. */
        if (suicide)
 804b859:	8b 83 ac 04 00 00    	mov    0x4ac(%ebx),%eax
 804b85f:	85 c0                	test   %eax,%eax
 804b861:	0f 85 91 06 00 00    	jne    804bef8 <ifree+0x6da>
                return;

        index = ptr2index(ptr);
 804b867:	8b 45 08             	mov    0x8(%ebp),%eax
 804b86a:	89 c2                	mov    %eax,%edx
 804b86c:	c1 ea 0c             	shr    $0xc,%edx
 804b86f:	8b 83 84 04 00 00    	mov    0x484(%ebx),%eax
 804b875:	89 d1                	mov    %edx,%ecx
 804b877:	29 c1                	sub    %eax,%ecx
 804b879:	89 c8                	mov    %ecx,%eax
 804b87b:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if (index < malloc_pageshift) {
 804b87e:	83 7d e4 0b          	cmpl   $0xb,-0x1c(%ebp)
 804b882:	77 13                	ja     804b897 <ifree+0x79>
                wrtwarning("junk pointer, too low to make sense.\n");
 804b884:	8d 83 68 d6 ff ff    	lea    -0x2998(%ebx),%eax
 804b88a:	89 04 24             	mov    %eax,(%esp)
 804b88d:	e8 65 e8 ff ff       	call   804a0f7 <wrtwarning>
                return;
 804b892:	e9 65 06 00 00       	jmp    804befc <ifree+0x6de>
        }

        if (index > last_index) {
 804b897:	8b 83 88 04 00 00    	mov    0x488(%ebx),%eax
 804b89d:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
 804b8a0:	76 13                	jbe    804b8b5 <ifree+0x97>
                wrtwarning("junk pointer, too high to make sense.\n");
 804b8a2:	8d 83 90 d6 ff ff    	lea    -0x2970(%ebx),%eax
 804b8a8:	89 04 24             	mov    %eax,(%esp)
 804b8ab:	e8 47 e8 ff ff       	call   804a0f7 <wrtwarning>
                return;
 804b8b0:	e9 47 06 00 00       	jmp    804befc <ifree+0x6de>
        }

        info = page_dir[index];
 804b8b5:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804b8bb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804b8be:	c1 e2 02             	shl    $0x2,%edx
 804b8c1:	01 d0                	add    %edx,%eax
 804b8c3:	8b 00                	mov    (%eax),%eax
 804b8c5:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if (info < MALLOC_MAGIC)
 804b8c8:	83 7d e0 03          	cmpl   $0x3,-0x20(%ebp)
 804b8cc:	0f 87 13 04 00 00    	ja     804bce5 <ifree+0x4c7>
                free_pages(ptr, index, info);
 804b8d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b8d5:	8b 55 08             	mov    0x8(%ebp),%edx
 804b8d8:	89 55 dc             	mov    %edx,-0x24(%ebp)
 804b8db:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804b8de:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b8e1:	89 45 d4             	mov    %eax,-0x2c(%ebp)

static __inline__ void
free_pages(void *ptr, int index, struct pginfo *info)
{
        unsigned int i;
        struct pgfree *pf, *pt = 0;
 804b8e4:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
        u_long l;
        void *tail;

        if (info == MALLOC_FREE) {
 804b8eb:	83 7d d4 01          	cmpl   $0x1,-0x2c(%ebp)
 804b8ef:	75 13                	jne    804b904 <ifree+0xe6>
                wrtwarning("page is already free.\n");
 804b8f1:	8d 83 1e d7 ff ff    	lea    -0x28e2(%ebx),%eax
 804b8f7:	89 04 24             	mov    %eax,(%esp)
 804b8fa:	e8 f8 e7 ff ff       	call   804a0f7 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b8ff:	e9 f7 05 00 00       	jmp    804befb <ifree+0x6dd>
        if (info == MALLOC_FREE) {
                wrtwarning("page is already free.\n");
                return;
        }

        if (info != MALLOC_FIRST) {
 804b904:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
 804b908:	74 13                	je     804b91d <ifree+0xff>
                wrtwarning("pointer to wrong page.\n");
 804b90a:	8d 83 06 d7 ff ff    	lea    -0x28fa(%ebx),%eax
 804b910:	89 04 24             	mov    %eax,(%esp)
 804b913:	e8 df e7 ff ff       	call   804a0f7 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b918:	e9 de 05 00 00       	jmp    804befb <ifree+0x6dd>
        if (info != MALLOC_FIRST) {
                wrtwarning("pointer to wrong page.\n");
                return;
        }

        if ((u_long)ptr & malloc_pagemask) {
 804b91d:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b920:	25 ff 0f 00 00       	and    $0xfff,%eax
 804b925:	85 c0                	test   %eax,%eax
 804b927:	74 13                	je     804b93c <ifree+0x11e>
                wrtwarning("modified (page-) pointer.\n");
 804b929:	8d 83 b7 d6 ff ff    	lea    -0x2949(%ebx),%eax
 804b92f:	89 04 24             	mov    %eax,(%esp)
 804b932:	e8 c0 e7 ff ff       	call   804a0f7 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b937:	e9 bf 05 00 00       	jmp    804befb <ifree+0x6dd>
                wrtwarning("modified (page-) pointer.\n");
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
 804b93c:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804b942:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804b945:	c1 e2 02             	shl    $0x2,%edx
 804b948:	01 d0                	add    %edx,%eax
 804b94a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804b950:	c7 45 cc 01 00 00 00 	movl   $0x1,-0x34(%ebp)
 804b957:	eb 1b                	jmp    804b974 <ifree+0x156>
                page_dir[index + i] = MALLOC_FREE;
 804b959:	8b 93 8c 04 00 00    	mov    0x48c(%ebx),%edx
 804b95f:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804b962:	03 45 cc             	add    -0x34(%ebp),%eax
 804b965:	c1 e0 02             	shl    $0x2,%eax
 804b968:	01 d0                	add    %edx,%eax
 804b96a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804b970:	83 45 cc 01          	addl   $0x1,-0x34(%ebp)
 804b974:	8b 93 8c 04 00 00    	mov    0x48c(%ebx),%edx
 804b97a:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804b97d:	03 45 cc             	add    -0x34(%ebp),%eax
 804b980:	c1 e0 02             	shl    $0x2,%eax
 804b983:	01 d0                	add    %edx,%eax
 804b985:	8b 00                	mov    (%eax),%eax
 804b987:	83 f8 03             	cmp    $0x3,%eax
 804b98a:	74 cd                	je     804b959 <ifree+0x13b>
                page_dir[index + i] = MALLOC_FREE;

        l = i << malloc_pageshift;
 804b98c:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b98f:	c1 e0 0c             	shl    $0xc,%eax
 804b992:	89 45 c8             	mov    %eax,-0x38(%ebp)

        if (malloc_junk)
 804b995:	8b 83 c4 04 00 00    	mov    0x4c4(%ebx),%eax
 804b99b:	85 c0                	test   %eax,%eax
 804b99d:	74 1a                	je     804b9b9 <ifree+0x19b>
                memset(ptr, SOME_JUNK, l);
 804b99f:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804b9a2:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b9a6:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804b9ad:	00 
 804b9ae:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b9b1:	89 04 24             	mov    %eax,(%esp)
 804b9b4:	e8 0b 12 00 00       	call   804cbc4 <memset>
#ifdef HAS_MADVISE
        if (malloc_hint)
                madvise(ptr, l, MADV_FREE);
#endif

        tail = (char *)ptr + l;
 804b9b9:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804b9bc:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804b9bf:	01 d0                	add    %edx,%eax
 804b9c1:	89 45 c4             	mov    %eax,-0x3c(%ebp)

        /* add to free-list */
        if (!px)
 804b9c4:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b9ca:	85 c0                	test   %eax,%eax
 804b9cc:	75 12                	jne    804b9e0 <ifree+0x1c2>
                px = imalloc(sizeof * pt);      /* This cannot fail... */
 804b9ce:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 804b9d5:	e8 f0 f4 ff ff       	call   804aeca <imalloc>
 804b9da:	89 83 cc 04 00 00    	mov    %eax,0x4cc(%ebx)
        px->page = ptr;
 804b9e0:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b9e6:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804b9e9:	89 50 08             	mov    %edx,0x8(%eax)
        px->end =  tail;
 804b9ec:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b9f2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 804b9f5:	89 50 0c             	mov    %edx,0xc(%eax)
        px->size = l;
 804b9f8:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804b9fe:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804ba01:	89 50 10             	mov    %edx,0x10(%eax)
        if (!free_list.next) {
 804ba04:	8b 83 94 04 00 00    	mov    0x494(%ebx),%eax
 804ba0a:	85 c0                	test   %eax,%eax
 804ba0c:	75 41                	jne    804ba4f <ifree+0x231>

                /* Nothing on free list, put this at head */
                px->next = free_list.next;
 804ba0e:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804ba14:	8b 93 94 04 00 00    	mov    0x494(%ebx),%edx
 804ba1a:	89 10                	mov    %edx,(%eax)
                px->prev = &free_list;
 804ba1c:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804ba22:	8d 93 94 04 00 00    	lea    0x494(%ebx),%edx
 804ba28:	89 50 04             	mov    %edx,0x4(%eax)
                free_list.next = px;
 804ba2b:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804ba31:	89 83 94 04 00 00    	mov    %eax,0x494(%ebx)
                pf = px;
 804ba37:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804ba3d:	89 45 c0             	mov    %eax,-0x40(%ebp)
                px = 0;
 804ba40:	c7 83 cc 04 00 00 00 	movl   $0x0,0x4cc(%ebx)
 804ba47:	00 00 00 
 804ba4a:	e9 a2 01 00 00       	jmp    804bbf1 <ifree+0x3d3>

        } else {

                /* Find the right spot, leave pf pointing to the modified entry. */
                tail = (char *)ptr + l;
 804ba4f:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804ba52:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804ba55:	01 d0                	add    %edx,%eax
 804ba57:	89 45 c4             	mov    %eax,-0x3c(%ebp)

                for (pf = free_list.next; pf->end < ptr && pf->next; pf = pf->next)
 804ba5a:	8b 83 94 04 00 00    	mov    0x494(%ebx),%eax
 804ba60:	89 45 c0             	mov    %eax,-0x40(%ebp)
 804ba63:	eb 08                	jmp    804ba6d <ifree+0x24f>
 804ba65:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ba68:	8b 00                	mov    (%eax),%eax
 804ba6a:	89 45 c0             	mov    %eax,-0x40(%ebp)
 804ba6d:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ba70:	8b 40 0c             	mov    0xc(%eax),%eax
 804ba73:	39 45 dc             	cmp    %eax,-0x24(%ebp)
 804ba76:	76 09                	jbe    804ba81 <ifree+0x263>
 804ba78:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ba7b:	8b 00                	mov    (%eax),%eax
 804ba7d:	85 c0                	test   %eax,%eax
 804ba7f:	75 e4                	jne    804ba65 <ifree+0x247>
                        ; /* Race ahead here */

                if (pf->page > tail) {
 804ba81:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804ba84:	8b 40 08             	mov    0x8(%eax),%eax
 804ba87:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
 804ba8a:	73 4f                	jae    804badb <ifree+0x2bd>
                        /* Insert before entry */
                        px->next = pf;
 804ba8c:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804ba92:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804ba95:	89 10                	mov    %edx,(%eax)
                        px->prev = pf->prev;
 804ba97:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804ba9d:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804baa0:	8b 52 04             	mov    0x4(%edx),%edx
 804baa3:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev = px;
 804baa6:	8b 93 cc 04 00 00    	mov    0x4cc(%ebx),%edx
 804baac:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804baaf:	89 50 04             	mov    %edx,0x4(%eax)
                        px->prev->next = px;
 804bab2:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804bab8:	8b 40 04             	mov    0x4(%eax),%eax
 804babb:	8b 93 cc 04 00 00    	mov    0x4cc(%ebx),%edx
 804bac1:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804bac3:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804bac9:	89 45 c0             	mov    %eax,-0x40(%ebp)
                        px = 0;
 804bacc:	c7 83 cc 04 00 00 00 	movl   $0x0,0x4cc(%ebx)
 804bad3:	00 00 00 
 804bad6:	e9 16 01 00 00       	jmp    804bbf1 <ifree+0x3d3>
                } else if (pf->end == ptr) {
 804badb:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bade:	8b 40 0c             	mov    0xc(%eax),%eax
 804bae1:	39 45 dc             	cmp    %eax,-0x24(%ebp)
 804bae4:	0f 85 91 00 00 00    	jne    804bb7b <ifree+0x35d>
                        /* Append to the previous entry */
                        pf->end = (char *)pf->end + l;
 804baea:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804baed:	8b 40 0c             	mov    0xc(%eax),%eax
 804baf0:	89 c2                	mov    %eax,%edx
 804baf2:	03 55 c8             	add    -0x38(%ebp),%edx
 804baf5:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804baf8:	89 50 0c             	mov    %edx,0xc(%eax)
                        pf->size += l;
 804bafb:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bafe:	8b 40 10             	mov    0x10(%eax),%eax
 804bb01:	89 c2                	mov    %eax,%edx
 804bb03:	03 55 c8             	add    -0x38(%ebp),%edx
 804bb06:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bb09:	89 50 10             	mov    %edx,0x10(%eax)
                        if (pf->next && pf->end == pf->next->page) {
 804bb0c:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bb0f:	8b 00                	mov    (%eax),%eax
 804bb11:	85 c0                	test   %eax,%eax
 804bb13:	0f 84 d8 00 00 00    	je     804bbf1 <ifree+0x3d3>
 804bb19:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bb1c:	8b 50 0c             	mov    0xc(%eax),%edx
 804bb1f:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bb22:	8b 00                	mov    (%eax),%eax
 804bb24:	8b 40 08             	mov    0x8(%eax),%eax
 804bb27:	39 c2                	cmp    %eax,%edx
 804bb29:	0f 85 c2 00 00 00    	jne    804bbf1 <ifree+0x3d3>
                                /* And collapse the next too. */
                                pt = pf->next;
 804bb2f:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bb32:	8b 00                	mov    (%eax),%eax
 804bb34:	89 45 d0             	mov    %eax,-0x30(%ebp)
                                pf->end = pt->end;
 804bb37:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804bb3a:	8b 50 0c             	mov    0xc(%eax),%edx
 804bb3d:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bb40:	89 50 0c             	mov    %edx,0xc(%eax)
                                pf->size += pt->size;
 804bb43:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bb46:	8b 50 10             	mov    0x10(%eax),%edx
 804bb49:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804bb4c:	8b 40 10             	mov    0x10(%eax),%eax
 804bb4f:	01 c2                	add    %eax,%edx
 804bb51:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bb54:	89 50 10             	mov    %edx,0x10(%eax)
                                pf->next = pt->next;
 804bb57:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804bb5a:	8b 10                	mov    (%eax),%edx
 804bb5c:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bb5f:	89 10                	mov    %edx,(%eax)
                                if (pf->next)
 804bb61:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bb64:	8b 00                	mov    (%eax),%eax
 804bb66:	85 c0                	test   %eax,%eax
 804bb68:	0f 84 83 00 00 00    	je     804bbf1 <ifree+0x3d3>
                                        pf->next->prev = pf;
 804bb6e:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bb71:	8b 00                	mov    (%eax),%eax
 804bb73:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804bb76:	89 50 04             	mov    %edx,0x4(%eax)
 804bb79:	eb 76                	jmp    804bbf1 <ifree+0x3d3>
                        }
                } else if (pf->page == tail) {
 804bb7b:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bb7e:	8b 40 08             	mov    0x8(%eax),%eax
 804bb81:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
 804bb84:	75 1c                	jne    804bba2 <ifree+0x384>
                        /* Prepend to entry */
                        pf->size += l;
 804bb86:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bb89:	8b 40 10             	mov    0x10(%eax),%eax
 804bb8c:	89 c2                	mov    %eax,%edx
 804bb8e:	03 55 c8             	add    -0x38(%ebp),%edx
 804bb91:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bb94:	89 50 10             	mov    %edx,0x10(%eax)
                        pf->page = ptr;
 804bb97:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bb9a:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804bb9d:	89 50 08             	mov    %edx,0x8(%eax)
 804bba0:	eb 4f                	jmp    804bbf1 <ifree+0x3d3>
                } else if (!pf->next) {
 804bba2:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bba5:	8b 00                	mov    (%eax),%eax
 804bba7:	85 c0                	test   %eax,%eax
 804bba9:	75 38                	jne    804bbe3 <ifree+0x3c5>
                        /* Append at tail of chain */
                        px->next = 0;
 804bbab:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804bbb1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                        px->prev = pf;
 804bbb7:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804bbbd:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804bbc0:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->next = px;
 804bbc3:	8b 93 cc 04 00 00    	mov    0x4cc(%ebx),%edx
 804bbc9:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bbcc:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804bbce:	8b 83 cc 04 00 00    	mov    0x4cc(%ebx),%eax
 804bbd4:	89 45 c0             	mov    %eax,-0x40(%ebp)
                        px = 0;
 804bbd7:	c7 83 cc 04 00 00 00 	movl   $0x0,0x4cc(%ebx)
 804bbde:	00 00 00 
 804bbe1:	eb 0e                	jmp    804bbf1 <ifree+0x3d3>
                } else {
                        wrterror("freelist is destroyed.\n");
 804bbe3:	8d 83 35 d7 ff ff    	lea    -0x28cb(%ebx),%eax
 804bbe9:	89 04 24             	mov    %eax,(%esp)
 804bbec:	e8 3b e4 ff ff       	call   804a02c <wrterror>
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804bbf1:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bbf4:	8b 00                	mov    (%eax),%eax
 804bbf6:	85 c0                	test   %eax,%eax
 804bbf8:	0f 85 cd 00 00 00    	jne    804bccb <ifree+0x4ad>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804bbfe:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bc01:	8b 50 10             	mov    0x10(%eax),%edx
 804bc04:	8b 83 34 01 00 00    	mov    0x134(%ebx),%eax
                        wrterror("freelist is destroyed.\n");
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804bc0a:	39 c2                	cmp    %eax,%edx
 804bc0c:	0f 86 b9 00 00 00    	jbe    804bccb <ifree+0x4ad>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804bc12:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bc15:	8b 50 0c             	mov    0xc(%eax),%edx
 804bc18:	8b 83 c8 04 00 00    	mov    0x4c8(%ebx),%eax
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804bc1e:	39 c2                	cmp    %eax,%edx
 804bc20:	0f 85 a5 00 00 00    	jne    804bccb <ifree+0x4ad>
            pf->end == malloc_brk &&                  /* ..and none behind us, */
            malloc_brk == sbrk(0)) {                  /* ..and it's OK to do... */
 804bc26:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804bc2d:	e8 7e c8 ff ff       	call   80484b0 <sbrk>
 804bc32:	8b 93 c8 04 00 00    	mov    0x4c8(%ebx),%edx
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804bc38:	39 d0                	cmp    %edx,%eax
 804bc3a:	0f 85 8b 00 00 00    	jne    804bccb <ifree+0x4ad>

                /*
                 * Keep the cache intact.  Notice that the '>' above guarantees that
                 * the pf will always have at least one page afterwards.
                 */
                pf->end = (char *)pf->page + malloc_cache;
 804bc40:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bc43:	8b 50 08             	mov    0x8(%eax),%edx
 804bc46:	8b 83 34 01 00 00    	mov    0x134(%ebx),%eax
 804bc4c:	01 c2                	add    %eax,%edx
 804bc4e:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bc51:	89 50 0c             	mov    %edx,0xc(%eax)
                pf->size = malloc_cache;
 804bc54:	8b 93 34 01 00 00    	mov    0x134(%ebx),%edx
 804bc5a:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bc5d:	89 50 10             	mov    %edx,0x10(%eax)

                brk(pf->end);
 804bc60:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bc63:	8b 40 0c             	mov    0xc(%eax),%eax
 804bc66:	89 04 24             	mov    %eax,(%esp)
 804bc69:	e8 12 c9 ff ff       	call   8048580 <brk>
                malloc_brk = pf->end;
 804bc6e:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bc71:	8b 40 0c             	mov    0xc(%eax),%eax
 804bc74:	89 83 c8 04 00 00    	mov    %eax,0x4c8(%ebx)

                index = ptr2index(pf->end);
 804bc7a:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804bc7d:	8b 40 0c             	mov    0xc(%eax),%eax
 804bc80:	89 c2                	mov    %eax,%edx
 804bc82:	c1 ea 0c             	shr    $0xc,%edx
 804bc85:	8b 83 84 04 00 00    	mov    0x484(%ebx),%eax
 804bc8b:	89 d6                	mov    %edx,%esi
 804bc8d:	29 c6                	sub    %eax,%esi
 804bc8f:	89 f0                	mov    %esi,%eax
 804bc91:	89 45 d8             	mov    %eax,-0x28(%ebp)
                last_index = index - 1;
 804bc94:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804bc97:	83 e8 01             	sub    $0x1,%eax
 804bc9a:	89 83 88 04 00 00    	mov    %eax,0x488(%ebx)

                for (i = index; i <= last_index;)
 804bca0:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804bca3:	89 45 cc             	mov    %eax,-0x34(%ebp)
 804bca6:	eb 18                	jmp    804bcc0 <ifree+0x4a2>
                        page_dir[i++] = MALLOC_NOT_MINE;
 804bca8:	8b 83 8c 04 00 00    	mov    0x48c(%ebx),%eax
 804bcae:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804bcb1:	c1 e2 02             	shl    $0x2,%edx
 804bcb4:	01 d0                	add    %edx,%eax
 804bcb6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
 804bcbc:	83 45 cc 01          	addl   $0x1,-0x34(%ebp)
                malloc_brk = pf->end;

                index = ptr2index(pf->end);
                last_index = index - 1;

                for (i = index; i <= last_index;)
 804bcc0:	8b 83 88 04 00 00    	mov    0x488(%ebx),%eax
 804bcc6:	39 45 cc             	cmp    %eax,-0x34(%ebp)
 804bcc9:	76 dd                	jbe    804bca8 <ifree+0x48a>
                        page_dir[i++] = MALLOC_NOT_MINE;

                /* XXX: We could realloc/shrink the pagedir here I guess. */
        }
        if (pt)
 804bccb:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804bccf:	0f 84 26 02 00 00    	je     804befb <ifree+0x6dd>
                ifree(pt);
 804bcd5:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804bcd8:	89 04 24             	mov    %eax,(%esp)
 804bcdb:	e8 3e fb ff ff       	call   804b81e <ifree>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804bce0:	e9 16 02 00 00       	jmp    804befb <ifree+0x6dd>
        info = page_dir[index];

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
 804bce5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804bce8:	8b 55 08             	mov    0x8(%ebp),%edx
 804bceb:	89 55 bc             	mov    %edx,-0x44(%ebp)
 804bcee:	89 45 a8             	mov    %eax,-0x58(%ebp)
 804bcf1:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bcf4:	89 45 b8             	mov    %eax,-0x48(%ebp)
        int i;
        struct pginfo **mp;
        void *vp;

        /* Find the chunk number on the page */
        i = ((u_long)ptr & malloc_pagemask) >> info->shift;
 804bcf7:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804bcfa:	89 c2                	mov    %eax,%edx
 804bcfc:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
 804bd02:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804bd05:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804bd09:	0f b7 c0             	movzwl %ax,%eax
 804bd0c:	89 d6                	mov    %edx,%esi
 804bd0e:	89 c1                	mov    %eax,%ecx
 804bd10:	d3 ee                	shr    %cl,%esi
 804bd12:	89 f0                	mov    %esi,%eax
 804bd14:	89 45 b4             	mov    %eax,-0x4c(%ebp)

        if (((u_long)ptr & (info->size - 1))) {
 804bd17:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804bd1a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804bd1e:	0f b7 c0             	movzwl %ax,%eax
 804bd21:	83 e8 01             	sub    $0x1,%eax
 804bd24:	89 c2                	mov    %eax,%edx
 804bd26:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804bd29:	21 d0                	and    %edx,%eax
 804bd2b:	85 c0                	test   %eax,%eax
 804bd2d:	74 13                	je     804bd42 <ifree+0x524>
                wrtwarning("modified (chunk-) pointer.\n");
 804bd2f:	8d 83 d2 d6 ff ff    	lea    -0x292e(%ebx),%eax
 804bd35:	89 04 24             	mov    %eax,(%esp)
 804bd38:	e8 ba e3 ff ff       	call   804a0f7 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804bd3d:	e9 b9 01 00 00       	jmp    804befb <ifree+0x6dd>
        if (((u_long)ptr & (info->size - 1))) {
                wrtwarning("modified (chunk-) pointer.\n");
                return;
        }

        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804bd42:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804bd45:	89 c2                	mov    %eax,%edx
 804bd47:	c1 ea 05             	shr    $0x5,%edx
 804bd4a:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804bd4d:	83 c2 04             	add    $0x4,%edx
 804bd50:	8b 14 90             	mov    (%eax,%edx,4),%edx
 804bd53:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804bd56:	83 e0 1f             	and    $0x1f,%eax
 804bd59:	be 01 00 00 00       	mov    $0x1,%esi
 804bd5e:	89 f7                	mov    %esi,%edi
 804bd60:	89 c1                	mov    %eax,%ecx
 804bd62:	d3 e7                	shl    %cl,%edi
 804bd64:	89 f8                	mov    %edi,%eax
 804bd66:	21 d0                	and    %edx,%eax
 804bd68:	85 c0                	test   %eax,%eax
 804bd6a:	74 13                	je     804bd7f <ifree+0x561>
                wrtwarning("chunk is already free.\n");
 804bd6c:	8d 83 ee d6 ff ff    	lea    -0x2912(%ebx),%eax
 804bd72:	89 04 24             	mov    %eax,(%esp)
 804bd75:	e8 7d e3 ff ff       	call   804a0f7 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804bd7a:	e9 7c 01 00 00       	jmp    804befb <ifree+0x6dd>
        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
                wrtwarning("chunk is already free.\n");
                return;
        }

        if (malloc_junk)
 804bd7f:	8b 83 c4 04 00 00    	mov    0x4c4(%ebx),%eax
 804bd85:	85 c0                	test   %eax,%eax
 804bd87:	74 21                	je     804bdaa <ifree+0x58c>
                memset(ptr, SOME_JUNK, info->size);
 804bd89:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804bd8c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804bd90:	0f b7 c0             	movzwl %ax,%eax
 804bd93:	89 44 24 08          	mov    %eax,0x8(%esp)
 804bd97:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804bd9e:	00 
 804bd9f:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804bda2:	89 04 24             	mov    %eax,(%esp)
 804bda5:	e8 1a 0e 00 00       	call   804cbc4 <memset>

        info->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804bdaa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804bdad:	c1 e8 05             	shr    $0x5,%eax
 804bdb0:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804bdb3:	8d 48 04             	lea    0x4(%eax),%ecx
 804bdb6:	8b 34 8a             	mov    (%edx,%ecx,4),%esi
 804bdb9:	8b 55 b4             	mov    -0x4c(%ebp),%edx
 804bdbc:	83 e2 1f             	and    $0x1f,%edx
 804bdbf:	c7 45 a4 01 00 00 00 	movl   $0x1,-0x5c(%ebp)
 804bdc6:	8b 7d a4             	mov    -0x5c(%ebp),%edi
 804bdc9:	89 d1                	mov    %edx,%ecx
 804bdcb:	d3 e7                	shl    %cl,%edi
 804bdcd:	89 fa                	mov    %edi,%edx
 804bdcf:	89 f1                	mov    %esi,%ecx
 804bdd1:	09 d1                	or     %edx,%ecx
 804bdd3:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804bdd6:	83 c0 04             	add    $0x4,%eax
 804bdd9:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
        info->free++;
 804bddc:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804bddf:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804bde3:	8d 50 01             	lea    0x1(%eax),%edx
 804bde6:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804bde9:	66 89 50 0c          	mov    %dx,0xc(%eax)

        mp = page_dir + info->shift;
 804bded:	8b 93 8c 04 00 00    	mov    0x48c(%ebx),%edx
 804bdf3:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804bdf6:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804bdfa:	0f b7 c0             	movzwl %ax,%eax
 804bdfd:	c1 e0 02             	shl    $0x2,%eax
 804be00:	01 d0                	add    %edx,%eax
 804be02:	89 45 b0             	mov    %eax,-0x50(%ebp)

        if (info->free == 1) {
 804be05:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804be08:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804be0c:	66 83 f8 01          	cmp    $0x1,%ax
 804be10:	75 61                	jne    804be73 <ifree+0x655>

                /* Page became non-full */

                mp = page_dir + info->shift;
 804be12:	8b 93 8c 04 00 00    	mov    0x48c(%ebx),%edx
 804be18:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804be1b:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804be1f:	0f b7 c0             	movzwl %ax,%eax
 804be22:	c1 e0 02             	shl    $0x2,%eax
 804be25:	01 d0                	add    %edx,%eax
 804be27:	89 45 b0             	mov    %eax,-0x50(%ebp)
 804be2a:	eb 08                	jmp    804be34 <ifree+0x616>
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
                        mp = &(*mp)->next;
 804be2c:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804be2f:	8b 00                	mov    (%eax),%eax
 804be31:	89 45 b0             	mov    %eax,-0x50(%ebp)

                /* Page became non-full */

                mp = page_dir + info->shift;
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804be34:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804be37:	8b 00                	mov    (%eax),%eax
 804be39:	85 c0                	test   %eax,%eax
 804be3b:	74 1f                	je     804be5c <ifree+0x63e>
 804be3d:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804be40:	8b 00                	mov    (%eax),%eax
 804be42:	8b 00                	mov    (%eax),%eax
 804be44:	85 c0                	test   %eax,%eax
 804be46:	74 14                	je     804be5c <ifree+0x63e>
 804be48:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804be4b:	8b 00                	mov    (%eax),%eax
 804be4d:	8b 00                	mov    (%eax),%eax
 804be4f:	8b 50 04             	mov    0x4(%eax),%edx
 804be52:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804be55:	8b 40 04             	mov    0x4(%eax),%eax
 804be58:	39 c2                	cmp    %eax,%edx
 804be5a:	72 d0                	jb     804be2c <ifree+0x60e>
                        mp = &(*mp)->next;
                info->next = *mp;
 804be5c:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804be5f:	8b 10                	mov    (%eax),%edx
 804be61:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804be64:	89 10                	mov    %edx,(%eax)
                *mp = info;
 804be66:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804be69:	8b 55 b8             	mov    -0x48(%ebp),%edx
 804be6c:	89 10                	mov    %edx,(%eax)

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804be6e:	e9 88 00 00 00       	jmp    804befb <ifree+0x6dd>
                info->next = *mp;
                *mp = info;
                return;
        }

        if (info->free != info->total)
 804be73:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804be76:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804be7a:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804be7d:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804be81:	66 39 c2             	cmp    %ax,%dx
 804be84:	75 75                	jne    804befb <ifree+0x6dd>
 804be86:	eb 08                	jmp    804be90 <ifree+0x672>
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
                mp = &((*mp)->next);
 804be88:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804be8b:	8b 00                	mov    (%eax),%eax
 804be8d:	89 45 b0             	mov    %eax,-0x50(%ebp)

        if (info->free != info->total)
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
 804be90:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804be93:	8b 00                	mov    (%eax),%eax
 804be95:	39 45 b8             	cmp    %eax,-0x48(%ebp)
 804be98:	75 ee                	jne    804be88 <ifree+0x66a>
#ifdef EXTRA_SANITY
                if (!*mp)
                        wrterror("(ES): Not on queue\n");
#endif /* EXTRA_SANITY */
        }
        *mp = info->next;
 804be9a:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804be9d:	8b 10                	mov    (%eax),%edx
 804be9f:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804bea2:	89 10                	mov    %edx,(%eax)

        /* Free the page & the info structure if need be */
        page_dir[ptr2index(info->page)] = MALLOC_FIRST;
 804bea4:	8b 93 8c 04 00 00    	mov    0x48c(%ebx),%edx
 804beaa:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804bead:	8b 40 04             	mov    0x4(%eax),%eax
 804beb0:	89 c1                	mov    %eax,%ecx
 804beb2:	c1 e9 0c             	shr    $0xc,%ecx
 804beb5:	8b 83 84 04 00 00    	mov    0x484(%ebx),%eax
 804bebb:	89 ce                	mov    %ecx,%esi
 804bebd:	29 c6                	sub    %eax,%esi
 804bebf:	89 f0                	mov    %esi,%eax
 804bec1:	c1 e0 02             	shl    $0x2,%eax
 804bec4:	01 d0                	add    %edx,%eax
 804bec6:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        vp = info->page;            /* Order is important ! */
 804becc:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804becf:	8b 40 04             	mov    0x4(%eax),%eax
 804bed2:	89 45 ac             	mov    %eax,-0x54(%ebp)
        if (vp != (void *)info)
 804bed5:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804bed8:	3b 45 ac             	cmp    -0x54(%ebp),%eax
 804bedb:	74 0b                	je     804bee8 <ifree+0x6ca>
                ifree(info);
 804bedd:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804bee0:	89 04 24             	mov    %eax,(%esp)
 804bee3:	e8 36 f9 ff ff       	call   804b81e <ifree>
        ifree(vp);
 804bee8:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804beeb:	89 04 24             	mov    %eax,(%esp)
 804beee:	e8 2b f9 ff ff       	call   804b81e <ifree>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804bef3:	eb 06                	jmp    804befb <ifree+0x6dd>
        struct pginfo *info;
        unsigned int index;

        /* This is legal */
        if (!ptr)
                return;
 804bef5:	90                   	nop
 804bef6:	eb 04                	jmp    804befc <ifree+0x6de>
                return;
        }

        /* If we're already sinking, don't make matters any worse. */
        if (suicide)
                return;
 804bef8:	90                   	nop
 804bef9:	eb 01                	jmp    804befc <ifree+0x6de>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804befb:	90                   	nop
}
 804befc:	83 c4 6c             	add    $0x6c,%esp
 804beff:	5b                   	pop    %ebx
 804bf00:	5e                   	pop    %esi
 804bf01:	5f                   	pop    %edi
 804bf02:	5d                   	pop    %ebp
 804bf03:	c3                   	ret    

0804bf04 <malloc>:
 */


void *
malloc(size_t size)
{
 804bf04:	55                   	push   %ebp
 804bf05:	89 e5                	mov    %esp,%ebp
 804bf07:	56                   	push   %esi
 804bf08:	53                   	push   %ebx
 804bf09:	83 ec 10             	sub    $0x10,%esp
 804bf0c:	e8 54 c5 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804bf11:	81 c3 9b 42 00 00    	add    $0x429b,%ebx
        register void *r;

        THREAD_LOCK();
        malloc_func = " in malloc():";
 804bf17:	8d 83 71 d7 ff ff    	lea    -0x288f(%ebx),%eax
 804bf1d:	89 83 d0 04 00 00    	mov    %eax,0x4d0(%ebx)
        if (malloc_active++) {
 804bf23:	8b 83 80 04 00 00    	mov    0x480(%ebx),%eax
 804bf29:	85 c0                	test   %eax,%eax
 804bf2b:	0f 95 c2             	setne  %dl
 804bf2e:	83 c0 01             	add    $0x1,%eax
 804bf31:	89 83 80 04 00 00    	mov    %eax,0x480(%ebx)
 804bf37:	84 d2                	test   %dl,%dl
 804bf39:	74 24                	je     804bf5f <malloc+0x5b>
                wrtwarning("recursive call.\n");
 804bf3b:	8d 83 7f d7 ff ff    	lea    -0x2881(%ebx),%eax
 804bf41:	89 04 24             	mov    %eax,(%esp)
 804bf44:	e8 ae e1 ff ff       	call   804a0f7 <wrtwarning>
                malloc_active--;
 804bf49:	8b 83 80 04 00 00    	mov    0x480(%ebx),%eax
 804bf4f:	83 e8 01             	sub    $0x1,%eax
 804bf52:	89 83 80 04 00 00    	mov    %eax,0x480(%ebx)
                return (0);
 804bf58:	b8 00 00 00 00       	mov    $0x0,%eax
 804bf5d:	eb 60                	jmp    804bfbf <malloc+0xbb>
        }
        if (!malloc_started) {
 804bf5f:	8b 83 7c 04 00 00    	mov    0x47c(%ebx),%eax
 804bf65:	85 c0                	test   %eax,%eax
 804bf67:	75 05                	jne    804bf6e <malloc+0x6a>
                malloc_init();
 804bf69:	e8 db e3 ff ff       	call   804a349 <malloc_init>
        }
        if (malloc_sysv && !size)
 804bf6e:	8b 83 bc 04 00 00    	mov    0x4bc(%ebx),%eax
 804bf74:	85 c0                	test   %eax,%eax
 804bf76:	74 0d                	je     804bf85 <malloc+0x81>
 804bf78:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804bf7c:	75 07                	jne    804bf85 <malloc+0x81>
                r = 0;
 804bf7e:	be 00 00 00 00       	mov    $0x0,%esi
 804bf83:	eb 0d                	jmp    804bf92 <malloc+0x8e>
        else
                r = imalloc(size);
 804bf85:	8b 45 08             	mov    0x8(%ebp),%eax
 804bf88:	89 04 24             	mov    %eax,(%esp)
 804bf8b:	e8 3a ef ff ff       	call   804aeca <imalloc>
 804bf90:	89 c6                	mov    %eax,%esi
        UTRACE(0, size, r);
        malloc_active--;
 804bf92:	8b 83 80 04 00 00    	mov    0x480(%ebx),%eax
 804bf98:	83 e8 01             	sub    $0x1,%eax
 804bf9b:	89 83 80 04 00 00    	mov    %eax,0x480(%ebx)
        THREAD_UNLOCK();
        if (malloc_xmalloc && !r)
 804bfa1:	8b 83 b8 04 00 00    	mov    0x4b8(%ebx),%eax
 804bfa7:	85 c0                	test   %eax,%eax
 804bfa9:	74 12                	je     804bfbd <malloc+0xb9>
 804bfab:	85 f6                	test   %esi,%esi
 804bfad:	75 0e                	jne    804bfbd <malloc+0xb9>
                wrterror("out of memory.\n");
 804bfaf:	8d 83 90 d7 ff ff    	lea    -0x2870(%ebx),%eax
 804bfb5:	89 04 24             	mov    %eax,(%esp)
 804bfb8:	e8 6f e0 ff ff       	call   804a02c <wrterror>
        return (r);
 804bfbd:	89 f0                	mov    %esi,%eax
}
 804bfbf:	83 c4 10             	add    $0x10,%esp
 804bfc2:	5b                   	pop    %ebx
 804bfc3:	5e                   	pop    %esi
 804bfc4:	5d                   	pop    %ebp
 804bfc5:	c3                   	ret    

0804bfc6 <free>:

void
free(void *ptr)
{
 804bfc6:	55                   	push   %ebp
 804bfc7:	89 e5                	mov    %esp,%ebp
 804bfc9:	53                   	push   %ebx
 804bfca:	83 ec 14             	sub    $0x14,%esp
 804bfcd:	e8 93 c4 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804bfd2:	81 c3 da 41 00 00    	add    $0x41da,%ebx
        THREAD_LOCK();
        malloc_func = " in free():";
 804bfd8:	8d 83 a0 d7 ff ff    	lea    -0x2860(%ebx),%eax
 804bfde:	89 83 d0 04 00 00    	mov    %eax,0x4d0(%ebx)
        if (malloc_active++) {
 804bfe4:	8b 83 80 04 00 00    	mov    0x480(%ebx),%eax
 804bfea:	85 c0                	test   %eax,%eax
 804bfec:	0f 95 c2             	setne  %dl
 804bfef:	83 c0 01             	add    $0x1,%eax
 804bff2:	89 83 80 04 00 00    	mov    %eax,0x480(%ebx)
 804bff8:	84 d2                	test   %dl,%dl
 804bffa:	74 1f                	je     804c01b <free+0x55>
                wrtwarning("recursive call.\n");
 804bffc:	8d 83 7f d7 ff ff    	lea    -0x2881(%ebx),%eax
 804c002:	89 04 24             	mov    %eax,(%esp)
 804c005:	e8 ed e0 ff ff       	call   804a0f7 <wrtwarning>
                malloc_active--;
 804c00a:	8b 83 80 04 00 00    	mov    0x480(%ebx),%eax
 804c010:	83 e8 01             	sub    $0x1,%eax
 804c013:	89 83 80 04 00 00    	mov    %eax,0x480(%ebx)
                return;
 804c019:	eb 1b                	jmp    804c036 <free+0x70>
        } else {
                ifree(ptr);
 804c01b:	8b 45 08             	mov    0x8(%ebp),%eax
 804c01e:	89 04 24             	mov    %eax,(%esp)
 804c021:	e8 f8 f7 ff ff       	call   804b81e <ifree>
                UTRACE(ptr, 0, 0);
        }
        malloc_active--;
 804c026:	8b 83 80 04 00 00    	mov    0x480(%ebx),%eax
 804c02c:	83 e8 01             	sub    $0x1,%eax
 804c02f:	89 83 80 04 00 00    	mov    %eax,0x480(%ebx)
        THREAD_UNLOCK();
        return;
 804c035:	90                   	nop
}
 804c036:	83 c4 14             	add    $0x14,%esp
 804c039:	5b                   	pop    %ebx
 804c03a:	5d                   	pop    %ebp
 804c03b:	c3                   	ret    

0804c03c <realloc>:

void *
realloc(void *ptr, size_t size)
{
 804c03c:	55                   	push   %ebp
 804c03d:	89 e5                	mov    %esp,%ebp
 804c03f:	56                   	push   %esi
 804c040:	53                   	push   %ebx
 804c041:	83 ec 10             	sub    $0x10,%esp
 804c044:	e8 1c c4 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804c049:	81 c3 63 41 00 00    	add    $0x4163,%ebx
        register void *r;

        THREAD_LOCK();
        malloc_func = " in realloc():";
 804c04f:	8d 83 ac d7 ff ff    	lea    -0x2854(%ebx),%eax
 804c055:	89 83 d0 04 00 00    	mov    %eax,0x4d0(%ebx)
        if (malloc_active++) {
 804c05b:	8b 83 80 04 00 00    	mov    0x480(%ebx),%eax
 804c061:	85 c0                	test   %eax,%eax
 804c063:	0f 95 c2             	setne  %dl
 804c066:	83 c0 01             	add    $0x1,%eax
 804c069:	89 83 80 04 00 00    	mov    %eax,0x480(%ebx)
 804c06f:	84 d2                	test   %dl,%dl
 804c071:	74 27                	je     804c09a <realloc+0x5e>
                wrtwarning("recursive call.\n");
 804c073:	8d 83 7f d7 ff ff    	lea    -0x2881(%ebx),%eax
 804c079:	89 04 24             	mov    %eax,(%esp)
 804c07c:	e8 76 e0 ff ff       	call   804a0f7 <wrtwarning>
                malloc_active--;
 804c081:	8b 83 80 04 00 00    	mov    0x480(%ebx),%eax
 804c087:	83 e8 01             	sub    $0x1,%eax
 804c08a:	89 83 80 04 00 00    	mov    %eax,0x480(%ebx)
                return (0);
 804c090:	b8 00 00 00 00       	mov    $0x0,%eax
 804c095:	e9 ac 00 00 00       	jmp    804c146 <realloc+0x10a>
        }
        if (ptr && !malloc_started) {
 804c09a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804c09e:	74 1f                	je     804c0bf <realloc+0x83>
 804c0a0:	8b 83 7c 04 00 00    	mov    0x47c(%ebx),%eax
 804c0a6:	85 c0                	test   %eax,%eax
 804c0a8:	75 15                	jne    804c0bf <realloc+0x83>
                wrtwarning("malloc() has never been called.\n");
 804c0aa:	8d 83 50 d7 ff ff    	lea    -0x28b0(%ebx),%eax
 804c0b0:	89 04 24             	mov    %eax,(%esp)
 804c0b3:	e8 3f e0 ff ff       	call   804a0f7 <wrtwarning>
                ptr = 0;
 804c0b8:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        }
        if (!malloc_started)
 804c0bf:	8b 83 7c 04 00 00    	mov    0x47c(%ebx),%eax
 804c0c5:	85 c0                	test   %eax,%eax
 804c0c7:	75 05                	jne    804c0ce <realloc+0x92>
                malloc_init();
 804c0c9:	e8 7b e2 ff ff       	call   804a349 <malloc_init>
        if (malloc_sysv && !size) {
 804c0ce:	8b 83 bc 04 00 00    	mov    0x4bc(%ebx),%eax
 804c0d4:	85 c0                	test   %eax,%eax
 804c0d6:	74 18                	je     804c0f0 <realloc+0xb4>
 804c0d8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804c0dc:	75 12                	jne    804c0f0 <realloc+0xb4>
                ifree(ptr);
 804c0de:	8b 45 08             	mov    0x8(%ebp),%eax
 804c0e1:	89 04 24             	mov    %eax,(%esp)
 804c0e4:	e8 35 f7 ff ff       	call   804b81e <ifree>
                r = 0;
 804c0e9:	be 00 00 00 00       	mov    $0x0,%esi
 804c0ee:	eb 29                	jmp    804c119 <realloc+0xdd>
        } else if (!ptr) {
 804c0f0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804c0f4:	75 0f                	jne    804c105 <realloc+0xc9>
                r = imalloc(size);
 804c0f6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c0f9:	89 04 24             	mov    %eax,(%esp)
 804c0fc:	e8 c9 ed ff ff       	call   804aeca <imalloc>
 804c101:	89 c6                	mov    %eax,%esi
 804c103:	eb 14                	jmp    804c119 <realloc+0xdd>
        } else {
                r = irealloc(ptr, size);
 804c105:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c108:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c10c:	8b 45 08             	mov    0x8(%ebp),%eax
 804c10f:	89 04 24             	mov    %eax,(%esp)
 804c112:	e8 69 ee ff ff       	call   804af80 <irealloc>
 804c117:	89 c6                	mov    %eax,%esi
        }
        UTRACE(ptr, size, r);
        malloc_active--;
 804c119:	8b 83 80 04 00 00    	mov    0x480(%ebx),%eax
 804c11f:	83 e8 01             	sub    $0x1,%eax
 804c122:	89 83 80 04 00 00    	mov    %eax,0x480(%ebx)
        THREAD_UNLOCK();
        if (malloc_xmalloc && !r)
 804c128:	8b 83 b8 04 00 00    	mov    0x4b8(%ebx),%eax
 804c12e:	85 c0                	test   %eax,%eax
 804c130:	74 12                	je     804c144 <realloc+0x108>
 804c132:	85 f6                	test   %esi,%esi
 804c134:	75 0e                	jne    804c144 <realloc+0x108>
                wrterror("out of memory.\n");
 804c136:	8d 83 90 d7 ff ff    	lea    -0x2870(%ebx),%eax
 804c13c:	89 04 24             	mov    %eax,(%esp)
 804c13f:	e8 e8 de ff ff       	call   804a02c <wrterror>
        return (r);
 804c144:	89 f0                	mov    %esi,%eax
}
 804c146:	83 c4 10             	add    $0x10,%esp
 804c149:	5b                   	pop    %ebx
 804c14a:	5e                   	pop    %esi
 804c14b:	5d                   	pop    %ebp
 804c14c:	c3                   	ret    

0804c14d <calloc>:

/* Added */
void *calloc(size_t nelem, size_t elsize)
{
 804c14d:	55                   	push   %ebp
 804c14e:	89 e5                	mov    %esp,%ebp
 804c150:	53                   	push   %ebx
 804c151:	83 ec 24             	sub    $0x24,%esp
 804c154:	e8 0c c3 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804c159:	81 c3 53 40 00 00    	add    $0x4053,%ebx
        void *tmp;
        if (NULL == (tmp = malloc(nelem * elsize))) {
 804c15f:	8b 45 08             	mov    0x8(%ebp),%eax
 804c162:	0f af 45 0c          	imul   0xc(%ebp),%eax
 804c166:	89 04 24             	mov    %eax,(%esp)
 804c169:	e8 96 fd ff ff       	call   804bf04 <malloc>
 804c16e:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804c171:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804c175:	75 07                	jne    804c17e <calloc+0x31>
                return NULL;
 804c177:	b8 00 00 00 00       	mov    $0x0,%eax
 804c17c:	eb 21                	jmp    804c19f <calloc+0x52>
        } else {
                memset(tmp, 0, nelem * elsize);
 804c17e:	8b 45 08             	mov    0x8(%ebp),%eax
 804c181:	0f af 45 0c          	imul   0xc(%ebp),%eax
 804c185:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c189:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804c190:	00 
 804c191:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c194:	89 04 24             	mov    %eax,(%esp)
 804c197:	e8 28 0a 00 00       	call   804cbc4 <memset>
                return tmp;
 804c19c:	8b 45 f4             	mov    -0xc(%ebp),%eax
        }
}
 804c19f:	83 c4 24             	add    $0x24,%esp
 804c1a2:	5b                   	pop    %ebx
 804c1a3:	5d                   	pop    %ebp
 804c1a4:	c3                   	ret    
 804c1a5:	90                   	nop
 804c1a6:	90                   	nop
 804c1a7:	90                   	nop

0804c1a8 <shl>:
 * `fall out' the left (there never will be any such anyway).
 * We may assume len >= 0.  NOTE THAT THIS WRITES len+1 DIGITS.
 */
static void
shl(register digit *p, register int len, register int sh)
{
 804c1a8:	55                   	push   %ebp
 804c1a9:	89 e5                	mov    %esp,%ebp
 804c1ab:	57                   	push   %edi
 804c1ac:	56                   	push   %esi
 804c1ad:	83 ec 08             	sub    $0x8,%esp
        register int i;

        for (i = 0; i < len; i++)
 804c1b0:	be 00 00 00 00       	mov    $0x0,%esi
 804c1b5:	eb 4f                	jmp    804c206 <shl+0x5e>
                p[i] = LHALF(p[i] << sh) | (p[i + 1] >> (HALF_BITS - sh));
 804c1b7:	89 f0                	mov    %esi,%eax
 804c1b9:	c1 e0 02             	shl    $0x2,%eax
 804c1bc:	8b 55 08             	mov    0x8(%ebp),%edx
 804c1bf:	01 c2                	add    %eax,%edx
 804c1c1:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804c1c4:	89 f0                	mov    %esi,%eax
 804c1c6:	c1 e0 02             	shl    $0x2,%eax
 804c1c9:	03 45 08             	add    0x8(%ebp),%eax
 804c1cc:	8b 00                	mov    (%eax),%eax
 804c1ce:	0f b6 4d 10          	movzbl 0x10(%ebp),%ecx
 804c1d2:	d3 e0                	shl    %cl,%eax
 804c1d4:	25 ff ff 00 00       	and    $0xffff,%eax
 804c1d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c1dc:	89 f0                	mov    %esi,%eax
 804c1de:	83 c0 01             	add    $0x1,%eax
 804c1e1:	c1 e0 02             	shl    $0x2,%eax
 804c1e4:	03 45 08             	add    0x8(%ebp),%eax
 804c1e7:	8b 38                	mov    (%eax),%edi
 804c1e9:	8b 55 10             	mov    0x10(%ebp),%edx
 804c1ec:	b8 10 00 00 00       	mov    $0x10,%eax
 804c1f1:	29 d0                	sub    %edx,%eax
 804c1f3:	89 fa                	mov    %edi,%edx
 804c1f5:	89 c1                	mov    %eax,%ecx
 804c1f7:	d3 ea                	shr    %cl,%edx
 804c1f9:	89 d0                	mov    %edx,%eax
 804c1fb:	0b 45 f0             	or     -0x10(%ebp),%eax
 804c1fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804c201:	89 02                	mov    %eax,(%edx)
static void
shl(register digit *p, register int len, register int sh)
{
        register int i;

        for (i = 0; i < len; i++)
 804c203:	83 c6 01             	add    $0x1,%esi
 804c206:	3b 75 0c             	cmp    0xc(%ebp),%esi
 804c209:	7c ac                	jl     804c1b7 <shl+0xf>
                p[i] = LHALF(p[i] << sh) | (p[i + 1] >> (HALF_BITS - sh));
        p[i] = LHALF(p[i] << sh);
 804c20b:	89 f0                	mov    %esi,%eax
 804c20d:	c1 e0 02             	shl    $0x2,%eax
 804c210:	03 45 08             	add    0x8(%ebp),%eax
 804c213:	89 f2                	mov    %esi,%edx
 804c215:	c1 e2 02             	shl    $0x2,%edx
 804c218:	03 55 08             	add    0x8(%ebp),%edx
 804c21b:	8b 12                	mov    (%edx),%edx
 804c21d:	0f b6 4d 10          	movzbl 0x10(%ebp),%ecx
 804c221:	d3 e2                	shl    %cl,%edx
 804c223:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804c229:	89 10                	mov    %edx,(%eax)
}
 804c22b:	83 c4 08             	add    $0x8,%esp
 804c22e:	5e                   	pop    %esi
 804c22f:	5f                   	pop    %edi
 804c230:	5d                   	pop    %ebp
 804c231:	c3                   	ret    

0804c232 <__qdivrem>:
 * divisor are 4 `digits' in this base (they are shorter if they have
 * leading zeros).
 */
unsigned long long
__qdivrem(unsigned long long uq, unsigned long long vq, unsigned long long *arq)
{
 804c232:	55                   	push   %ebp
 804c233:	89 e5                	mov    %esp,%ebp
 804c235:	57                   	push   %edi
 804c236:	56                   	push   %esi
 804c237:	53                   	push   %ebx
 804c238:	81 ec c8 00 00 00    	sub    $0xc8,%esp
 804c23e:	e8 22 c2 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804c243:	81 c3 69 3f 00 00    	add    $0x3f69,%ebx
 804c249:	8b 45 08             	mov    0x8(%ebp),%eax
 804c24c:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
 804c252:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c255:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
 804c25b:	8b 45 10             	mov    0x10(%ebp),%eax
 804c25e:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
 804c264:	8b 45 14             	mov    0x14(%ebp),%eax
 804c267:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
        digit uspace[5], vspace[5], qspace[5];

        /*
         * Take care of special cases: divide by zero, and u < v.
         */
        if (vq == 0) {
 804c26d:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
 804c273:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
 804c279:	09 d0                	or     %edx,%eax
 804c27b:	85 c0                	test   %eax,%eax
 804c27d:	75 4a                	jne    804c2c9 <__qdivrem+0x97>
                /* divide by zero. */
                static volatile const unsigned int zero = 0;

                tmp.ul[H] = tmp.ul[L] = 1 / zero;
 804c27f:	8b 93 3c 01 00 00    	mov    0x13c(%ebx),%edx
 804c285:	89 95 40 ff ff ff    	mov    %edx,-0xc0(%ebp)
 804c28b:	b8 01 00 00 00       	mov    $0x1,%eax
 804c290:	ba 00 00 00 00       	mov    $0x0,%edx
 804c295:	f7 b5 40 ff ff ff    	divl   -0xc0(%ebp)
 804c29b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804c29e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c2a1:	89 45 a8             	mov    %eax,-0x58(%ebp)
                if (arq)
 804c2a4:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804c2a8:	74 14                	je     804c2be <__qdivrem+0x8c>
                        *arq = uq;
 804c2aa:	8b 4d 18             	mov    0x18(%ebp),%ecx
 804c2ad:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 804c2b3:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 804c2b9:	89 01                	mov    %eax,(%ecx)
 804c2bb:	89 51 04             	mov    %edx,0x4(%ecx)
                return (tmp.q);
 804c2be:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c2c1:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804c2c4:	e9 c5 05 00 00       	jmp    804c88e <__qdivrem+0x65c>
        }
        if (uq < vq) {
 804c2c9:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 804c2cf:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 804c2d5:	3b 95 54 ff ff ff    	cmp    -0xac(%ebp),%edx
 804c2db:	77 39                	ja     804c316 <__qdivrem+0xe4>
 804c2dd:	3b 95 54 ff ff ff    	cmp    -0xac(%ebp),%edx
 804c2e3:	72 08                	jb     804c2ed <__qdivrem+0xbb>
 804c2e5:	3b 85 50 ff ff ff    	cmp    -0xb0(%ebp),%eax
 804c2eb:	73 29                	jae    804c316 <__qdivrem+0xe4>
                if (arq)
 804c2ed:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804c2f1:	74 14                	je     804c307 <__qdivrem+0xd5>
                        *arq = uq;
 804c2f3:	8b 4d 18             	mov    0x18(%ebp),%ecx
 804c2f6:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 804c2fc:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 804c302:	89 01                	mov    %eax,(%ecx)
 804c304:	89 51 04             	mov    %edx,0x4(%ecx)
                return (0);
 804c307:	b8 00 00 00 00       	mov    $0x0,%eax
 804c30c:	ba 00 00 00 00       	mov    $0x0,%edx
 804c311:	e9 78 05 00 00       	jmp    804c88e <__qdivrem+0x65c>
        }
        u = &uspace[0];
 804c316:	8d 45 90             	lea    -0x70(%ebp),%eax
 804c319:	89 45 ec             	mov    %eax,-0x14(%ebp)
        v = &vspace[0];
 804c31c:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
 804c322:	89 45 e8             	mov    %eax,-0x18(%ebp)
        q = &qspace[0];
 804c325:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
 804c32b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
         *      m >= 0 (otherwise u < v, which we already checked)
         *      m + n = 4
         * and thus
         *      m = 4 - n <= 2
         */
        tmp.uq = uq;
 804c32e:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 804c334:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 804c33a:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804c33d:	89 55 a8             	mov    %edx,-0x58(%ebp)
        u[0] = 0;
 804c340:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c343:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        u[1] = HHALF(tmp.ul[H]);
 804c349:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c34c:	83 c0 04             	add    $0x4,%eax
 804c34f:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804c352:	c1 ea 10             	shr    $0x10,%edx
 804c355:	89 10                	mov    %edx,(%eax)
        u[2] = LHALF(tmp.ul[H]);
 804c357:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c35a:	83 c0 08             	add    $0x8,%eax
 804c35d:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804c360:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804c366:	89 10                	mov    %edx,(%eax)
        u[3] = HHALF(tmp.ul[L]);
 804c368:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c36b:	83 c0 0c             	add    $0xc,%eax
 804c36e:	8b 55 a4             	mov    -0x5c(%ebp),%edx
 804c371:	c1 ea 10             	shr    $0x10,%edx
 804c374:	89 10                	mov    %edx,(%eax)
        u[4] = LHALF(tmp.ul[L]);
 804c376:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c379:	83 c0 10             	add    $0x10,%eax
 804c37c:	8b 55 a4             	mov    -0x5c(%ebp),%edx
 804c37f:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804c385:	89 10                	mov    %edx,(%eax)
        tmp.uq = vq;
 804c387:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
 804c38d:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
 804c393:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804c396:	89 55 a8             	mov    %edx,-0x58(%ebp)
        v[1] = HHALF(tmp.ul[H]);
 804c399:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c39c:	83 c0 04             	add    $0x4,%eax
 804c39f:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804c3a2:	c1 ea 10             	shr    $0x10,%edx
 804c3a5:	89 10                	mov    %edx,(%eax)
        v[2] = LHALF(tmp.ul[H]);
 804c3a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c3aa:	83 c0 08             	add    $0x8,%eax
 804c3ad:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804c3b0:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804c3b6:	89 10                	mov    %edx,(%eax)
        v[3] = HHALF(tmp.ul[L]);
 804c3b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c3bb:	83 c0 0c             	add    $0xc,%eax
 804c3be:	8b 55 a4             	mov    -0x5c(%ebp),%edx
 804c3c1:	c1 ea 10             	shr    $0x10,%edx
 804c3c4:	89 10                	mov    %edx,(%eax)
        v[4] = LHALF(tmp.ul[L]);
 804c3c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c3c9:	83 c0 10             	add    $0x10,%eax
 804c3cc:	8b 55 a4             	mov    -0x5c(%ebp),%edx
 804c3cf:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804c3d5:	89 10                	mov    %edx,(%eax)
        for (n = 4; v[1] == 0; v++) {
 804c3d7:	c7 45 d4 04 00 00 00 	movl   $0x4,-0x2c(%ebp)
 804c3de:	e9 fd 00 00 00       	jmp    804c4e0 <__qdivrem+0x2ae>
                if (--n == 1) {
 804c3e3:	83 6d d4 01          	subl   $0x1,-0x2c(%ebp)
 804c3e7:	83 7d d4 01          	cmpl   $0x1,-0x2c(%ebp)
 804c3eb:	0f 85 eb 00 00 00    	jne    804c4dc <__qdivrem+0x2aa>
                         *      for j = 1..4:
                         *              q[j] = floor((r*B + u[j]) / v),
                         *              r = (r*B + u[j]) % v;
                         * We unroll this completely here.
                         */
                        t = v[2];       /* nonzero, by definition */
 804c3f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c3f4:	8b 40 08             	mov    0x8(%eax),%eax
 804c3f7:	89 45 dc             	mov    %eax,-0x24(%ebp)
                        q1 = u[1] / t;
 804c3fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c3fd:	83 c0 04             	add    $0x4,%eax
 804c400:	8b 00                	mov    (%eax),%eax
 804c402:	ba 00 00 00 00       	mov    $0x0,%edx
 804c407:	f7 75 dc             	divl   -0x24(%ebp)
 804c40a:	89 45 c0             	mov    %eax,-0x40(%ebp)
                        rbj = COMBINE(u[1] % t, u[2]);
 804c40d:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c410:	83 c0 04             	add    $0x4,%eax
 804c413:	8b 00                	mov    (%eax),%eax
 804c415:	ba 00 00 00 00       	mov    $0x0,%edx
 804c41a:	f7 75 dc             	divl   -0x24(%ebp)
 804c41d:	89 d0                	mov    %edx,%eax
 804c41f:	89 c2                	mov    %eax,%edx
 804c421:	c1 e2 10             	shl    $0x10,%edx
 804c424:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c427:	83 c0 08             	add    $0x8,%eax
 804c42a:	8b 00                	mov    (%eax),%eax
 804c42c:	09 d0                	or     %edx,%eax
 804c42e:	89 45 bc             	mov    %eax,-0x44(%ebp)
                        q2 = rbj / t;
 804c431:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c434:	ba 00 00 00 00       	mov    $0x0,%edx
 804c439:	f7 75 dc             	divl   -0x24(%ebp)
 804c43c:	89 45 b8             	mov    %eax,-0x48(%ebp)
                        rbj = COMBINE(rbj % t, u[3]);
 804c43f:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c442:	ba 00 00 00 00       	mov    $0x0,%edx
 804c447:	f7 75 dc             	divl   -0x24(%ebp)
 804c44a:	89 d0                	mov    %edx,%eax
 804c44c:	89 c2                	mov    %eax,%edx
 804c44e:	c1 e2 10             	shl    $0x10,%edx
 804c451:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c454:	83 c0 0c             	add    $0xc,%eax
 804c457:	8b 00                	mov    (%eax),%eax
 804c459:	09 d0                	or     %edx,%eax
 804c45b:	89 45 bc             	mov    %eax,-0x44(%ebp)
                        q3 = rbj / t;
 804c45e:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c461:	ba 00 00 00 00       	mov    $0x0,%edx
 804c466:	f7 75 dc             	divl   -0x24(%ebp)
 804c469:	89 45 b4             	mov    %eax,-0x4c(%ebp)
                        rbj = COMBINE(rbj % t, u[4]);
 804c46c:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c46f:	ba 00 00 00 00       	mov    $0x0,%edx
 804c474:	f7 75 dc             	divl   -0x24(%ebp)
 804c477:	89 d0                	mov    %edx,%eax
 804c479:	89 c2                	mov    %eax,%edx
 804c47b:	c1 e2 10             	shl    $0x10,%edx
 804c47e:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c481:	83 c0 10             	add    $0x10,%eax
 804c484:	8b 00                	mov    (%eax),%eax
 804c486:	09 d0                	or     %edx,%eax
 804c488:	89 45 bc             	mov    %eax,-0x44(%ebp)
                        q4 = rbj / t;
 804c48b:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c48e:	ba 00 00 00 00       	mov    $0x0,%edx
 804c493:	f7 75 dc             	divl   -0x24(%ebp)
 804c496:	89 45 b0             	mov    %eax,-0x50(%ebp)
                        if (arq)
 804c499:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804c49d:	74 1a                	je     804c4b9 <__qdivrem+0x287>
                                *arq = rbj % t;
 804c49f:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c4a2:	ba 00 00 00 00       	mov    $0x0,%edx
 804c4a7:	f7 75 dc             	divl   -0x24(%ebp)
 804c4aa:	89 d0                	mov    %edx,%eax
 804c4ac:	ba 00 00 00 00       	mov    $0x0,%edx
 804c4b1:	8b 4d 18             	mov    0x18(%ebp),%ecx
 804c4b4:	89 01                	mov    %eax,(%ecx)
 804c4b6:	89 51 04             	mov    %edx,0x4(%ecx)
                        tmp.ul[H] = COMBINE(q1, q2);
 804c4b9:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c4bc:	c1 e0 10             	shl    $0x10,%eax
 804c4bf:	0b 45 b8             	or     -0x48(%ebp),%eax
 804c4c2:	89 45 a8             	mov    %eax,-0x58(%ebp)
                        tmp.ul[L] = COMBINE(q3, q4);
 804c4c5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804c4c8:	c1 e0 10             	shl    $0x10,%eax
 804c4cb:	0b 45 b0             	or     -0x50(%ebp),%eax
 804c4ce:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                        return (tmp.q);
 804c4d1:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c4d4:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804c4d7:	e9 b2 03 00 00       	jmp    804c88e <__qdivrem+0x65c>
        tmp.uq = vq;
        v[1] = HHALF(tmp.ul[H]);
        v[2] = LHALF(tmp.ul[H]);
        v[3] = HHALF(tmp.ul[L]);
        v[4] = LHALF(tmp.ul[L]);
        for (n = 4; v[1] == 0; v++) {
 804c4dc:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
 804c4e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c4e3:	83 c0 04             	add    $0x4,%eax
 804c4e6:	8b 00                	mov    (%eax),%eax
 804c4e8:	85 c0                	test   %eax,%eax
 804c4ea:	0f 84 f3 fe ff ff    	je     804c3e3 <__qdivrem+0x1b1>
        /*
         * By adjusting q once we determine m, we can guarantee that
         * there is a complete four-digit quotient at &qspace[1] when
         * we finally stop.
         */
        for (m = 4 - n; u[1] == 0; u++)
 804c4f0:	b8 04 00 00 00       	mov    $0x4,%eax
 804c4f5:	2b 45 d4             	sub    -0x2c(%ebp),%eax
 804c4f8:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804c4fb:	eb 08                	jmp    804c505 <__qdivrem+0x2d3>
                m--;
 804c4fd:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
        /*
         * By adjusting q once we determine m, we can guarantee that
         * there is a complete four-digit quotient at &qspace[1] when
         * we finally stop.
         */
        for (m = 4 - n; u[1] == 0; u++)
 804c501:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
 804c505:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c508:	83 c0 04             	add    $0x4,%eax
 804c50b:	8b 00                	mov    (%eax),%eax
 804c50d:	85 c0                	test   %eax,%eax
 804c50f:	74 ec                	je     804c4fd <__qdivrem+0x2cb>
                m--;
        for (i = 4 - m; --i >= 0;)
 804c511:	b8 04 00 00 00       	mov    $0x4,%eax
 804c516:	2b 45 d8             	sub    -0x28(%ebp),%eax
 804c519:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804c51c:	eb 0f                	jmp    804c52d <__qdivrem+0x2fb>
                q[i] = 0;
 804c51e:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804c521:	c1 e0 02             	shl    $0x2,%eax
 804c524:	03 45 c4             	add    -0x3c(%ebp),%eax
 804c527:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
         * there is a complete four-digit quotient at &qspace[1] when
         * we finally stop.
         */
        for (m = 4 - n; u[1] == 0; u++)
                m--;
        for (i = 4 - m; --i >= 0;)
 804c52d:	83 6d c8 01          	subl   $0x1,-0x38(%ebp)
 804c531:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804c535:	79 e7                	jns    804c51e <__qdivrem+0x2ec>
                q[i] = 0;
        q += 4 - m;
 804c537:	b8 04 00 00 00       	mov    $0x4,%eax
 804c53c:	2b 45 d8             	sub    -0x28(%ebp),%eax
 804c53f:	c1 e0 02             	shl    $0x2,%eax
 804c542:	01 45 c4             	add    %eax,-0x3c(%ebp)
         * Here we run Program D, translated from MIX to C and acquiring
         * a few minor changes.
         *
         * D1: choose multiplier 1 << d to ensure v[1] >= B/2.
         */
        d = 0;
 804c545:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
        for (t = v[1]; t < B / 2; t <<= 1)
 804c54c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c54f:	8b 40 04             	mov    0x4(%eax),%eax
 804c552:	89 45 dc             	mov    %eax,-0x24(%ebp)
 804c555:	eb 07                	jmp    804c55e <__qdivrem+0x32c>
                d++;
 804c557:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
         * a few minor changes.
         *
         * D1: choose multiplier 1 << d to ensure v[1] >= B/2.
         */
        d = 0;
        for (t = v[1]; t < B / 2; t <<= 1)
 804c55b:	d1 65 dc             	shll   -0x24(%ebp)
 804c55e:	81 7d dc ff 7f 00 00 	cmpl   $0x7fff,-0x24(%ebp)
 804c565:	76 f0                	jbe    804c557 <__qdivrem+0x325>
                d++;
        if (d > 0) {
 804c567:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804c56b:	7e 3d                	jle    804c5aa <__qdivrem+0x378>
                shl(&u[0], m + n, d);           /* u <<= d */
 804c56d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804c570:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804c573:	01 c2                	add    %eax,%edx
 804c575:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804c578:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c57c:	89 54 24 04          	mov    %edx,0x4(%esp)
 804c580:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c583:	89 04 24             	mov    %eax,(%esp)
 804c586:	e8 1d fc ff ff       	call   804c1a8 <shl>
                shl(&v[1], n - 1, d);           /* v <<= d */
 804c58b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804c58e:	8d 48 ff             	lea    -0x1(%eax),%ecx
 804c591:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c594:	8d 50 04             	lea    0x4(%eax),%edx
 804c597:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804c59a:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c59e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 804c5a2:	89 14 24             	mov    %edx,(%esp)
 804c5a5:	e8 fe fb ff ff       	call   804c1a8 <shl>
        }
        /*
         * D2: j = 0.
         */
        j = 0;
 804c5aa:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
        v1 = v[1];      /* for D3 -- note that v[1..n] are constant */
 804c5b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c5b4:	8b 70 04             	mov    0x4(%eax),%esi
        v2 = v[2];      /* for D3 */
 804c5b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c5ba:	8b 40 08             	mov    0x8(%eax),%eax
 804c5bd:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
                 * let rhat = (u[j]*B + u[j+1]) mod v[1].
                 * While rhat < B and v[2]*qhat > rhat*B+u[j+2],
                 * decrement qhat and increase rhat correspondingly.
                 * Note that if rhat >= B, v[2]*qhat < rhat*B.
                 */
                uj0 = u[j + 0]; /* for D3 only -- note that u[j+...] change */
 804c5c3:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804c5c6:	c1 e0 02             	shl    $0x2,%eax
 804c5c9:	03 45 ec             	add    -0x14(%ebp),%eax
 804c5cc:	8b 00                	mov    (%eax),%eax
 804c5ce:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
                uj1 = u[j + 1]; /* for D3 only */
 804c5d4:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804c5d7:	83 c0 01             	add    $0x1,%eax
 804c5da:	c1 e0 02             	shl    $0x2,%eax
 804c5dd:	03 45 ec             	add    -0x14(%ebp),%eax
 804c5e0:	8b 38                	mov    (%eax),%edi
                uj2 = u[j + 2]; /* for D3 only */
 804c5e2:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804c5e5:	83 c0 02             	add    $0x2,%eax
 804c5e8:	c1 e0 02             	shl    $0x2,%eax
 804c5eb:	03 45 ec             	add    -0x14(%ebp),%eax
 804c5ee:	8b 00                	mov    (%eax),%eax
 804c5f0:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
                if (uj0 == v1) {
 804c5f6:	39 b5 48 ff ff ff    	cmp    %esi,-0xb8(%ebp)
 804c5fc:	75 0c                	jne    804c60a <__qdivrem+0x3d8>
                        qhat = B;
 804c5fe:	c7 45 e4 00 00 01 00 	movl   $0x10000,-0x1c(%ebp)
                        rhat = uj1;
 804c605:	89 7d e0             	mov    %edi,-0x20(%ebp)
                        goto qhat_too_big;
 804c608:	eb 2a                	jmp    804c634 <__qdivrem+0x402>
                } else {
                        unsigned long nn = COMBINE(uj0, uj1);
 804c60a:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
 804c610:	c1 e0 10             	shl    $0x10,%eax
 804c613:	09 f8                	or     %edi,%eax
 804c615:	89 45 ac             	mov    %eax,-0x54(%ebp)
                        qhat = nn / v1;
 804c618:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804c61b:	ba 00 00 00 00       	mov    $0x0,%edx
 804c620:	f7 f6                	div    %esi
 804c622:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                        rhat = nn % v1;
 804c625:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804c628:	ba 00 00 00 00       	mov    $0x0,%edx
 804c62d:	f7 f6                	div    %esi
 804c62f:	89 55 e0             	mov    %edx,-0x20(%ebp)
                }
                while (v2 * qhat > COMBINE(rhat, uj2)) {
 804c632:	eb 10                	jmp    804c644 <__qdivrem+0x412>
qhat_too_big:
                        qhat--;
 804c634:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
                        if ((rhat += v1) >= B)
 804c638:	01 75 e0             	add    %esi,-0x20(%ebp)
 804c63b:	81 7d e0 ff ff 00 00 	cmpl   $0xffff,-0x20(%ebp)
 804c642:	77 1c                	ja     804c660 <__qdivrem+0x42e>
                } else {
                        unsigned long nn = COMBINE(uj0, uj1);
                        qhat = nn / v1;
                        rhat = nn % v1;
                }
                while (v2 * qhat > COMBINE(rhat, uj2)) {
 804c644:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
 804c64a:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
 804c64e:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804c651:	c1 e2 10             	shl    $0x10,%edx
 804c654:	0b 95 44 ff ff ff    	or     -0xbc(%ebp),%edx
 804c65a:	39 d0                	cmp    %edx,%eax
 804c65c:	77 d6                	ja     804c634 <__qdivrem+0x402>
 804c65e:	eb 01                	jmp    804c661 <__qdivrem+0x42f>
qhat_too_big:
                        qhat--;
                        if ((rhat += v1) >= B)
                                break;
 804c660:	90                   	nop
                 * D4: Multiply and subtract.
                 * The variable `t' holds any borrows across the loop.
                 * We split this up so that we do not require v[0] = 0,
                 * and to eliminate a final special case.
                 */
                for (t = 0, i = n; i > 0; i--) {
 804c661:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 804c668:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804c66b:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804c66e:	eb 58                	jmp    804c6c8 <__qdivrem+0x496>
                        t = u[i + j] - v[i] * qhat - t;
 804c670:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804c673:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804c676:	01 d0                	add    %edx,%eax
 804c678:	c1 e0 02             	shl    $0x2,%eax
 804c67b:	03 45 ec             	add    -0x14(%ebp),%eax
 804c67e:	8b 10                	mov    (%eax),%edx
 804c680:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804c683:	c1 e0 02             	shl    $0x2,%eax
 804c686:	03 45 e8             	add    -0x18(%ebp),%eax
 804c689:	8b 00                	mov    (%eax),%eax
 804c68b:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
 804c68f:	89 d1                	mov    %edx,%ecx
 804c691:	29 c1                	sub    %eax,%ecx
 804c693:	89 c8                	mov    %ecx,%eax
 804c695:	2b 45 dc             	sub    -0x24(%ebp),%eax
 804c698:	89 45 dc             	mov    %eax,-0x24(%ebp)
                        u[i + j] = LHALF(t);
 804c69b:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804c69e:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804c6a1:	01 d0                	add    %edx,%eax
 804c6a3:	c1 e0 02             	shl    $0x2,%eax
 804c6a6:	03 45 ec             	add    -0x14(%ebp),%eax
 804c6a9:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804c6ac:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804c6b2:	89 10                	mov    %edx,(%eax)
                        t = (B - HHALF(t)) & (B - 1);
 804c6b4:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804c6b7:	c1 e8 10             	shr    $0x10,%eax
 804c6ba:	f7 d8                	neg    %eax
 804c6bc:	25 ff ff 00 00       	and    $0xffff,%eax
 804c6c1:	89 45 dc             	mov    %eax,-0x24(%ebp)
                 * D4: Multiply and subtract.
                 * The variable `t' holds any borrows across the loop.
                 * We split this up so that we do not require v[0] = 0,
                 * and to eliminate a final special case.
                 */
                for (t = 0, i = n; i > 0; i--) {
 804c6c4:	83 6d c8 01          	subl   $0x1,-0x38(%ebp)
 804c6c8:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804c6cc:	7f a2                	jg     804c670 <__qdivrem+0x43e>
                        t = u[i + j] - v[i] * qhat - t;
                        u[i + j] = LHALF(t);
                        t = (B - HHALF(t)) & (B - 1);
                }
                t = u[j] - t;
 804c6ce:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804c6d1:	c1 e0 02             	shl    $0x2,%eax
 804c6d4:	03 45 ec             	add    -0x14(%ebp),%eax
 804c6d7:	8b 00                	mov    (%eax),%eax
 804c6d9:	2b 45 dc             	sub    -0x24(%ebp),%eax
 804c6dc:	89 45 dc             	mov    %eax,-0x24(%ebp)
                u[j] = LHALF(t);
 804c6df:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804c6e2:	c1 e0 02             	shl    $0x2,%eax
 804c6e5:	03 45 ec             	add    -0x14(%ebp),%eax
 804c6e8:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804c6eb:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804c6f1:	89 10                	mov    %edx,(%eax)
                 * D5: test remainder.
                 * There is a borrow if and only if HHALF(t) is nonzero;
                 * in that (rare) case, qhat was too large (by exactly 1).
                 * Fix it by adding v[1..n] to u[j..j+n].
                 */
                if (HHALF(t)) {
 804c6f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804c6f6:	c1 e8 10             	shr    $0x10,%eax
 804c6f9:	85 c0                	test   %eax,%eax
 804c6fb:	74 79                	je     804c776 <__qdivrem+0x544>
                        qhat--;
 804c6fd:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
                        for (t = 0, i = n; i > 0; i--) { /* D6: add back. */
 804c701:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 804c708:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804c70b:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804c70e:	eb 41                	jmp    804c751 <__qdivrem+0x51f>
                                t += u[i + j] + v[i];
 804c710:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804c713:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804c716:	01 d0                	add    %edx,%eax
 804c718:	c1 e0 02             	shl    $0x2,%eax
 804c71b:	03 45 ec             	add    -0x14(%ebp),%eax
 804c71e:	8b 10                	mov    (%eax),%edx
 804c720:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804c723:	c1 e0 02             	shl    $0x2,%eax
 804c726:	03 45 e8             	add    -0x18(%ebp),%eax
 804c729:	8b 00                	mov    (%eax),%eax
 804c72b:	01 d0                	add    %edx,%eax
 804c72d:	01 45 dc             	add    %eax,-0x24(%ebp)
                                u[i + j] = LHALF(t);
 804c730:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804c733:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804c736:	01 d0                	add    %edx,%eax
 804c738:	c1 e0 02             	shl    $0x2,%eax
 804c73b:	03 45 ec             	add    -0x14(%ebp),%eax
 804c73e:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804c741:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804c747:	89 10                	mov    %edx,(%eax)
                                t = HHALF(t);
 804c749:	c1 6d dc 10          	shrl   $0x10,-0x24(%ebp)
                 * in that (rare) case, qhat was too large (by exactly 1).
                 * Fix it by adding v[1..n] to u[j..j+n].
                 */
                if (HHALF(t)) {
                        qhat--;
                        for (t = 0, i = n; i > 0; i--) { /* D6: add back. */
 804c74d:	83 6d c8 01          	subl   $0x1,-0x38(%ebp)
 804c751:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804c755:	7f b9                	jg     804c710 <__qdivrem+0x4de>
                                t += u[i + j] + v[i];
                                u[i + j] = LHALF(t);
                                t = HHALF(t);
                        }
                        u[j] = LHALF(u[j] + t);
 804c757:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804c75a:	c1 e0 02             	shl    $0x2,%eax
 804c75d:	03 45 ec             	add    -0x14(%ebp),%eax
 804c760:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804c763:	c1 e2 02             	shl    $0x2,%edx
 804c766:	03 55 ec             	add    -0x14(%ebp),%edx
 804c769:	8b 12                	mov    (%edx),%edx
 804c76b:	03 55 dc             	add    -0x24(%ebp),%edx
 804c76e:	81 e2 ff ff 00 00    	and    $0xffff,%edx
 804c774:	89 10                	mov    %edx,(%eax)
                }
                q[j] = qhat;
 804c776:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804c779:	c1 e0 02             	shl    $0x2,%eax
 804c77c:	03 45 c4             	add    -0x3c(%ebp),%eax
 804c77f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804c782:	89 10                	mov    %edx,(%eax)
        } while (++j <= m);             /* D7: loop on j. */
 804c784:	83 45 cc 01          	addl   $0x1,-0x34(%ebp)
 804c788:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804c78b:	3b 45 d8             	cmp    -0x28(%ebp),%eax
 804c78e:	0f 8e 2f fe ff ff    	jle    804c5c3 <__qdivrem+0x391>
        /*
         * If caller wants the remainder, we have to calculate it as
         * u[m..m+n] >> d (this is at most n digits and thus fits in
         * u[m+1..m+n], but we may need more source digits).
         */
        if (arq) {
 804c794:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804c798:	0f 84 be 00 00 00    	je     804c85c <__qdivrem+0x62a>
                if (d) {
 804c79e:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804c7a2:	0f 84 86 00 00 00    	je     804c82e <__qdivrem+0x5fc>
                        for (i = m + n; i > m; --i)
 804c7a8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804c7ab:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804c7ae:	01 d0                	add    %edx,%eax
 804c7b0:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804c7b3:	eb 62                	jmp    804c817 <__qdivrem+0x5e5>
                                u[i] = (u[i] >> d) |
 804c7b5:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804c7b8:	c1 e0 02             	shl    $0x2,%eax
 804c7bb:	03 45 ec             	add    -0x14(%ebp),%eax
 804c7be:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804c7c1:	c1 e2 02             	shl    $0x2,%edx
 804c7c4:	03 55 ec             	add    -0x14(%ebp),%edx
 804c7c7:	8b 32                	mov    (%edx),%esi
 804c7c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804c7cc:	89 f7                	mov    %esi,%edi
 804c7ce:	89 d1                	mov    %edx,%ecx
 804c7d0:	d3 ef                	shr    %cl,%edi
                                       LHALF(u[i - 1] << (HALF_BITS - d));
 804c7d2:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804c7d5:	83 ea 01             	sub    $0x1,%edx
 804c7d8:	c1 e2 02             	shl    $0x2,%edx
 804c7db:	03 55 ec             	add    -0x14(%ebp),%edx
 804c7de:	8b 12                	mov    (%edx),%edx
 804c7e0:	89 95 3c ff ff ff    	mov    %edx,-0xc4(%ebp)
 804c7e6:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804c7e9:	c7 85 38 ff ff ff 10 	movl   $0x10,-0xc8(%ebp)
 804c7f0:	00 00 00 
 804c7f3:	8b b5 38 ff ff ff    	mov    -0xc8(%ebp),%esi
 804c7f9:	29 d6                	sub    %edx,%esi
 804c7fb:	89 f2                	mov    %esi,%edx
 804c7fd:	8b b5 3c ff ff ff    	mov    -0xc4(%ebp),%esi
 804c803:	89 d1                	mov    %edx,%ecx
 804c805:	d3 e6                	shl    %cl,%esi
 804c807:	89 f2                	mov    %esi,%edx
 804c809:	81 e2 ff ff 00 00    	and    $0xffff,%edx
         * u[m+1..m+n], but we may need more source digits).
         */
        if (arq) {
                if (d) {
                        for (i = m + n; i > m; --i)
                                u[i] = (u[i] >> d) |
 804c80f:	09 fa                	or     %edi,%edx
 804c811:	89 10                	mov    %edx,(%eax)
         * u[m..m+n] >> d (this is at most n digits and thus fits in
         * u[m+1..m+n], but we may need more source digits).
         */
        if (arq) {
                if (d) {
                        for (i = m + n; i > m; --i)
 804c813:	83 6d c8 01          	subl   $0x1,-0x38(%ebp)
 804c817:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804c81a:	3b 45 d8             	cmp    -0x28(%ebp),%eax
 804c81d:	7f 96                	jg     804c7b5 <__qdivrem+0x583>
                                u[i] = (u[i] >> d) |
                                       LHALF(u[i - 1] << (HALF_BITS - d));
                        u[i] = 0;
 804c81f:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804c822:	c1 e0 02             	shl    $0x2,%eax
 804c825:	03 45 ec             	add    -0x14(%ebp),%eax
 804c828:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                }
                tmp.ul[H] = COMBINE(uspace[1], uspace[2]);
 804c82e:	8b 45 94             	mov    -0x6c(%ebp),%eax
 804c831:	89 c2                	mov    %eax,%edx
 804c833:	c1 e2 10             	shl    $0x10,%edx
 804c836:	8b 45 98             	mov    -0x68(%ebp),%eax
 804c839:	09 d0                	or     %edx,%eax
 804c83b:	89 45 a8             	mov    %eax,-0x58(%ebp)
                tmp.ul[L] = COMBINE(uspace[3], uspace[4]);
 804c83e:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804c841:	89 c2                	mov    %eax,%edx
 804c843:	c1 e2 10             	shl    $0x10,%edx
 804c846:	8b 45 a0             	mov    -0x60(%ebp),%eax
 804c849:	09 d0                	or     %edx,%eax
 804c84b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                *arq = tmp.q;
 804c84e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c851:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804c854:	8b 4d 18             	mov    0x18(%ebp),%ecx
 804c857:	89 01                	mov    %eax,(%ecx)
 804c859:	89 51 04             	mov    %edx,0x4(%ecx)
        }

        tmp.ul[H] = COMBINE(qspace[1], qspace[2]);
 804c85c:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
 804c862:	89 c2                	mov    %eax,%edx
 804c864:	c1 e2 10             	shl    $0x10,%edx
 804c867:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
 804c86d:	09 d0                	or     %edx,%eax
 804c86f:	89 45 a8             	mov    %eax,-0x58(%ebp)
        tmp.ul[L] = COMBINE(qspace[3], qspace[4]);
 804c872:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
 804c878:	89 c2                	mov    %eax,%edx
 804c87a:	c1 e2 10             	shl    $0x10,%edx
 804c87d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
 804c883:	09 d0                	or     %edx,%eax
 804c885:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        return (tmp.q);
 804c888:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c88b:	8b 55 a8             	mov    -0x58(%ebp),%edx
}
 804c88e:	81 c4 c8 00 00 00    	add    $0xc8,%esp
 804c894:	5b                   	pop    %ebx
 804c895:	5e                   	pop    %esi
 804c896:	5f                   	pop    %edi
 804c897:	5d                   	pop    %ebp
 804c898:	c3                   	ret    

0804c899 <__divdi3>:
/*
 * Divide two signed quads.
 * ??? if -1/2 should produce -1 on this machine, this code is wrong
 */
long long __divdi3(long long a, long long b)
{
 804c899:	55                   	push   %ebp
 804c89a:	89 e5                	mov    %esp,%ebp
 804c89c:	53                   	push   %ebx
 804c89d:	83 ec 54             	sub    $0x54,%esp
 804c8a0:	e8 c0 bb ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804c8a5:	81 c3 07 39 00 00    	add    $0x3907,%ebx
 804c8ab:	8b 45 08             	mov    0x8(%ebp),%eax
 804c8ae:	89 45 d0             	mov    %eax,-0x30(%ebp)
 804c8b1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c8b4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804c8b7:	8b 45 10             	mov    0x10(%ebp),%eax
 804c8ba:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804c8bd:	8b 45 14             	mov    0x14(%ebp),%eax
 804c8c0:	89 45 cc             	mov    %eax,-0x34(%ebp)
        unsigned long long ua, ub, uq;
        int neg;

        if (a < 0)
 804c8c3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804c8c7:	79 1c                	jns    804c8e5 <__divdi3+0x4c>
                ua = -(unsigned long long)a, neg = 1;
 804c8c9:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804c8cc:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804c8cf:	f7 d8                	neg    %eax
 804c8d1:	83 d2 00             	adc    $0x0,%edx
 804c8d4:	f7 da                	neg    %edx
 804c8d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c8d9:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804c8dc:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
 804c8e3:	eb 13                	jmp    804c8f8 <__divdi3+0x5f>
        else
                ua = a, neg = 0;
 804c8e5:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804c8e8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804c8eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c8ee:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804c8f1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if (b < 0)
 804c8f8:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
 804c8fc:	79 19                	jns    804c917 <__divdi3+0x7e>
                ub = -(unsigned long long)b, neg ^= 1;
 804c8fe:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804c901:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804c904:	f7 d8                	neg    %eax
 804c906:	83 d2 00             	adc    $0x0,%edx
 804c909:	f7 da                	neg    %edx
 804c90b:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804c90e:	89 55 ec             	mov    %edx,-0x14(%ebp)
 804c911:	83 75 e4 01          	xorl   $0x1,-0x1c(%ebp)
 804c915:	eb 0c                	jmp    804c923 <__divdi3+0x8a>
        else
                ub = b;
 804c917:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804c91a:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804c91d:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804c920:	89 55 ec             	mov    %edx,-0x14(%ebp)
        uq = __qdivrem(ua, ub, (unsigned long long *)0);
 804c923:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c92a:	00 
 804c92b:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c92e:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804c931:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c935:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804c939:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c93c:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804c93f:	89 04 24             	mov    %eax,(%esp)
 804c942:	89 54 24 04          	mov    %edx,0x4(%esp)
 804c946:	e8 e7 f8 ff ff       	call   804c232 <__qdivrem>
 804c94b:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804c94e:	89 55 dc             	mov    %edx,-0x24(%ebp)
        return (neg ? -uq : uq);
 804c951:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804c955:	74 0f                	je     804c966 <__divdi3+0xcd>
 804c957:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c95a:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804c95d:	f7 d8                	neg    %eax
 804c95f:	83 d2 00             	adc    $0x0,%edx
 804c962:	f7 da                	neg    %edx
 804c964:	eb 06                	jmp    804c96c <__divdi3+0xd3>
 804c966:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c969:	8b 55 dc             	mov    -0x24(%ebp),%edx
}
 804c96c:	83 c4 54             	add    $0x54,%esp
 804c96f:	5b                   	pop    %ebx
 804c970:	5d                   	pop    %ebp
 804c971:	c3                   	ret    

0804c972 <__udivdi3>:
/*
 * Divide two unsigned quads.
 */
unsigned long long
__udivdi3(unsigned long long a, unsigned long long b)
{
 804c972:	55                   	push   %ebp
 804c973:	89 e5                	mov    %esp,%ebp
 804c975:	53                   	push   %ebx
 804c976:	83 ec 34             	sub    $0x34,%esp
 804c979:	e8 e7 ba ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804c97e:	81 c3 2e 38 00 00    	add    $0x382e,%ebx
 804c984:	8b 45 08             	mov    0x8(%ebp),%eax
 804c987:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c98a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c98d:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804c990:	8b 45 10             	mov    0x10(%ebp),%eax
 804c993:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804c996:	8b 45 14             	mov    0x14(%ebp),%eax
 804c999:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return (__qdivrem(a, b, (unsigned long long *)0));
 804c99c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c9a3:	00 
 804c9a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c9a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804c9aa:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c9ae:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804c9b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c9b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804c9b8:	89 04 24             	mov    %eax,(%esp)
 804c9bb:	89 54 24 04          	mov    %edx,0x4(%esp)
 804c9bf:	e8 6e f8 ff ff       	call   804c232 <__qdivrem>
}
 804c9c4:	83 c4 34             	add    $0x34,%esp
 804c9c7:	5b                   	pop    %ebx
 804c9c8:	5d                   	pop    %ebp
 804c9c9:	c3                   	ret    

0804c9ca <__umoddi3>:
/*
 * Return remainder after dividing two unsigned quads.
 */
unsigned long long
__umoddi3(unsigned long long a, unsigned long long b)
{
 804c9ca:	55                   	push   %ebp
 804c9cb:	89 e5                	mov    %esp,%ebp
 804c9cd:	53                   	push   %ebx
 804c9ce:	83 ec 44             	sub    $0x44,%esp
 804c9d1:	e8 8f ba ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804c9d6:	81 c3 d6 37 00 00    	add    $0x37d6,%ebx
 804c9dc:	8b 45 08             	mov    0x8(%ebp),%eax
 804c9df:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804c9e2:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c9e5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804c9e8:	8b 45 10             	mov    0x10(%ebp),%eax
 804c9eb:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804c9ee:	8b 45 14             	mov    0x14(%ebp),%eax
 804c9f1:	89 45 dc             	mov    %eax,-0x24(%ebp)
        unsigned long long r;

        (void)__qdivrem(a, b, &r);
 804c9f4:	8d 45 f0             	lea    -0x10(%ebp),%eax
 804c9f7:	89 44 24 10          	mov    %eax,0x10(%esp)
 804c9fb:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c9fe:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804ca01:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ca05:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804ca09:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804ca0c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804ca0f:	89 04 24             	mov    %eax,(%esp)
 804ca12:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ca16:	e8 17 f8 ff ff       	call   804c232 <__qdivrem>
        return (r);
 804ca1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ca1e:	8b 55 f4             	mov    -0xc(%ebp),%edx
}
 804ca21:	83 c4 44             	add    $0x44,%esp
 804ca24:	5b                   	pop    %ebx
 804ca25:	5d                   	pop    %ebp
 804ca26:	c3                   	ret    
 804ca27:	90                   	nop

0804ca28 <memcmp>:
#include "stdlib.h"
#include "string.h"
#include "errno.h"

int memcmp(const void *cs, const void *ct, size_t count)
{
 804ca28:	55                   	push   %ebp
 804ca29:	89 e5                	mov    %esp,%ebp
 804ca2b:	83 ec 10             	sub    $0x10,%esp
        const unsigned char *su1, *su2;
        signed char res = 0;
 804ca2e:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

        for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
 804ca32:	8b 45 08             	mov    0x8(%ebp),%eax
 804ca35:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804ca38:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ca3b:	89 45 f8             	mov    %eax,-0x8(%ebp)
 804ca3e:	eb 27                	jmp    804ca67 <memcmp+0x3f>
                if ((res = *su1 - *su2) != 0)
 804ca40:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804ca43:	0f b6 10             	movzbl (%eax),%edx
 804ca46:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804ca49:	0f b6 00             	movzbl (%eax),%eax
 804ca4c:	89 d1                	mov    %edx,%ecx
 804ca4e:	28 c1                	sub    %al,%cl
 804ca50:	89 c8                	mov    %ecx,%eax
 804ca52:	88 45 f7             	mov    %al,-0x9(%ebp)
 804ca55:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
 804ca59:	75 14                	jne    804ca6f <memcmp+0x47>
int memcmp(const void *cs, const void *ct, size_t count)
{
        const unsigned char *su1, *su2;
        signed char res = 0;

        for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
 804ca5b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804ca5f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
 804ca63:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
 804ca67:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804ca6b:	75 d3                	jne    804ca40 <memcmp+0x18>
 804ca6d:	eb 01                	jmp    804ca70 <memcmp+0x48>
                if ((res = *su1 - *su2) != 0)
                        break;
 804ca6f:	90                   	nop
        return res;
 804ca70:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
}
 804ca74:	c9                   	leave  
 804ca75:	c3                   	ret    

0804ca76 <memcpy>:

void *memcpy(void *dest, const void *src, size_t count)
{
 804ca76:	55                   	push   %ebp
 804ca77:	89 e5                	mov    %esp,%ebp
 804ca79:	83 ec 10             	sub    $0x10,%esp
        char *tmp = (char *) dest;
 804ca7c:	8b 45 08             	mov    0x8(%ebp),%eax
 804ca7f:	89 45 fc             	mov    %eax,-0x4(%ebp)
        const char *s = src;
 804ca82:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ca85:	89 45 f8             	mov    %eax,-0x8(%ebp)

        while (count--)
 804ca88:	eb 13                	jmp    804ca9d <memcpy+0x27>
                *tmp++ = *s++;
 804ca8a:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804ca8d:	0f b6 10             	movzbl (%eax),%edx
 804ca90:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804ca93:	88 10                	mov    %dl,(%eax)
 804ca95:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804ca99:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
void *memcpy(void *dest, const void *src, size_t count)
{
        char *tmp = (char *) dest;
        const char *s = src;

        while (count--)
 804ca9d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804caa1:	0f 95 c0             	setne  %al
 804caa4:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
 804caa8:	84 c0                	test   %al,%al
 804caaa:	75 de                	jne    804ca8a <memcpy+0x14>
                *tmp++ = *s++;

        return dest;
 804caac:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804caaf:	c9                   	leave  
 804cab0:	c3                   	ret    

0804cab1 <strncmp>:

int strncmp(const char *cs, const char *ct, size_t count)
{
 804cab1:	55                   	push   %ebp
 804cab2:	89 e5                	mov    %esp,%ebp
 804cab4:	56                   	push   %esi
        register signed char __res = 0;
 804cab5:	be 00 00 00 00       	mov    $0x0,%esi

        while (count) {
 804caba:	eb 3c                	jmp    804caf8 <strncmp+0x47>
                if ((__res = *cs - *ct++) != 0 || !*cs++)
 804cabc:	8b 45 08             	mov    0x8(%ebp),%eax
 804cabf:	0f b6 00             	movzbl (%eax),%eax
 804cac2:	89 c2                	mov    %eax,%edx
 804cac4:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cac7:	0f b6 00             	movzbl (%eax),%eax
 804caca:	89 d1                	mov    %edx,%ecx
 804cacc:	28 c1                	sub    %al,%cl
 804cace:	89 c8                	mov    %ecx,%eax
 804cad0:	89 c6                	mov    %eax,%esi
 804cad2:	89 f0                	mov    %esi,%eax
 804cad4:	84 c0                	test   %al,%al
 804cad6:	0f 95 c0             	setne  %al
 804cad9:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
 804cadd:	84 c0                	test   %al,%al
 804cadf:	75 1d                	jne    804cafe <strncmp+0x4d>
 804cae1:	8b 45 08             	mov    0x8(%ebp),%eax
 804cae4:	0f b6 00             	movzbl (%eax),%eax
 804cae7:	84 c0                	test   %al,%al
 804cae9:	0f 94 c0             	sete   %al
 804caec:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804caf0:	84 c0                	test   %al,%al
 804caf2:	75 0a                	jne    804cafe <strncmp+0x4d>
                        break;
                count--;
 804caf4:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

int strncmp(const char *cs, const char *ct, size_t count)
{
        register signed char __res = 0;

        while (count) {
 804caf8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804cafc:	75 be                	jne    804cabc <strncmp+0xb>
                if ((__res = *cs - *ct++) != 0 || !*cs++)
                        break;
                count--;
        }

        return __res;
 804cafe:	89 f2                	mov    %esi,%edx
 804cb00:	0f be c2             	movsbl %dl,%eax
}
 804cb03:	5e                   	pop    %esi
 804cb04:	5d                   	pop    %ebp
 804cb05:	c3                   	ret    

0804cb06 <strcmp>:

int strcmp(const char *cs, const char *ct)
{
 804cb06:	55                   	push   %ebp
 804cb07:	89 e5                	mov    %esp,%ebp
 804cb09:	56                   	push   %esi
 804cb0a:	eb 01                	jmp    804cb0d <strcmp+0x7>
        register signed char __res;

        while (1) {
                if ((__res = *cs - *ct++) != 0 || !*cs++)
                        break;
        }
 804cb0c:	90                   	nop
int strcmp(const char *cs, const char *ct)
{
        register signed char __res;

        while (1) {
                if ((__res = *cs - *ct++) != 0 || !*cs++)
 804cb0d:	8b 45 08             	mov    0x8(%ebp),%eax
 804cb10:	0f b6 00             	movzbl (%eax),%eax
 804cb13:	89 c2                	mov    %eax,%edx
 804cb15:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cb18:	0f b6 00             	movzbl (%eax),%eax
 804cb1b:	89 d1                	mov    %edx,%ecx
 804cb1d:	28 c1                	sub    %al,%cl
 804cb1f:	89 c8                	mov    %ecx,%eax
 804cb21:	89 c6                	mov    %eax,%esi
 804cb23:	89 f0                	mov    %esi,%eax
 804cb25:	84 c0                	test   %al,%al
 804cb27:	0f 95 c0             	setne  %al
 804cb2a:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
 804cb2e:	84 c0                	test   %al,%al
 804cb30:	75 13                	jne    804cb45 <strcmp+0x3f>
 804cb32:	8b 45 08             	mov    0x8(%ebp),%eax
 804cb35:	0f b6 00             	movzbl (%eax),%eax
 804cb38:	84 c0                	test   %al,%al
 804cb3a:	0f 94 c0             	sete   %al
 804cb3d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804cb41:	84 c0                	test   %al,%al
 804cb43:	74 c7                	je     804cb0c <strcmp+0x6>
                        break;
        }

        return __res;
 804cb45:	89 f2                	mov    %esi,%edx
 804cb47:	0f be c2             	movsbl %dl,%eax
}
 804cb4a:	5e                   	pop    %esi
 804cb4b:	5d                   	pop    %ebp
 804cb4c:	c3                   	ret    

0804cb4d <strcpy>:

char *strcpy(char *dest, const char *src)
{
 804cb4d:	55                   	push   %ebp
 804cb4e:	89 e5                	mov    %esp,%ebp
 804cb50:	83 ec 10             	sub    $0x10,%esp
        char *tmp = dest;
 804cb53:	8b 45 08             	mov    0x8(%ebp),%eax
 804cb56:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while ((*dest++ = *src++) != '\0')
 804cb59:	90                   	nop
 804cb5a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cb5d:	0f b6 10             	movzbl (%eax),%edx
 804cb60:	8b 45 08             	mov    0x8(%ebp),%eax
 804cb63:	88 10                	mov    %dl,(%eax)
 804cb65:	8b 45 08             	mov    0x8(%ebp),%eax
 804cb68:	0f b6 00             	movzbl (%eax),%eax
 804cb6b:	84 c0                	test   %al,%al
 804cb6d:	0f 95 c0             	setne  %al
 804cb70:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804cb74:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
 804cb78:	84 c0                	test   %al,%al
 804cb7a:	75 de                	jne    804cb5a <strcpy+0xd>
                /* nothing */;
        return tmp;
 804cb7c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804cb7f:	c9                   	leave  
 804cb80:	c3                   	ret    

0804cb81 <strncpy>:

char *strncpy(char *dest, const char *src, size_t count)
{
 804cb81:	55                   	push   %ebp
 804cb82:	89 e5                	mov    %esp,%ebp
 804cb84:	83 ec 10             	sub    $0x10,%esp
        char *tmp = dest;
 804cb87:	8b 45 08             	mov    0x8(%ebp),%eax
 804cb8a:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (count-- && (*dest++ = *src++) != '\0')
 804cb8d:	90                   	nop
 804cb8e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804cb92:	0f 95 c0             	setne  %al
 804cb95:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
 804cb99:	84 c0                	test   %al,%al
 804cb9b:	74 22                	je     804cbbf <strncpy+0x3e>
 804cb9d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cba0:	0f b6 10             	movzbl (%eax),%edx
 804cba3:	8b 45 08             	mov    0x8(%ebp),%eax
 804cba6:	88 10                	mov    %dl,(%eax)
 804cba8:	8b 45 08             	mov    0x8(%ebp),%eax
 804cbab:	0f b6 00             	movzbl (%eax),%eax
 804cbae:	84 c0                	test   %al,%al
 804cbb0:	0f 95 c0             	setne  %al
 804cbb3:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804cbb7:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
 804cbbb:	84 c0                	test   %al,%al
 804cbbd:	75 cf                	jne    804cb8e <strncpy+0xd>
                /* nothing */;

        return tmp;
 804cbbf:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804cbc2:	c9                   	leave  
 804cbc3:	c3                   	ret    

0804cbc4 <memset>:

void *memset(void *s, int c, size_t count)
{
 804cbc4:	55                   	push   %ebp
 804cbc5:	89 e5                	mov    %esp,%ebp
 804cbc7:	83 ec 10             	sub    $0x10,%esp
        char *xs = (char *) s;
 804cbca:	8b 45 08             	mov    0x8(%ebp),%eax
 804cbcd:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (count--)
 804cbd0:	eb 0e                	jmp    804cbe0 <memset+0x1c>
                *xs++ = c;
 804cbd2:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cbd5:	89 c2                	mov    %eax,%edx
 804cbd7:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804cbda:	88 10                	mov    %dl,(%eax)
 804cbdc:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)

void *memset(void *s, int c, size_t count)
{
        char *xs = (char *) s;

        while (count--)
 804cbe0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804cbe4:	0f 95 c0             	setne  %al
 804cbe7:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
 804cbeb:	84 c0                	test   %al,%al
 804cbed:	75 e3                	jne    804cbd2 <memset+0xe>
                *xs++ = c;

        return s;
 804cbef:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804cbf2:	c9                   	leave  
 804cbf3:	c3                   	ret    

0804cbf4 <strnlen>:

size_t strnlen(const char *s, size_t count)
{
 804cbf4:	55                   	push   %ebp
 804cbf5:	89 e5                	mov    %esp,%ebp
 804cbf7:	83 ec 10             	sub    $0x10,%esp
        const char *sc;

        for (sc = s; count-- && *sc != '\0'; ++sc)
 804cbfa:	8b 45 08             	mov    0x8(%ebp),%eax
 804cbfd:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804cc00:	eb 04                	jmp    804cc06 <strnlen+0x12>
 804cc02:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804cc06:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804cc0a:	0f 95 c0             	setne  %al
 804cc0d:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
 804cc11:	84 c0                	test   %al,%al
 804cc13:	74 0a                	je     804cc1f <strnlen+0x2b>
 804cc15:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804cc18:	0f b6 00             	movzbl (%eax),%eax
 804cc1b:	84 c0                	test   %al,%al
 804cc1d:	75 e3                	jne    804cc02 <strnlen+0xe>
                /* nothing */;
        return sc - s;
 804cc1f:	8b 55 fc             	mov    -0x4(%ebp),%edx
 804cc22:	8b 45 08             	mov    0x8(%ebp),%eax
 804cc25:	89 d1                	mov    %edx,%ecx
 804cc27:	29 c1                	sub    %eax,%ecx
 804cc29:	89 c8                	mov    %ecx,%eax
}
 804cc2b:	c9                   	leave  
 804cc2c:	c3                   	ret    

0804cc2d <strcat>:


char *strcat(char *dest, const char *src)
{
 804cc2d:	55                   	push   %ebp
 804cc2e:	89 e5                	mov    %esp,%ebp
 804cc30:	83 ec 10             	sub    $0x10,%esp
        char *tmp = dest;
 804cc33:	8b 45 08             	mov    0x8(%ebp),%eax
 804cc36:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (*dest)
 804cc39:	eb 04                	jmp    804cc3f <strcat+0x12>
                dest++;
 804cc3b:	83 45 08 01          	addl   $0x1,0x8(%ebp)

char *strcat(char *dest, const char *src)
{
        char *tmp = dest;

        while (*dest)
 804cc3f:	8b 45 08             	mov    0x8(%ebp),%eax
 804cc42:	0f b6 00             	movzbl (%eax),%eax
 804cc45:	84 c0                	test   %al,%al
 804cc47:	75 f2                	jne    804cc3b <strcat+0xe>
                dest++;

        while ((*dest++ = *src++) != '\0');
 804cc49:	90                   	nop
 804cc4a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cc4d:	0f b6 10             	movzbl (%eax),%edx
 804cc50:	8b 45 08             	mov    0x8(%ebp),%eax
 804cc53:	88 10                	mov    %dl,(%eax)
 804cc55:	8b 45 08             	mov    0x8(%ebp),%eax
 804cc58:	0f b6 00             	movzbl (%eax),%eax
 804cc5b:	84 c0                	test   %al,%al
 804cc5d:	0f 95 c0             	setne  %al
 804cc60:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804cc64:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
 804cc68:	84 c0                	test   %al,%al
 804cc6a:	75 de                	jne    804cc4a <strcat+0x1d>

        return tmp;
 804cc6c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804cc6f:	c9                   	leave  
 804cc70:	c3                   	ret    

0804cc71 <strlen>:

size_t strlen(const char *s)
{
 804cc71:	55                   	push   %ebp
 804cc72:	89 e5                	mov    %esp,%ebp
 804cc74:	83 ec 10             	sub    $0x10,%esp
        const char *sc;

        for (sc = s; *sc != '\0'; ++sc)
 804cc77:	8b 45 08             	mov    0x8(%ebp),%eax
 804cc7a:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804cc7d:	eb 04                	jmp    804cc83 <strlen+0x12>
 804cc7f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804cc83:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804cc86:	0f b6 00             	movzbl (%eax),%eax
 804cc89:	84 c0                	test   %al,%al
 804cc8b:	75 f2                	jne    804cc7f <strlen+0xe>
                /* nothing */;
        return sc - s;
 804cc8d:	8b 55 fc             	mov    -0x4(%ebp),%edx
 804cc90:	8b 45 08             	mov    0x8(%ebp),%eax
 804cc93:	89 d1                	mov    %edx,%ecx
 804cc95:	29 c1                	sub    %eax,%ecx
 804cc97:	89 c8                	mov    %ecx,%eax
}
 804cc99:	c9                   	leave  
 804cc9a:	c3                   	ret    

0804cc9b <strchr>:

char *strchr(const char *s, int c)
{
 804cc9b:	55                   	push   %ebp
 804cc9c:	89 e5                	mov    %esp,%ebp
        for (; *s != (char) c; ++s)
 804cc9e:	eb 15                	jmp    804ccb5 <strchr+0x1a>
                if (*s == '\0')
 804cca0:	8b 45 08             	mov    0x8(%ebp),%eax
 804cca3:	0f b6 00             	movzbl (%eax),%eax
 804cca6:	84 c0                	test   %al,%al
 804cca8:	75 07                	jne    804ccb1 <strchr+0x16>
                        return NULL;
 804ccaa:	b8 00 00 00 00       	mov    $0x0,%eax
 804ccaf:	eb 14                	jmp    804ccc5 <strchr+0x2a>
        return sc - s;
}

char *strchr(const char *s, int c)
{
        for (; *s != (char) c; ++s)
 804ccb1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804ccb5:	8b 45 08             	mov    0x8(%ebp),%eax
 804ccb8:	0f b6 10             	movzbl (%eax),%edx
 804ccbb:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ccbe:	38 c2                	cmp    %al,%dl
 804ccc0:	75 de                	jne    804cca0 <strchr+0x5>
                if (*s == '\0')
                        return NULL;
        return (char *)s;
 804ccc2:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804ccc5:	5d                   	pop    %ebp
 804ccc6:	c3                   	ret    

0804ccc7 <strrchr>:

char *strrchr(const char *s, int c)
{
 804ccc7:	55                   	push   %ebp
 804ccc8:	89 e5                	mov    %esp,%ebp
 804ccca:	83 ec 10             	sub    $0x10,%esp
        char *r = NULL;
 804cccd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
        for (; *s; ++s)
 804ccd4:	eb 17                	jmp    804cced <strrchr+0x26>
                if (*s == (char)c)
 804ccd6:	8b 45 08             	mov    0x8(%ebp),%eax
 804ccd9:	0f b6 10             	movzbl (%eax),%edx
 804ccdc:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ccdf:	38 c2                	cmp    %al,%dl
 804cce1:	75 06                	jne    804cce9 <strrchr+0x22>
                        r = (char *)s;
 804cce3:	8b 45 08             	mov    0x8(%ebp),%eax
 804cce6:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

char *strrchr(const char *s, int c)
{
        char *r = NULL;
        for (; *s; ++s)
 804cce9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804cced:	8b 45 08             	mov    0x8(%ebp),%eax
 804ccf0:	0f b6 00             	movzbl (%eax),%eax
 804ccf3:	84 c0                	test   %al,%al
 804ccf5:	75 df                	jne    804ccd6 <strrchr+0xf>
                if (*s == (char)c)
                        r = (char *)s;
        return r;
 804ccf7:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804ccfa:	c9                   	leave  
 804ccfb:	c3                   	ret    

0804ccfc <strstr>:

char *strstr(const char *s1, const char *s2)
{
 804ccfc:	55                   	push   %ebp
 804ccfd:	89 e5                	mov    %esp,%ebp
 804ccff:	53                   	push   %ebx
 804cd00:	83 ec 24             	sub    $0x24,%esp
 804cd03:	e8 5d b7 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804cd08:	81 c3 a4 34 00 00    	add    $0x34a4,%ebx
        int l1, l2;

        l2 = strlen(s2);
 804cd0e:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cd11:	89 04 24             	mov    %eax,(%esp)
 804cd14:	e8 58 ff ff ff       	call   804cc71 <strlen>
 804cd19:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (!l2)
 804cd1c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804cd20:	75 05                	jne    804cd27 <strstr+0x2b>
                return (char *) s1;
 804cd22:	8b 45 08             	mov    0x8(%ebp),%eax
 804cd25:	eb 47                	jmp    804cd6e <strstr+0x72>
        l1 = strlen(s1);
 804cd27:	8b 45 08             	mov    0x8(%ebp),%eax
 804cd2a:	89 04 24             	mov    %eax,(%esp)
 804cd2d:	e8 3f ff ff ff       	call   804cc71 <strlen>
 804cd32:	89 45 f4             	mov    %eax,-0xc(%ebp)
        while (l1 >= l2) {
 804cd35:	eb 2a                	jmp    804cd61 <strstr+0x65>
                l1--;
 804cd37:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
                if (!memcmp(s1, s2, l2))
 804cd3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804cd3e:	89 44 24 08          	mov    %eax,0x8(%esp)
 804cd42:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cd45:	89 44 24 04          	mov    %eax,0x4(%esp)
 804cd49:	8b 45 08             	mov    0x8(%ebp),%eax
 804cd4c:	89 04 24             	mov    %eax,(%esp)
 804cd4f:	e8 d4 fc ff ff       	call   804ca28 <memcmp>
 804cd54:	85 c0                	test   %eax,%eax
 804cd56:	75 05                	jne    804cd5d <strstr+0x61>
                        return (char *) s1;
 804cd58:	8b 45 08             	mov    0x8(%ebp),%eax
 804cd5b:	eb 11                	jmp    804cd6e <strstr+0x72>
                s1++;
 804cd5d:	83 45 08 01          	addl   $0x1,0x8(%ebp)

        l2 = strlen(s2);
        if (!l2)
                return (char *) s1;
        l1 = strlen(s1);
        while (l1 >= l2) {
 804cd61:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cd64:	3b 45 f0             	cmp    -0x10(%ebp),%eax
 804cd67:	7d ce                	jge    804cd37 <strstr+0x3b>
                l1--;
                if (!memcmp(s1, s2, l2))
                        return (char *) s1;
                s1++;
        }
        return NULL;
 804cd69:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804cd6e:	83 c4 24             	add    $0x24,%esp
 804cd71:	5b                   	pop    %ebx
 804cd72:	5d                   	pop    %ebp
 804cd73:	c3                   	ret    

0804cd74 <strdup>:

char *strdup(const char *s)
{
 804cd74:	55                   	push   %ebp
 804cd75:	89 e5                	mov    %esp,%ebp
        /* TODO - alvin */
        return NULL;
 804cd77:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804cd7c:	5d                   	pop    %ebp
 804cd7d:	c3                   	ret    

0804cd7e <strpbrk>:
 * Got this from /onnv-gate/usr/src/common/uti/string.c.
 */

char *
strpbrk(const char *string, const char *brkset)
{
 804cd7e:	55                   	push   %ebp
 804cd7f:	89 e5                	mov    %esp,%ebp
 804cd81:	83 ec 10             	sub    $0x10,%esp
        const char *p;

        do {
                for (p = brkset; *p != '\0' && *p != *string; ++p)
 804cd84:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cd87:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804cd8a:	eb 04                	jmp    804cd90 <strpbrk+0x12>
 804cd8c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804cd90:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804cd93:	0f b6 00             	movzbl (%eax),%eax
 804cd96:	84 c0                	test   %al,%al
 804cd98:	74 10                	je     804cdaa <strpbrk+0x2c>
 804cd9a:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804cd9d:	0f b6 10             	movzbl (%eax),%edx
 804cda0:	8b 45 08             	mov    0x8(%ebp),%eax
 804cda3:	0f b6 00             	movzbl (%eax),%eax
 804cda6:	38 c2                	cmp    %al,%dl
 804cda8:	75 e2                	jne    804cd8c <strpbrk+0xe>
                        ;
                if (*p != '\0')
 804cdaa:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804cdad:	0f b6 00             	movzbl (%eax),%eax
 804cdb0:	84 c0                	test   %al,%al
 804cdb2:	74 05                	je     804cdb9 <strpbrk+0x3b>
                        return ((char *)string);
 804cdb4:	8b 45 08             	mov    0x8(%ebp),%eax
 804cdb7:	eb 18                	jmp    804cdd1 <strpbrk+0x53>
        } while (*string++);
 804cdb9:	8b 45 08             	mov    0x8(%ebp),%eax
 804cdbc:	0f b6 00             	movzbl (%eax),%eax
 804cdbf:	84 c0                	test   %al,%al
 804cdc1:	0f 95 c0             	setne  %al
 804cdc4:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804cdc8:	84 c0                	test   %al,%al
 804cdca:	75 b8                	jne    804cd84 <strpbrk+0x6>

        return (NULL);
 804cdcc:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804cdd1:	c9                   	leave  
 804cdd2:	c3                   	ret    

0804cdd3 <strspn>:

size_t
strspn(const char *string, const char *charset)
{
 804cdd3:	55                   	push   %ebp
 804cdd4:	89 e5                	mov    %esp,%ebp
 804cdd6:	83 ec 10             	sub    $0x10,%esp
        const char *p, *q;

        for (q = string; *q != '\0'; ++q) {
 804cdd9:	8b 45 08             	mov    0x8(%ebp),%eax
 804cddc:	89 45 f8             	mov    %eax,-0x8(%ebp)
 804cddf:	eb 34                	jmp    804ce15 <strspn+0x42>
                for (p = charset; *p != '\0' && *p != *q; ++p)
 804cde1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cde4:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804cde7:	eb 04                	jmp    804cded <strspn+0x1a>
 804cde9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804cded:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804cdf0:	0f b6 00             	movzbl (%eax),%eax
 804cdf3:	84 c0                	test   %al,%al
 804cdf5:	74 10                	je     804ce07 <strspn+0x34>
 804cdf7:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804cdfa:	0f b6 10             	movzbl (%eax),%edx
 804cdfd:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804ce00:	0f b6 00             	movzbl (%eax),%eax
 804ce03:	38 c2                	cmp    %al,%dl
 804ce05:	75 e2                	jne    804cde9 <strspn+0x16>
                        ;
                if (*p == '\0')
 804ce07:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804ce0a:	0f b6 00             	movzbl (%eax),%eax
 804ce0d:	84 c0                	test   %al,%al
 804ce0f:	74 10                	je     804ce21 <strspn+0x4e>
size_t
strspn(const char *string, const char *charset)
{
        const char *p, *q;

        for (q = string; *q != '\0'; ++q) {
 804ce11:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
 804ce15:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804ce18:	0f b6 00             	movzbl (%eax),%eax
 804ce1b:	84 c0                	test   %al,%al
 804ce1d:	75 c2                	jne    804cde1 <strspn+0xe>
 804ce1f:	eb 01                	jmp    804ce22 <strspn+0x4f>
                for (p = charset; *p != '\0' && *p != *q; ++p)
                        ;
                if (*p == '\0')
                        break;
 804ce21:	90                   	nop
        }

        return (q - string);
 804ce22:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804ce25:	8b 45 08             	mov    0x8(%ebp),%eax
 804ce28:	89 d1                	mov    %edx,%ecx
 804ce2a:	29 c1                	sub    %eax,%ecx
 804ce2c:	89 c8                	mov    %ecx,%eax
}
 804ce2e:	c9                   	leave  
 804ce2f:	c3                   	ret    

0804ce30 <strtok>:

char *
strtok(char *string, const char *sepset)
{
 804ce30:	55                   	push   %ebp
 804ce31:	89 e5                	mov    %esp,%ebp
 804ce33:	53                   	push   %ebx
 804ce34:	83 ec 24             	sub    $0x24,%esp
 804ce37:	e8 29 b6 ff ff       	call   8048465 <__i686.get_pc_thunk.bx>
 804ce3c:	81 c3 70 33 00 00    	add    $0x3370,%ebx
        static char     *savept;

        /*
         * Set `p' to our current location in the string.
         */
        p = (string == NULL) ? savept : string;
 804ce42:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804ce46:	75 08                	jne    804ce50 <strtok+0x20>
 804ce48:	8b 83 d4 04 00 00    	mov    0x4d4(%ebx),%eax
 804ce4e:	eb 03                	jmp    804ce53 <strtok+0x23>
 804ce50:	8b 45 08             	mov    0x8(%ebp),%eax
 804ce53:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (p == NULL)
 804ce56:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804ce5a:	75 07                	jne    804ce63 <strtok+0x33>
                return (NULL);
 804ce5c:	b8 00 00 00 00       	mov    $0x0,%eax
 804ce61:	eb 66                	jmp    804cec9 <strtok+0x99>

        /*
         * Skip leading separators; bail if no tokens remain.
         */
        q = p + strspn(p, sepset);
 804ce63:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ce66:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ce6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ce6d:	89 04 24             	mov    %eax,(%esp)
 804ce70:	e8 5e ff ff ff       	call   804cdd3 <strspn>
 804ce75:	03 45 f4             	add    -0xc(%ebp),%eax
 804ce78:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (*q == '\0')
 804ce7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ce7e:	0f b6 00             	movzbl (%eax),%eax
 804ce81:	84 c0                	test   %al,%al
 804ce83:	75 07                	jne    804ce8c <strtok+0x5c>
                return (NULL);
 804ce85:	b8 00 00 00 00       	mov    $0x0,%eax
 804ce8a:	eb 3d                	jmp    804cec9 <strtok+0x99>

        /*
         * Mark the end of the token and set `savept' for the next iteration.
         */
        if ((r = strpbrk(q, sepset)) == NULL)
 804ce8c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ce8f:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ce93:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ce96:	89 04 24             	mov    %eax,(%esp)
 804ce99:	e8 e0 fe ff ff       	call   804cd7e <strpbrk>
 804ce9e:	89 45 ec             	mov    %eax,-0x14(%ebp)
 804cea1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804cea5:	75 0c                	jne    804ceb3 <strtok+0x83>
                savept = NULL;
 804cea7:	c7 83 d4 04 00 00 00 	movl   $0x0,0x4d4(%ebx)
 804ceae:	00 00 00 
 804ceb1:	eb 13                	jmp    804cec6 <strtok+0x96>
        else {
                *r = '\0';
 804ceb3:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ceb6:	c6 00 00             	movb   $0x0,(%eax)
                savept = ++r;
 804ceb9:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
 804cebd:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cec0:	89 83 d4 04 00 00    	mov    %eax,0x4d4(%ebx)
        }

        return (q);
 804cec6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 804cec9:	83 c4 24             	add    $0x24,%esp
 804cecc:	5b                   	pop    %ebx
 804cecd:	5d                   	pop    %ebp
 804cece:	c3                   	ret    

0804cecf <strerror>:

/* created with the help of:
 * perl -p -e 's/#define\s+(\w+)\s+\d+\s+\/\* ([^\t\*]+)\s*\*\/\s*$/case $1: return "$2";\n/' < /usr/include/sys/errno.h
 */
char *strerror(int errnum)
{
 804cecf:	55                   	push   %ebp
 804ced0:	89 e5                	mov    %esp,%ebp
 804ced2:	e8 e0 c4 ff ff       	call   80493b7 <__i686.get_pc_thunk.cx>
 804ced7:	81 c1 d5 32 00 00    	add    $0x32d5,%ecx
        switch (errnum) {
 804cedd:	81 7d 08 83 00 00 00 	cmpl   $0x83,0x8(%ebp)
 804cee4:	0f 87 fd 06 00 00    	ja     804d5e7 <strerror+0x718>
 804ceea:	8b 45 08             	mov    0x8(%ebp),%eax
 804ceed:	c1 e0 02             	shl    $0x2,%eax
 804cef0:	8b 84 08 54 cd ff ff 	mov    -0x32ac(%eax,%ecx,1),%eax
 804cef7:	89 ca                	mov    %ecx,%edx
 804cef9:	29 c2                	sub    %eax,%edx
 804cefb:	89 d0                	mov    %edx,%eax
 804cefd:	ff e0                	jmp    *%eax
 804ceff:	90                   	nop
 804cf00:	c5 2b                	lds    (%ebx),%ebp
 804cf02:	00 00                	add    %al,(%eax)
 804cf04:	9c                   	pushf  
 804cf05:	30 00                	xor    %al,(%eax)
 804cf07:	00 91 30 00 00 86    	add    %dl,-0x79ffffd0(%ecx)
 804cf0d:	30 00                	xor    %al,(%eax)
 804cf0f:	00 7b 30             	add    %bh,0x30(%ebx)
 804cf12:	00 00                	add    %al,(%eax)
 804cf14:	70 30                	jo     804cf46 <strerror+0x77>
 804cf16:	00 00                	add    %al,(%eax)
 804cf18:	65 30 00             	xor    %al,%gs:(%eax)
 804cf1b:	00 5a 30             	add    %bl,0x30(%edx)
 804cf1e:	00 00                	add    %al,(%eax)
 804cf20:	4f                   	dec    %edi
 804cf21:	30 00                	xor    %al,(%eax)
 804cf23:	00 44 30 00          	add    %al,0x0(%eax,%esi,1)
 804cf27:	00 39                	add    %bh,(%ecx)
 804cf29:	30 00                	xor    %al,(%eax)
 804cf2b:	00 2e                	add    %ch,(%esi)
 804cf2d:	30 00                	xor    %al,(%eax)
 804cf2f:	00 23                	add    %ah,(%ebx)
 804cf31:	30 00                	xor    %al,(%eax)
 804cf33:	00 18                	add    %bl,(%eax)
 804cf35:	30 00                	xor    %al,(%eax)
 804cf37:	00 0d 30 00 00 02    	add    %cl,0x2000030
 804cf3d:	30 00                	xor    %al,(%eax)
 804cf3f:	00 f7                	add    %dh,%bh
 804cf41:	2f                   	das    
 804cf42:	00 00                	add    %al,(%eax)
 804cf44:	ec                   	in     (%dx),%al
 804cf45:	2f                   	das    
 804cf46:	00 00                	add    %al,(%eax)
 804cf48:	e1 2f                	loope  804cf79 <strerror+0xaa>
 804cf4a:	00 00                	add    %al,(%eax)
 804cf4c:	d6                   	(bad)  
 804cf4d:	2f                   	das    
 804cf4e:	00 00                	add    %al,(%eax)
 804cf50:	cb                   	lret   
 804cf51:	2f                   	das    
 804cf52:	00 00                	add    %al,(%eax)
 804cf54:	c0 2f 00             	shrb   $0x0,(%edi)
 804cf57:	00 b5 2f 00 00 aa    	add    %dh,-0x55ffffd1(%ebp)
 804cf5d:	2f                   	das    
 804cf5e:	00 00                	add    %al,(%eax)
 804cf60:	9f                   	lahf   
 804cf61:	2f                   	das    
 804cf62:	00 00                	add    %al,(%eax)
 804cf64:	94                   	xchg   %eax,%esp
 804cf65:	2f                   	das    
 804cf66:	00 00                	add    %al,(%eax)
 804cf68:	89 2f                	mov    %ebp,(%edi)
 804cf6a:	00 00                	add    %al,(%eax)
 804cf6c:	7e 2f                	jle    804cf9d <strerror+0xce>
 804cf6e:	00 00                	add    %al,(%eax)
 804cf70:	73 2f                	jae    804cfa1 <strerror+0xd2>
 804cf72:	00 00                	add    %al,(%eax)
 804cf74:	68 2f 00 00 5d       	push   $0x5d00002f
 804cf79:	2f                   	das    
 804cf7a:	00 00                	add    %al,(%eax)
 804cf7c:	52                   	push   %edx
 804cf7d:	2f                   	das    
 804cf7e:	00 00                	add    %al,(%eax)
 804cf80:	47                   	inc    %edi
 804cf81:	2f                   	das    
 804cf82:	00 00                	add    %al,(%eax)
 804cf84:	3c 2f                	cmp    $0x2f,%al
 804cf86:	00 00                	add    %al,(%eax)
 804cf88:	31 2f                	xor    %ebp,(%edi)
 804cf8a:	00 00                	add    %al,(%eax)
 804cf8c:	b8 2e 00 00 84       	mov    $0x8400002e,%eax
 804cf91:	2d 00 00 ad 2e       	sub    $0x2ead0000,%eax
 804cf96:	00 00                	add    %al,(%eax)
 804cf98:	0b 2d 00 00 df 2c    	or     0x2cdf0000,%ebp
 804cf9e:	00 00                	add    %al,(%eax)
 804cfa0:	00 2d 00 00 c5 2b    	add    %ch,0x2bc50000
 804cfa6:	00 00                	add    %al,(%eax)
 804cfa8:	26                   	es
 804cfa9:	2f                   	das    
 804cfaa:	00 00                	add    %al,(%eax)
 804cfac:	1b 2f                	sbb    (%edi),%ebp
 804cfae:	00 00                	add    %al,(%eax)
 804cfb0:	10 2f                	adc    %ch,(%edi)
 804cfb2:	00 00                	add    %al,(%eax)
 804cfb4:	05 2f 00 00 fa       	add    $0xfa00002f,%eax
 804cfb9:	2e 00 00             	add    %al,%cs:(%eax)
 804cfbc:	ef                   	out    %eax,(%dx)
 804cfbd:	2e 00 00             	add    %al,%cs:(%eax)
 804cfc0:	e4 2e                	in     $0x2e,%al
 804cfc2:	00 00                	add    %al,(%eax)
 804cfc4:	d9 2e                	fldcw  (%esi)
 804cfc6:	00 00                	add    %al,(%eax)
 804cfc8:	ce                   	into   
 804cfc9:	2e 00 00             	add    %al,%cs:(%eax)
 804cfcc:	c3                   	ret    
 804cfcd:	2e 00 00             	add    %al,%cs:(%eax)
 804cfd0:	81 2e 00 00 76 2e    	subl   $0x2e760000,(%esi)
 804cfd6:	00 00                	add    %al,(%eax)
 804cfd8:	6b 2e 00             	imul   $0x0,(%esi),%ebp
 804cfdb:	00 60 2e             	add    %ah,0x2e(%eax)
 804cfde:	00 00                	add    %al,(%eax)
 804cfe0:	55                   	push   %ebp
 804cfe1:	2e 00 00             	add    %al,%cs:(%eax)
 804cfe4:	4a                   	dec    %edx
 804cfe5:	2e 00 00             	add    %al,%cs:(%eax)
 804cfe8:	c5 2b                	lds    (%ebx),%ebp
 804cfea:	00 00                	add    %al,(%eax)
 804cfec:	3f                   	aas    
 804cfed:	2e 00 00             	add    %al,%cs:(%eax)
 804cff0:	1e                   	push   %ds
 804cff1:	2e 00 00             	add    %al,%cs:(%eax)
 804cff4:	13 2e                	adc    (%esi),%ebp
 804cff6:	00 00                	add    %al,(%eax)
 804cff8:	08 2e                	or     %ch,(%esi)
 804cffa:	00 00                	add    %al,(%eax)
 804cffc:	fd                   	std    
 804cffd:	2d 00 00 f2 2d       	sub    $0x2df20000,%eax
 804d002:	00 00                	add    %al,(%eax)
 804d004:	e7 2d                	out    %eax,$0x2d
 804d006:	00 00                	add    %al,(%eax)
 804d008:	dc 2d 00 00 d1 2d    	fsubrl 0x2dd10000
 804d00e:	00 00                	add    %al,(%eax)
 804d010:	c6                   	(bad)  
 804d011:	2d 00 00 bb 2d       	sub    $0x2dbb0000,%eax
 804d016:	00 00                	add    %al,(%eax)
 804d018:	b0 2d                	mov    $0x2d,%al
 804d01a:	00 00                	add    %al,(%eax)
 804d01c:	a5                   	movsl  %ds:(%esi),%es:(%edi)
 804d01d:	2d 00 00 9a 2d       	sub    $0x2d9a0000,%eax
 804d022:	00 00                	add    %al,(%eax)
 804d024:	c5 2b                	lds    (%ebx),%ebp
 804d026:	00 00                	add    %al,(%eax)
 804d028:	8f                   	(bad)  
 804d029:	2d 00 00 79 2d       	sub    $0x2d790000,%eax
 804d02e:	00 00                	add    %al,(%eax)
 804d030:	6e                   	outsb  %ds:(%esi),(%dx)
 804d031:	2d 00 00 63 2d       	sub    $0x2d630000,%eax
 804d036:	00 00                	add    %al,(%eax)
 804d038:	58                   	pop    %eax
 804d039:	2d 00 00 4d 2d       	sub    $0x2d4d0000,%eax
 804d03e:	00 00                	add    %al,(%eax)
 804d040:	42                   	inc    %edx
 804d041:	2d 00 00 37 2d       	sub    $0x2d370000,%eax
 804d046:	00 00                	add    %al,(%eax)
 804d048:	2c 2d                	sub    $0x2d,%al
 804d04a:	00 00                	add    %al,(%eax)
 804d04c:	21 2d 00 00 16 2d    	and    %ebp,0x2d160000
 804d052:	00 00                	add    %al,(%eax)
 804d054:	f5                   	cmc    
 804d055:	2c 00                	sub    $0x0,%al
 804d057:	00 ea                	add    %ch,%dl
 804d059:	2c 00                	sub    $0x0,%al
 804d05b:	00 d4                	add    %dl,%ah
 804d05d:	2c 00                	sub    $0x0,%al
 804d05f:	00 c9                	add    %cl,%cl
 804d061:	2c 00                	sub    $0x0,%al
 804d063:	00 be 2c 00 00 b3    	add    %bh,-0x4cffffd4(%esi)
 804d069:	2c 00                	sub    $0x0,%al
 804d06b:	00 a8 2c 00 00 9d    	add    %ch,-0x62ffffd4(%eax)
 804d071:	2c 00                	sub    $0x0,%al
 804d073:	00 92 2c 00 00 87    	add    %dl,-0x78ffffd4(%edx)
 804d079:	2c 00                	sub    $0x0,%al
 804d07b:	00 97 2e 00 00 7c    	add    %dl,0x7c00002e(%edi)
 804d081:	2c 00                	sub    $0x0,%al
 804d083:	00 71 2c             	add    %dh,0x2c(%ecx)
 804d086:	00 00                	add    %al,(%eax)
 804d088:	66                   	data16
 804d089:	2c 00                	sub    $0x0,%al
 804d08b:	00 5b 2c             	add    %bl,0x2c(%ebx)
 804d08e:	00 00                	add    %al,(%eax)
 804d090:	50                   	push   %eax
 804d091:	2c 00                	sub    $0x0,%al
 804d093:	00 45 2c             	add    %al,0x2c(%ebp)
 804d096:	00 00                	add    %al,(%eax)
 804d098:	3d 2c 00 00 35       	cmp    $0x3500002c,%eax
 804d09d:	2c 00                	sub    $0x0,%al
 804d09f:	00 2d 2c 00 00 25    	add    %ch,0x2500002c
 804d0a5:	2c 00                	sub    $0x0,%al
 804d0a7:	00 1d 2c 00 00 15    	add    %bl,0x1500002c
 804d0ad:	2c 00                	sub    $0x0,%al
 804d0af:	00 0d 2c 00 00 05    	add    %cl,0x500002c
 804d0b5:	2c 00                	sub    $0x0,%al
 804d0b7:	00 fd                	add    %bh,%ch
 804d0b9:	2b 00                	sub    (%eax),%eax
 804d0bb:	00 f5                	add    %dh,%ch
 804d0bd:	2b 00                	sub    (%eax),%eax
 804d0bf:	00 ed                	add    %ch,%ch
 804d0c1:	2b 00                	sub    (%eax),%eax
 804d0c3:	00 e5                	add    %ah,%ch
 804d0c5:	2b 00                	sub    (%eax),%eax
 804d0c7:	00 dd                	add    %bl,%ch
 804d0c9:	2b 00                	sub    (%eax),%eax
 804d0cb:	00 d5                	add    %dl,%ch
 804d0cd:	2b 00                	sub    (%eax),%eax
 804d0cf:	00 cd                	add    %cl,%ch
 804d0d1:	2b 00                	sub    (%eax),%eax
 804d0d3:	00 c5                	add    %al,%ch
 804d0d5:	2b 00                	sub    (%eax),%eax
 804d0d7:	00 c5                	add    %al,%ch
 804d0d9:	2b 00                	sub    (%eax),%eax
 804d0db:	00 c5                	add    %al,%ch
 804d0dd:	2b 00                	sub    (%eax),%eax
 804d0df:	00 c5                	add    %al,%ch
 804d0e1:	2b 00                	sub    (%eax),%eax
 804d0e3:	00 c5                	add    %al,%ch
 804d0e5:	2b 00                	sub    (%eax),%eax
 804d0e7:	00 8c 2e 00 00 c5 2b 	add    %cl,0x2bc50000(%esi,%ebp,1)
 804d0ee:	00 00                	add    %al,(%eax)
 804d0f0:	c5 2b                	lds    (%ebx),%ebp
 804d0f2:	00 00                	add    %al,(%eax)
 804d0f4:	a2 2e 00 00 c5       	mov    %al,0xc500002e
 804d0f9:	2b 00                	sub    (%eax),%eax
 804d0fb:	00 c5                	add    %al,%ch
 804d0fd:	2b 00                	sub    (%eax),%eax
 804d0ff:	00 c5                	add    %al,%ch
 804d101:	2b 00                	sub    (%eax),%eax
 804d103:	00 c5                	add    %al,%ch
 804d105:	2b 00                	sub    (%eax),%eax
 804d107:	00 34 2e             	add    %dh,(%esi,%ebp,1)
 804d10a:	00 00                	add    %al,(%eax)
 804d10c:	29 2e                	sub    %ebp,(%esi)
 804d10e:	00 00                	add    %al,(%eax)
                case EPERM: return "Not super-user";
 804d110:	8d 81 bc d7 ff ff    	lea    -0x2844(%ecx),%eax
 804d116:	e9 d1 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOENT: return "No such file or directory";
 804d11b:	8d 81 cb d7 ff ff    	lea    -0x2835(%ecx),%eax
 804d121:	e9 c6 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case ESRCH: return "No such process";
 804d126:	8d 81 e5 d7 ff ff    	lea    -0x281b(%ecx),%eax
 804d12c:	e9 bb 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case EINTR: return "interrupted system call";
 804d131:	8d 81 f5 d7 ff ff    	lea    -0x280b(%ecx),%eax
 804d137:	e9 b0 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case EIO: return "I/O error";
 804d13c:	8d 81 0d d8 ff ff    	lea    -0x27f3(%ecx),%eax
 804d142:	e9 a5 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENXIO: return "No such device or address";
 804d147:	8d 81 17 d8 ff ff    	lea    -0x27e9(%ecx),%eax
 804d14d:	e9 9a 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case E2BIG: return "Arg list too long";
 804d152:	8d 81 31 d8 ff ff    	lea    -0x27cf(%ecx),%eax
 804d158:	e9 8f 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOEXEC: return "Exec format error";
 804d15d:	8d 81 43 d8 ff ff    	lea    -0x27bd(%ecx),%eax
 804d163:	e9 84 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case EBADF: return "Bad file number";
 804d168:	8d 81 55 d8 ff ff    	lea    -0x27ab(%ecx),%eax
 804d16e:	e9 79 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case ECHILD: return "No children";
 804d173:	8d 81 65 d8 ff ff    	lea    -0x279b(%ecx),%eax
 804d179:	e9 6e 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case EAGAIN: return "Resource temporarily unavailable";
 804d17e:	8d 81 74 d8 ff ff    	lea    -0x278c(%ecx),%eax
 804d184:	e9 63 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOMEM: return "Not enough core";
 804d189:	8d 81 95 d8 ff ff    	lea    -0x276b(%ecx),%eax
 804d18f:	e9 58 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case EACCES: return "Permission denied";
 804d194:	8d 81 a5 d8 ff ff    	lea    -0x275b(%ecx),%eax
 804d19a:	e9 4d 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case EFAULT: return "Bad address";
 804d19f:	8d 81 b7 d8 ff ff    	lea    -0x2749(%ecx),%eax
 804d1a5:	e9 42 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOTBLK: return "Block device required";
 804d1aa:	8d 81 c3 d8 ff ff    	lea    -0x273d(%ecx),%eax
 804d1b0:	e9 37 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case EBUSY: return "Mount device busy";
 804d1b5:	8d 81 d9 d8 ff ff    	lea    -0x2727(%ecx),%eax
 804d1bb:	e9 2c 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case EEXIST: return "File exists";
 804d1c0:	8d 81 eb d8 ff ff    	lea    -0x2715(%ecx),%eax
 804d1c6:	e9 21 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case EXDEV: return "Cross-device link";
 804d1cb:	8d 81 f7 d8 ff ff    	lea    -0x2709(%ecx),%eax
 804d1d1:	e9 16 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENODEV: return "No such device";
 804d1d6:	8d 81 09 d9 ff ff    	lea    -0x26f7(%ecx),%eax
 804d1dc:	e9 0b 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOTDIR: return "Not a directory";
 804d1e1:	8d 81 18 d9 ff ff    	lea    -0x26e8(%ecx),%eax
 804d1e7:	e9 00 04 00 00       	jmp    804d5ec <strerror+0x71d>
                case EISDIR: return "Is a directory";
 804d1ec:	8d 81 28 d9 ff ff    	lea    -0x26d8(%ecx),%eax
 804d1f2:	e9 f5 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case EINVAL: return "Invalid argument";
 804d1f7:	8d 81 37 d9 ff ff    	lea    -0x26c9(%ecx),%eax
 804d1fd:	e9 ea 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENFILE: return "File table overflow";
 804d202:	8d 81 48 d9 ff ff    	lea    -0x26b8(%ecx),%eax
 804d208:	e9 df 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case EMFILE: return "Too many open files";
 804d20d:	8d 81 5c d9 ff ff    	lea    -0x26a4(%ecx),%eax
 804d213:	e9 d4 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOTTY: return "Inappropriate ioctl for device";
 804d218:	8d 81 70 d9 ff ff    	lea    -0x2690(%ecx),%eax
 804d21e:	e9 c9 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case ETXTBSY: return "Text file busy";
 804d223:	8d 81 8f d9 ff ff    	lea    -0x2671(%ecx),%eax
 804d229:	e9 be 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case EFBIG: return "File too large";
 804d22e:	8d 81 9e d9 ff ff    	lea    -0x2662(%ecx),%eax
 804d234:	e9 b3 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOSPC: return "No space left on device";
 804d239:	8d 81 ad d9 ff ff    	lea    -0x2653(%ecx),%eax
 804d23f:	e9 a8 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case ESPIPE: return "Illegal seek";
 804d244:	8d 81 c5 d9 ff ff    	lea    -0x263b(%ecx),%eax
 804d24a:	e9 9d 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case EROFS: return "Read only file system";
 804d24f:	8d 81 d2 d9 ff ff    	lea    -0x262e(%ecx),%eax
 804d255:	e9 92 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case EMLINK: return "Too many links";
 804d25a:	8d 81 e8 d9 ff ff    	lea    -0x2618(%ecx),%eax
 804d260:	e9 87 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case EPIPE: return "Broken pipe";
 804d265:	8d 81 f7 d9 ff ff    	lea    -0x2609(%ecx),%eax
 804d26b:	e9 7c 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case EDOM: return "Math arg out of domain of func";
 804d270:	8d 81 04 da ff ff    	lea    -0x25fc(%ecx),%eax
 804d276:	e9 71 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case ERANGE: return "Math result not representable";
 804d27b:	8d 81 23 da ff ff    	lea    -0x25dd(%ecx),%eax
 804d281:	e9 66 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOMSG: return "No message of desired type";
 804d286:	8d 81 41 da ff ff    	lea    -0x25bf(%ecx),%eax
 804d28c:	e9 5b 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case EIDRM: return "Identifier removed";
 804d291:	8d 81 5c da ff ff    	lea    -0x25a4(%ecx),%eax
 804d297:	e9 50 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case ECHRNG: return "Channel number out of range";
 804d29c:	8d 81 6f da ff ff    	lea    -0x2591(%ecx),%eax
 804d2a2:	e9 45 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case EL2NSYNC: return "Level 2 not synchronized";
 804d2a7:	8d 81 8b da ff ff    	lea    -0x2575(%ecx),%eax
 804d2ad:	e9 3a 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case EL3HLT: return "Level 3 halted";
 804d2b2:	8d 81 a4 da ff ff    	lea    -0x255c(%ecx),%eax
 804d2b8:	e9 2f 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case EL3RST: return "Level 3 reset";
 804d2bd:	8d 81 b3 da ff ff    	lea    -0x254d(%ecx),%eax
 804d2c3:	e9 24 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case ELNRNG: return "Link number out of range";
 804d2c8:	8d 81 c1 da ff ff    	lea    -0x253f(%ecx),%eax
 804d2ce:	e9 19 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case EUNATCH: return "Protocol driver not attached";
 804d2d3:	8d 81 da da ff ff    	lea    -0x2526(%ecx),%eax
 804d2d9:	e9 0e 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOCSI: return "No CSI structure available";
 804d2de:	8d 81 f7 da ff ff    	lea    -0x2509(%ecx),%eax
 804d2e4:	e9 03 03 00 00       	jmp    804d5ec <strerror+0x71d>
                case EL2HLT: return "Level 2 halted";
 804d2e9:	8d 81 12 db ff ff    	lea    -0x24ee(%ecx),%eax
 804d2ef:	e9 f8 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case EDEADLK: return "Deadlock condition.";
 804d2f4:	8d 81 21 db ff ff    	lea    -0x24df(%ecx),%eax
 804d2fa:	e9 ed 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOLCK: return "No record locks available.";
 804d2ff:	8d 81 35 db ff ff    	lea    -0x24cb(%ecx),%eax
 804d305:	e9 e2 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case ECANCELED: return "Operation canceled";
 804d30a:	8d 81 50 db ff ff    	lea    -0x24b0(%ecx),%eax
 804d310:	e9 d7 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOTSUP: return "Operation not supported";
 804d315:	8d 81 63 db ff ff    	lea    -0x249d(%ecx),%eax
 804d31b:	e9 cc 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case EDQUOT: return "Disc quota exceeded";
 804d320:	8d 81 7b db ff ff    	lea    -0x2485(%ecx),%eax
 804d326:	e9 c1 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case EBADE: return "invalid exchange";
 804d32b:	8d 81 8f db ff ff    	lea    -0x2471(%ecx),%eax
 804d331:	e9 b6 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case EBADR: return "invalid request descriptor";
 804d336:	8d 81 a0 db ff ff    	lea    -0x2460(%ecx),%eax
 804d33c:	e9 ab 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case EXFULL: return "exchange full";
 804d341:	8d 81 bb db ff ff    	lea    -0x2445(%ecx),%eax
 804d347:	e9 a0 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOANO: return "no anode";
 804d34c:	8d 81 c9 db ff ff    	lea    -0x2437(%ecx),%eax
 804d352:	e9 95 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case EBADRQC: return "invalid request code";
 804d357:	8d 81 d2 db ff ff    	lea    -0x242e(%ecx),%eax
 804d35d:	e9 8a 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case EBADSLT: return "invalid slot";
 804d362:	8d 81 e7 db ff ff    	lea    -0x2419(%ecx),%eax
 804d368:	e9 7f 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case EBFONT: return "bad font file fmt";
 804d36d:	8d 81 f4 db ff ff    	lea    -0x240c(%ecx),%eax
 804d373:	e9 74 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case EOWNERDEAD: return "process died with the lock";
 804d378:	8d 81 06 dc ff ff    	lea    -0x23fa(%ecx),%eax
 804d37e:	e9 69 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOTRECOVERABLE: return "lock is not recoverable";
 804d383:	8d 81 21 dc ff ff    	lea    -0x23df(%ecx),%eax
 804d389:	e9 5e 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOSTR: return "Device not a stream";
 804d38e:	8d 81 39 dc ff ff    	lea    -0x23c7(%ecx),%eax
 804d394:	e9 53 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENODATA: return "no data (for no delay io)";
 804d399:	8d 81 4d dc ff ff    	lea    -0x23b3(%ecx),%eax
 804d39f:	e9 48 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case ETIME: return "timer expired";
 804d3a4:	8d 81 67 dc ff ff    	lea    -0x2399(%ecx),%eax
 804d3aa:	e9 3d 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOSR: return "out of streams resources";
 804d3af:	8d 81 75 dc ff ff    	lea    -0x238b(%ecx),%eax
 804d3b5:	e9 32 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENONET: return "Machine is not on the network";
 804d3ba:	8d 81 8e dc ff ff    	lea    -0x2372(%ecx),%eax
 804d3c0:	e9 27 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOPKG: return "Package not installed";
 804d3c5:	8d 81 ac dc ff ff    	lea    -0x2354(%ecx),%eax
 804d3cb:	e9 1c 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case EREMOTE: return "The object is remote";
 804d3d0:	8d 81 c2 dc ff ff    	lea    -0x233e(%ecx),%eax
 804d3d6:	e9 11 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOLINK: return "the link has been severed";
 804d3db:	8d 81 d7 dc ff ff    	lea    -0x2329(%ecx),%eax
 804d3e1:	e9 06 02 00 00       	jmp    804d5ec <strerror+0x71d>
                case EADV: return "advertise error";
 804d3e6:	8d 81 f1 dc ff ff    	lea    -0x230f(%ecx),%eax
 804d3ec:	e9 fb 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case ESRMNT: return "srmount error";
 804d3f1:	8d 81 01 dd ff ff    	lea    -0x22ff(%ecx),%eax
 804d3f7:	e9 f0 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case ECOMM: return "Communication error on send";
 804d3fc:	8d 81 0f dd ff ff    	lea    -0x22f1(%ecx),%eax
 804d402:	e9 e5 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case EPROTO: return "Protocol error";
 804d407:	8d 81 2b dd ff ff    	lea    -0x22d5(%ecx),%eax
 804d40d:	e9 da 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case EMULTIHOP: return "multihop attempted";
 804d412:	8d 81 3a dd ff ff    	lea    -0x22c6(%ecx),%eax
 804d418:	e9 cf 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case EBADMSG: return "trying to read unreadable message";
 804d41d:	8d 81 50 dd ff ff    	lea    -0x22b0(%ecx),%eax
 804d423:	e9 c4 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENAMETOOLONG: return "path name is too long";
 804d428:	8d 81 72 dd ff ff    	lea    -0x228e(%ecx),%eax
 804d42e:	e9 b9 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case EOVERFLOW: return "value too large to be stored in data type";
 804d433:	8d 81 88 dd ff ff    	lea    -0x2278(%ecx),%eax
 804d439:	e9 ae 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOTUNIQ: return "given log. name not unique";
 804d43e:	8d 81 b2 dd ff ff    	lea    -0x224e(%ecx),%eax
 804d444:	e9 a3 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case EBADFD: return "f.d. invalid for this operation";
 804d449:	8d 81 d0 dd ff ff    	lea    -0x2230(%ecx),%eax
 804d44f:	e9 98 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case EREMCHG: return "Remote address changed";
 804d454:	8d 81 f0 dd ff ff    	lea    -0x2210(%ecx),%eax
 804d45a:	e9 8d 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case ELIBACC: return "Can't access a needed shared lib.";
 804d45f:	8d 81 08 de ff ff    	lea    -0x21f8(%ecx),%eax
 804d465:	e9 82 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case ELIBBAD: return "Accessing a corrupted shared lib.";
 804d46a:	8d 81 2c de ff ff    	lea    -0x21d4(%ecx),%eax
 804d470:	e9 77 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case ELIBSCN: return ".lib section in a.out corrupted.";
 804d475:	8d 81 50 de ff ff    	lea    -0x21b0(%ecx),%eax
 804d47b:	e9 6c 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case ELIBMAX: return "Attempting to link in too many libs.";
 804d480:	8d 81 74 de ff ff    	lea    -0x218c(%ecx),%eax
 804d486:	e9 61 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case ELIBEXEC: return "Attempting to exec a shared library.";
 804d48b:	8d 81 9c de ff ff    	lea    -0x2164(%ecx),%eax
 804d491:	e9 56 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case EILSEQ: return "Illegal byte sequence.";
 804d496:	8d 81 c1 de ff ff    	lea    -0x213f(%ecx),%eax
 804d49c:	e9 4b 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOSYS: return "Unsupported file system operation";
 804d4a1:	8d 81 d8 de ff ff    	lea    -0x2128(%ecx),%eax
 804d4a7:	e9 40 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case ELOOP: return "Symbolic link loop";
 804d4ac:	8d 81 fa de ff ff    	lea    -0x2106(%ecx),%eax
 804d4b2:	e9 35 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case ERESTART: return "Restartable system call";
 804d4b7:	8d 81 0d df ff ff    	lea    -0x20f3(%ecx),%eax
 804d4bd:	e9 2a 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case ESTRPIPE: return "if pipe/FIFO, don't sleep in stream head";
 804d4c2:	8d 81 28 df ff ff    	lea    -0x20d8(%ecx),%eax
 804d4c8:	e9 1f 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOTEMPTY: return "directory not empty";
 804d4cd:	8d 81 51 df ff ff    	lea    -0x20af(%ecx),%eax
 804d4d3:	e9 14 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case EUSERS: return "Too many users (for UFS)";
 804d4d8:	8d 81 65 df ff ff    	lea    -0x209b(%ecx),%eax
 804d4de:	e9 09 01 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOTSOCK: return "Socket operation on non-socket";
 804d4e3:	8d 81 80 df ff ff    	lea    -0x2080(%ecx),%eax
 804d4e9:	e9 fe 00 00 00       	jmp    804d5ec <strerror+0x71d>
                case EDESTADDRREQ: return "Destination address required";
 804d4ee:	8d 81 9f df ff ff    	lea    -0x2061(%ecx),%eax
 804d4f4:	e9 f3 00 00 00       	jmp    804d5ec <strerror+0x71d>
                case EMSGSIZE: return "Message too long";
 804d4f9:	8d 81 bc df ff ff    	lea    -0x2044(%ecx),%eax
 804d4ff:	e9 e8 00 00 00       	jmp    804d5ec <strerror+0x71d>
                case EPROTOTYPE: return "Protocol wrong type for socket";
 804d504:	8d 81 d0 df ff ff    	lea    -0x2030(%ecx),%eax
 804d50a:	e9 dd 00 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENOPROTOOPT: return "Protocol not available";
 804d50f:	8d 81 ef df ff ff    	lea    -0x2011(%ecx),%eax
 804d515:	e9 d2 00 00 00       	jmp    804d5ec <strerror+0x71d>
                case EPROTONOSUPPORT: return "Protocol not supported";
 804d51a:	8d 81 06 e0 ff ff    	lea    -0x1ffa(%ecx),%eax
 804d520:	e9 c7 00 00 00       	jmp    804d5ec <strerror+0x71d>
                case ESOCKTNOSUPPORT: return "Socket type not supported";
 804d525:	8d 81 1d e0 ff ff    	lea    -0x1fe3(%ecx),%eax
 804d52b:	e9 bc 00 00 00       	jmp    804d5ec <strerror+0x71d>
                case EPFNOSUPPORT: return "Protocol family not supported";
 804d530:	8d 81 37 e0 ff ff    	lea    -0x1fc9(%ecx),%eax
 804d536:	e9 b1 00 00 00       	jmp    804d5ec <strerror+0x71d>
                case EAFNOSUPPORT: return "Address family not supported by protocol family";
 804d53b:	8d 81 58 e0 ff ff    	lea    -0x1fa8(%ecx),%eax
 804d541:	e9 a6 00 00 00       	jmp    804d5ec <strerror+0x71d>
                case EADDRINUSE: return "Address already in use";
 804d546:	8d 81 88 e0 ff ff    	lea    -0x1f78(%ecx),%eax
 804d54c:	e9 9b 00 00 00       	jmp    804d5ec <strerror+0x71d>
                case EADDRNOTAVAIL: return "Can't assign requested address";
 804d551:	8d 81 a0 e0 ff ff    	lea    -0x1f60(%ecx),%eax
 804d557:	e9 90 00 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENETDOWN: return "Network is down";
 804d55c:	8d 81 bf e0 ff ff    	lea    -0x1f41(%ecx),%eax
 804d562:	e9 85 00 00 00       	jmp    804d5ec <strerror+0x71d>
                case ENETUNREACH: return "Network is unreachable";
 804d567:	8d 81 cf e0 ff ff    	lea    -0x1f31(%ecx),%eax
 804d56d:	eb 7d                	jmp    804d5ec <strerror+0x71d>
                case ENETRESET: return "Network dropped connection because of reset";
 804d56f:	8d 81 e8 e0 ff ff    	lea    -0x1f18(%ecx),%eax
 804d575:	eb 75                	jmp    804d5ec <strerror+0x71d>
                case ECONNABORTED: return "Software caused connection abort";
 804d577:	8d 81 14 e1 ff ff    	lea    -0x1eec(%ecx),%eax
 804d57d:	eb 6d                	jmp    804d5ec <strerror+0x71d>
                case ECONNRESET: return "Connection reset by peer";
 804d57f:	8d 81 35 e1 ff ff    	lea    -0x1ecb(%ecx),%eax
 804d585:	eb 65                	jmp    804d5ec <strerror+0x71d>
                case ENOBUFS: return "No buffer space available";
 804d587:	8d 81 4e e1 ff ff    	lea    -0x1eb2(%ecx),%eax
 804d58d:	eb 5d                	jmp    804d5ec <strerror+0x71d>
                case EISCONN: return "Socket is already connected";
 804d58f:	8d 81 68 e1 ff ff    	lea    -0x1e98(%ecx),%eax
 804d595:	eb 55                	jmp    804d5ec <strerror+0x71d>
                case ENOTCONN: return "Socket is not connected";
 804d597:	8d 81 84 e1 ff ff    	lea    -0x1e7c(%ecx),%eax
 804d59d:	eb 4d                	jmp    804d5ec <strerror+0x71d>
                case ESHUTDOWN: return "Can't send after socket shutdown";
 804d59f:	8d 81 9c e1 ff ff    	lea    -0x1e64(%ecx),%eax
 804d5a5:	eb 45                	jmp    804d5ec <strerror+0x71d>
                case ETOOMANYREFS: return "Too many references: can't splice";
 804d5a7:	8d 81 c0 e1 ff ff    	lea    -0x1e40(%ecx),%eax
 804d5ad:	eb 3d                	jmp    804d5ec <strerror+0x71d>
                case ETIMEDOUT: return "Connection timed out";
 804d5af:	8d 81 e2 e1 ff ff    	lea    -0x1e1e(%ecx),%eax
 804d5b5:	eb 35                	jmp    804d5ec <strerror+0x71d>
                case ECONNREFUSED: return "Connection refused";
 804d5b7:	8d 81 f7 e1 ff ff    	lea    -0x1e09(%ecx),%eax
 804d5bd:	eb 2d                	jmp    804d5ec <strerror+0x71d>
                case EHOSTDOWN: return "Host is down";
 804d5bf:	8d 81 0a e2 ff ff    	lea    -0x1df6(%ecx),%eax
 804d5c5:	eb 25                	jmp    804d5ec <strerror+0x71d>
                case EHOSTUNREACH: return "No route to host";
 804d5c7:	8d 81 17 e2 ff ff    	lea    -0x1de9(%ecx),%eax
 804d5cd:	eb 1d                	jmp    804d5ec <strerror+0x71d>
                case EALREADY: return "operation already in progress";
 804d5cf:	8d 81 28 e2 ff ff    	lea    -0x1dd8(%ecx),%eax
 804d5d5:	eb 15                	jmp    804d5ec <strerror+0x71d>
                case EINPROGRESS: return "operation now in progress";
 804d5d7:	8d 81 46 e2 ff ff    	lea    -0x1dba(%ecx),%eax
 804d5dd:	eb 0d                	jmp    804d5ec <strerror+0x71d>
                case ESTALE: return "Stale NFS file handle";
 804d5df:	8d 81 60 e2 ff ff    	lea    -0x1da0(%ecx),%eax
 804d5e5:	eb 05                	jmp    804d5ec <strerror+0x71d>
                default: return 0;
 804d5e7:	b8 00 00 00 00       	mov    $0x0,%eax
        }
}
 804d5ec:	5d                   	pop    %ebp
 804d5ed:	c3                   	ret    
